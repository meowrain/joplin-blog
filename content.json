{"meta":{"title":"知识库","subtitle":"","description":"","author":"Public","url":"http://example.com","root":"/"},"pages":[{"title":"Categories","date":"2023-02-02T04:51:27.644Z","updated":"2023-02-02T04:51:27.644Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"[object Object]","date":"2023-02-02T04:51:27.644Z","updated":"2023-02-02T04:51:27.644Z","comments":true,"path":"scaffolds/embed.html","permalink":"http://example.com/scaffolds/embed.html","excerpt":"","text":""},{"title":"Tags","date":"2023-02-02T04:53:40.780Z","updated":"2023-02-02T04:51:27.644Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"About","date":"2023-02-02T04:51:27.644Z","updated":"2023-02-02T04:51:27.644Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"[object Object]","date":"2023-02-02T04:51:27.644Z","updated":"2023-02-02T04:51:27.644Z","comments":true,"path":"scaffolds/post.html","permalink":"http://example.com/scaffolds/post.html","excerpt":"","text":"参考资料"}],"posts":[{"title":"Java-冒泡排序","slug":"03f3dd343d094bd6baf6772f4a6a2aed","date":"2023-01-25T12:04:13.541Z","updated":"2023-01-25T12:04:20.206Z","comments":true,"path":"2023/01/25/03f3dd343d094bd6baf6772f4a6a2aed/","link":"","permalink":"http://example.com/2023/01/25/03f3dd343d094bd6baf6772f4a6a2aed/","excerpt":"","text":"1234567891011121314151617181920212223package sort;import java.util.Arrays;//冒泡排序模板public class bubble_sort &#123; public static void main(String[] args) &#123; int[] arr = &#123;44,-30,20,100,22&#125;; bubble_sort(arr); System.out.println(Arrays.toString(arr)); &#125; public static void bubble_sort(int[] arr)&#123; for (int i = 0; i &lt; arr.length-1; i++) &#123; for (int j = 0; j &lt; arr.length-1-i; j++) &#123; if(arr[j]&gt;arr[j+1])&#123; int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"JAVASE","slug":"Java/JAVASE","permalink":"http://example.com/categories/Java/JAVASE/"}],"tags":[]},{"title":"javascript-事件流","slug":"6d5690c11c9c40d9ab1e41f85c32ea0d","date":"2023-01-25T12:02:46.533Z","updated":"2023-01-25T12:02:53.757Z","comments":true,"path":"2023/01/25/6d5690c11c9c40d9ab1e41f85c32ea0d/","link":"","permalink":"http://example.com/2023/01/25/6d5690c11c9c40d9ab1e41f85c32ea0d/","excerpt":"","text":"事件流事件流指的是事件完整执行过程中的流动路径 捕获：父到子 冒泡：子到父 事件冒泡概念：当一个元素的事件被处罚时，同样的事情将会在该元素的所有祖先元素中依次被触发。这一过程被称为事件冒泡 冒泡阶段案例： 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father &#123; margin: 100px auto; width: 500px; height: 500px; background-color: pink; &#125; .son &#123; width: 200px; height: 200px; background-color: blueviolet; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; let fa = document.querySelector(&#x27;.father&#x27;); let son = document.querySelector(&#x27;.son&#x27;); fa.addEventListener(&#x27;click&#x27;,function()&#123; alert(&#x27;hello i am father&#x27;); &#125;) son.addEventListener(&#x27;click&#x27;,function() &#123; alert(&#x27;hello i am son&#x27;) &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上述案例中，儿子和父亲元素已经全部被创建了点击事件，但是我们在点击儿子元素后，不仅儿子的点击事件会被触发，父亲的点击事件也会被触发 如下动图： 捕获阶段1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father &#123; margin: 100px auto; width: 500px; height: 500px; background-color: pink; &#125; .son &#123; width: 200px; height: 200px; background-color: blueviolet; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; let fa = document.querySelector(&#x27;.father&#x27;); let son = document.querySelector(&#x27;.son&#x27;); fa.addEventListener(&#x27;click&#x27;, function () &#123; alert(&#x27;hello i am father&#x27;); &#125;, true) son.addEventListener(&#x27;click&#x27;, function () &#123; alert(&#x27;hello i am son&#x27;) &#125;, true) document.addEventListener(&#x27;click&#x27;, function () &#123; alert(&#x27;grandfather&#x27;) &#125;, true) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 我们点击儿子元素后，会依次触发爷爷，父亲，儿子 如下图 阻止事件流动目标：能够写出阻止事件流动的代码 因为默认就有冒泡模式的存在，所以容易导致事件影响到父级元素 若想把事件就限制在当前元素内，就需要阻止事件流动 阻止事件流动需要拿到事件对象 语法： 1事件对象.stopPropagation() 案例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father &#123; margin: 100px auto; width: 500px; height: 500px; background-color: pink; &#125; .son &#123; width: 200px; height: 200px; background-color: blueviolet; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; let fa = document.querySelector(&#x27;.father&#x27;); let son = document.querySelector(&#x27;.son&#x27;); document.addEventListener(&#x27;click&#x27;, function (e) &#123; alert(&#x27;grandfather&#x27;); e.stopPropagation();//阻止流动 &#125;) fa.addEventListener(&#x27;click&#x27;, function (e) &#123; alert(&#x27;hello i am father&#x27;); e.stopPropagation();//阻止流动 &#125;) son.addEventListener(&#x27;click&#x27;, function (e) &#123; alert(&#x27;hello i am son&#x27;); e.stopPropagation(); //阻止流动 &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果如下：","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Javascript","slug":"前端/Javascript","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/Javascript/"}],"tags":[]},{"title":"javascript-DOM-分时问候案例","slug":"97466e0ebd1f48c8836d82a772e97d39","date":"2023-01-25T12:02:25.056Z","updated":"2023-01-25T12:02:30.997Z","comments":true,"path":"2023/01/25/97466e0ebd1f48c8836d82a772e97d39/","link":"","permalink":"http://example.com/2023/01/25/97466e0ebd1f48c8836d82a772e97d39/","excerpt":"","text":"直接挂代码了 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; img &#123; width: 300px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;img src=&quot;https://tse2-mm.cn.bing.net/th/id/OIP-C.5tG321WXo3Mzge2MehLFnwAAAA?pid=ImgDet&amp;rs=1&quot; alt=&quot;&quot;&gt; &lt;div&gt;早上好啊，MeowRain&lt;/div&gt; &lt;script src=&quot;../js/分时问候.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425// 根据系统不同时间来判断，所以需要用到日期内置对象// 利用多分支语句来设置不同的图片// 需要一个图片，并且根据时间修改图片，就需要用到操作元素src属性// 需要一个div元素，显示不同问候语，修改元素内容即可//获取元素let img = document.querySelector(&#x27;img&#x27;);let div = document.querySelector(&#x27;div&#x27;);//得到小时数let date = new Date();let h = date.getHours;// 判断小时数改变图片的文字和信息if (h &lt; 12) &#123; img.src = &#x27;https://tse2-mm.cn.bing.net/th/id/OIP-C.5tG321WXo3Mzge2MehLFnwAAAA?pid=ImgDet&amp;rs=1&#x27;; div.innerHTML = &#x27;&lt;strong&gt;早上好呀，MeowRain&lt;/strong&gt;&#x27;;&#125; else if (12&lt;h &amp;&amp; h&lt;13) &#123; img.src = &#x27;https://img95.699pic.com/element/40095/5149.png_300.png&#x27;; div.innerHTML = &#x27;&lt;strong&gt;中午好呀，MeowRain,别忘记要午休哦~&lt;/strong&gt;&#x27;;&#125; else if (13&lt;h &amp;&amp; h&lt;18) &#123; img.src = &#x27;https://ts1.cn.mm.bing.net/th/id/R-C.832e8b33a5ef7e2ae1b6027737696a05?rik=d2HweNtwgVdumg&amp;riu=http%3a%2f%2fface.zhaoxi.org%2fupload%2f201358%2f20130121193605.gif&amp;ehk=1mIMalbTaUnKu5AhchtHA8ybQmrJ70%2bYb70ugW678Dw%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0&#x27;; div.innerHTML =&#x27;&lt;strong&gt;下午好呀，MeowRain,天气热啦，可以喝杯可乐奥&lt;/strong&gt;&#x27;;&#125; else &#123; img.src = &#x27;https://tse1-mm.cn.bing.net/th/id/OIP-C.eFjfpAX9hBBc7r5pcSiomQAAAA?pid=ImgDet&amp;rs=1&#x27;; div.innerHTML = &#x27;&lt;strong&gt;晚上好呀，MeowRain,记住早早睡觉奥&lt;/strong&gt;&#x27;;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Javascript","slug":"前端/Javascript","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/Javascript/"}],"tags":[]},{"title":"Java-递归执行机制","slug":"b3ada79e6ff745f0acd8edcf57c95acc","date":"2023-01-25T12:01:56.477Z","updated":"2023-01-25T12:02:05.124Z","comments":true,"path":"2023/01/25/b3ada79e6ff745f0acd8edcf57c95acc/","link":"","permalink":"http://example.com/2023/01/25/b3ada79e6ff745f0acd8edcf57c95acc/","excerpt":"","text":"代码参考如下； 1234567891011121314151617public class test &#123; public static void main(String[] args) &#123; method fac = new method(); System.out.println(fac.factorial(3)); &#125;&#125;class method &#123; public int factorial(int n) &#123; System.out.println(n); if (n == 1) &#123; return 1; &#125; else &#123; return factorial(n-1) * n; &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"JAVASE","slug":"Java/JAVASE","permalink":"http://example.com/categories/Java/JAVASE/"}],"tags":[]},{"title":"Java-包装类","slug":"d5d66a7ebad94d6483e19407faf46cc5","date":"2023-01-25T12:01:33.789Z","updated":"2023-01-25T12:01:38.433Z","comments":true,"path":"2023/01/25/d5d66a7ebad94d6483e19407faf46cc5/","link":"","permalink":"http://example.com/2023/01/25/d5d66a7ebad94d6483e19407faf46cc5/","excerpt":"","text":"包装类包装类的分类 针对八种基本定义相应的引用类型–包装类 有了类的特点，就可以调用类中的方法 上面这个包装类的父类都是Number 包装类和基本数据类型的转换装箱： 基本类型-&gt;包装类型拆箱： 包装类型-&gt;基本类型自动装箱底层调用的是valueOf方法，比如Integer.valueOf() 12345678910111213141516171819package cn.meowrain.WrapperClass;public class WrapperType &#123; public static void main(String[] args) &#123; //手动装箱 int a = 10; Integer n1 = new Integer(a); Integer n2 = Integer.valueOf(a); //手动拆箱 int b = n1.intValue(); int c = n2.intValue(); //自动装箱 int d = 20; Integer n3 = d; //自动拆箱 int e = n3; &#125;&#125; 包装类型和String类型的相互转换1234567891011121314151617181920212223242526272829package cn.meowrain.WrapperClass;public class wrapper02 &#123; public static void main(String[] args) &#123; //包装类型--》 String类型 //----------方式1---------- Integer i = 10; String s1 = i.toString(); //------方式2-------- String s2 = String.valueOf(i); //--------方式3--------- String s3 = i + &quot;&quot;; //---------------- //String 类型--》包装类 //方式1 Integer j = new Integer(s1); //方式2 Integer j2 = Integer.valueOf(s2); Integer j3 = Integer.parseInt(s3); &#125;&#125; Integer类和Character类的常用方法1234567891011121314151617package cn.meowrain.WrapperClass;public class wrapper03 &#123; public static void main(String[] args) &#123; System.out.println(Integer.MAX_VALUE);//返回最大值 System.out.println(Integer.MIN_VALUE);//返回最小值 System.out.println(Character.isDigit(&#x27;a&#x27;));//判断是不是数字 System.out.println(Character.isLetter(&#x27;a&#x27;));//判断是不是字母 System.out.println(Character.isUpperCase(&#x27;A&#x27;));//判断是不是大写 System.out.println(Character.isLowerCase(&#x27;a&#x27;));//判断是不是小写 System.out.println(Character.isWhitespace(&#x27; &#x27;)); //判断是不是空格 System.out.println(Character.toUpperCase(&#x27;a&#x27;));//转成大写 System.out.println(Character.toLowerCase(&#x27;A&#x27;));//转成小写 &#125;&#125; Java Integer创建机制1234567891011121314package cn.meowrain.WrapperClass;public class wrapper04 &#123; public static void main(String[] args) &#123; Integer n1 = 1; Integer n2 = 1; System.out.println(n1 == n2); //true // -128 ~ 127 Integer n3 = 128; Integer n4 = 128; System.out.println(n3 == n4); //false &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"JAVASE","slug":"Java/JAVASE","permalink":"http://example.com/categories/Java/JAVASE/"}],"tags":[]},{"title":"Java-枚举","slug":"abec654a37ad4a498798cdf019a2e61e","date":"2023-01-25T12:01:24.108Z","updated":"2023-01-25T12:01:24.722Z","comments":true,"path":"2023/01/25/abec654a37ad4a498798cdf019a2e61e/","link":"","permalink":"http://example.com/2023/01/25/abec654a37ad4a498798cdf019a2e61e/","excerpt":"","text":"Java-枚举自定义类实现枚举 1234567891011121314151617181920212223242526272829303132333435363738394041424344package cn.meowrain.enum_;public class Enumeration02 &#123; public static void main(String[] args) &#123; System.out.println(Season.spring); &#125;&#125;//演示自定义枚举实现class Season &#123; private String name; private String desc; //定义了四个对象 //1.将构造器私有化，防止直接new//2.去掉setxx方法，防止属性被修改//3.在Season内部，直接创建固定的对象 //4.优化，可以加入final public static final Season spring = new Season(&quot;春天&quot;, &quot;温暖&quot;); public static final Season summer = new Season(&quot;夏天&quot;, &quot;炎热&quot;); public static final Season autumn = new Season(&quot;秋天&quot;, &quot;凉爽&quot;); public static final Season winter = new Season(&quot;冬天&quot;, &quot;寒冷&quot;); private Season(String name, String desc) &#123; this.name = name; this.desc = desc; &#125; public String getName() &#123; return name; &#125; public String getDesc() &#123; return desc; &#125; @Override public String toString() &#123; return &quot;Season&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, desc=&#x27;&quot; + desc + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; enum关键字实现枚举1234567891011121314151617181920212223242526272829303132333435363738394041424344package cn.meowrain.enum_;public class Enumeration03 &#123; public static void main(String[] args) &#123; System.out.println(Season2.SPRING); System.out.println(Season2.SUMMER); System.out.println(Season2.AUTTUMN); System.out.println(Season2.WINTER); &#125;&#125;//是同enum关键字实现enum Season2 &#123; //如果使用了enum来实现枚举类 //1.使用关键字enum替代class //2.public static Season spring = new Season(&quot;春天&quot;, &quot;温暖&quot;);使用 //spring(&quot;春天&quot;,&quot;温暖&quot;);替代 //SPRING(&quot;春天&quot;, &quot;温暖&quot;); 解读 常量名（实参列表） //3.如果有多个常量（对象），使用,分割即可 SPRING(&quot;春天&quot;, &quot;温暖&quot;), SUMMER(&quot;夏天&quot;, &quot;热&quot;), AUTTUMN(&quot;秋天&quot;, &quot;凉爽&quot;), WINTER(&quot;冬天&quot;, &quot;寒冷&quot;); private String name; private String desc; private Season2(String name, String desc) &#123; this.name = name; this.desc = desc; &#125; public String getName() &#123; return name; &#125; public String getDesc() &#123; return desc; &#125; @Override public String toString() &#123; return &quot;Season2&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, desc=&#x27;&quot; + desc + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; enum常用方法 课堂练习 123456789101112131415161718192021222324252627282930package cn.meowrain.enum_;public class Enumeration05 &#123; public static void main(String[] args) &#123; Week[] days = Week.values(); for (Week day : days) &#123; System.out.println(day.toString()); &#125; &#125;&#125;enum Week &#123; Monday(&quot;星期一&quot;), TUESDAY(&quot;星期二&quot;), WEDNESDAY(&quot;星期三&quot;), THURSDAY(&quot;星期四&quot;), FRIDAY(&quot;星期五&quot;), SATURDAY(&quot;星期六&quot;), SUNDAY(&quot;星期日&quot;); private String name; Week(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return name; &#125;&#125; enum实现接口 使用enum关键字后，就不能再继承其他类了，因为enum会隐式继承Enum,而Java是单继承机制 枚举类和普通类一样，可以实现接口，如下格式： enum 类名 implements 接口1,接口2&#123;&#125; 案例： 12345678910111213141516171819package cn.meowrain.enum_;public class Enumeration06 &#123; public static void main(String[] args) &#123; Music.CLASSMUSIC.playing(); Music.POPMUSIC.playing(); &#125;&#125;interface IPlaying &#123; public void playing();&#125;enum Music implements IPlaying&#123; CLASSMUSIC, POPMUSIC; public void playing() &#123; System.out.println(&quot;播放好听的音乐&quot; + this.name()); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"JAVASE","slug":"Java/JAVASE","permalink":"http://example.com/categories/Java/JAVASE/"}],"tags":[]},{"title":"java选择排序","slug":"d8cc29145a834e3aaa2a43b7d88c9ce1","date":"2023-01-25T12:00:20.080Z","updated":"2023-01-25T12:00:32.240Z","comments":true,"path":"2023/01/25/d8cc29145a834e3aaa2a43b7d88c9ce1/","link":"","permalink":"http://example.com/2023/01/25/d8cc29145a834e3aaa2a43b7d88c9ce1/","excerpt":"","text":"12345678910111213141516171819202122232425262728package sort;import java.util.Arrays;//选择排序模板public class select_sort &#123; public static void main(String[] args) &#123; int[] arr = new int[]&#123;10,20,-10,40,199,2,100&#125;; select_sort(arr); System.out.println(Arrays.toString(arr)); &#125; public static void select_sort(int[] arr)&#123; for(int i = 0;i&lt;arr.length-1;i++)&#123; int min = arr[i]; int min_index = i; for(int j = i+1;j&lt;arr.length;j++)&#123; if(min&gt;arr[j])&#123; min = arr[j]; min_index = j; &#125; &#125; if(i != min_index)&#123; arr[min_index] = arr[i]; arr[i] = min; &#125; &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"JAVASE","slug":"Java/JAVASE","permalink":"http://example.com/categories/Java/JAVASE/"}],"tags":[]},{"title":"javascript- 节点增加创建与追加-","slug":"3eb18b717005473285e60b95a1783d27","date":"2023-01-25T12:00:02.012Z","updated":"2023-01-25T12:00:09.662Z","comments":true,"path":"2023/01/25/3eb18b717005473285e60b95a1783d27/","link":"","permalink":"http://example.com/2023/01/25/3eb18b717005473285e60b95a1783d27/","excerpt":"","text":"增加节点很多情况下，我们需要在页面中增加元素 比如，点击发布按钮，可以新增一条信息 一般情况下，我们新增节点，按照如下操作 创建一个新的节点’ 把创建的新的节点放入到指定的元素内部 创建元素节点1document.createElement(&#x27;标签名&#x27;); 追加节点12父元素.appendChild(要插入的元素); //插入到父元素的后面父元素.insertBefore(要插入的元素); //插入到父元素的前面 案例： 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt;&lt;/ul&gt;&lt;script&gt;let ul = document.querySelector(&#x27;ul&#x27;);let li = document.createElement(&#x27;li&#x27;); //&lt;!-- 创建新的标签--&gt;ul.appendChild(li); //向ul插入li元素&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 把3插入到1,2,4,之间 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;4&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;&lt;!-- 创建新的标签--&gt;let ul = document.querySelector(&#x27;ul&#x27;);let li = document.createElement(&#x27;li&#x27;); //创建元素lili.innerText = &#x27;3&#x27;; //在li元素中添加3ul.insertBefore(li,ul.children[2]); //因为ul里面的子元素li是以数组形式存储的，所以这段代码的意思是，把3加在原来数组[2]也就是4的前面 ----》 注意： [0]是1 [1]是2 [2]是4&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Javascript","slug":"前端/Javascript","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/Javascript/"}],"tags":[]},{"title":"javascript-变量提升","slug":"bf50528806834aada4bf812a6e5cb4d7","date":"2023-01-25T11:59:53.611Z","updated":"2023-01-25T11:59:54.335Z","comments":true,"path":"2023/01/25/bf50528806834aada4bf812a6e5cb4d7/","link":"","permalink":"http://example.com/2023/01/25/bf50528806834aada4bf812a6e5cb4d7/","excerpt":"","text":"javascript-变量提升var123console.log(web);var web = &quot;meowrain&quot;;//undefined 这串代码相当于 12var web;console.log(web); 但是你不写var web的话，会直接报错 在js中,var会变量提升，但let不会 123console.log(web);let web = &quot;nce&quot;;// 会报错 let&amp;const暂时性死区TDC 使用let声明变量，必须在声明之后使用变量，不能再声明之前使用变量 123console.log(web);let web = &quot;nce&quot;;// 会报错","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Javascript","slug":"前端/Javascript","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/Javascript/"}],"tags":[]},{"title":"Java异常处理","slug":"cefb06ca6f8049a99703cf1b3bc1fa3d","date":"2023-01-25T11:59:30.701Z","updated":"2023-01-25T11:59:31.418Z","comments":true,"path":"2023/01/25/cefb06ca6f8049a99703cf1b3bc1fa3d/","link":"","permalink":"http://example.com/2023/01/25/cefb06ca6f8049a99703cf1b3bc1fa3d/","excerpt":"","text":"Java异常处理123456789101112131415package cn.meowrain.Erro_Exception;public class erro1 &#123; public static void main(String[] args) &#123; int n1 = 10; int n2 = 0; int res = 0; try &#123; res = n1/n2; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;程序继续执行&quot;); &#125;&#125; 抛出异常 基本概念Java语言中,把程序执行中发生的不正常情况称为异常 执行过程中发生的异常事件可以分为两类 Error(错误): Java虚拟机无法解决的严重问题,如:JVM系统内部错误,资源耗尽等严重情况.比如:StackOverflowErro(栈溢出)和OOM(out of memory),Erro是严重错误,程序会崩溃 Exception:其它因编程错误或偶然的外在因素导致的一般性问题,可以使用针对性的代码进行处理Exception分为两大类: 运行时异常和编译时异常 异常体系图 常见运行异常 NullPointerException 空指针异常 ArithmeticException 数学运算异常 ArrayIndexOutOfBoundsException 数组下标越界异常 ClassCastException 类型转换异常 NumberFormatException 数字格式不正确异常 空指针异常当应用程序试图在需要对象的地方使用null时,抛出该异常 1234567891011121314package cn.meowrain.Erro_Exception;public class erro2 &#123; public static void main(String[] args) &#123; Animal animal = null; animal.eat(); &#125;&#125;class Animal &#123; public void eat() &#123; System.out.println(&quot;animal eat food&quot;); &#125;&#125; 数学运算异常12345678910package cn.meowrain.Erro_Exception;public class erro2 &#123; public static void main(String[] args) &#123; int a = 10; int b = 0; int res = a/b; System.out.println(res); &#125;&#125; 数组下标越界异常1234567891011package cn.meowrain.Erro_Exception;public class erro3 &#123; public static void main(String[] args) &#123; int [] arr = new int[10]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = i; &#125; System.out.println(arr[10]); &#125;&#125; 类型转换异常123456789101112package cn.meowrain.Erro_Exception;public class erro4 &#123; public static void main(String[] args) &#123; A a = new B(); C c = (C)a; System.out.println(c); &#125;&#125;class A &#123;&#125;class B extends A &#123;&#125;class C extends A &#123;&#125; 数字格式不正确123456789101112package cn.meowrain.Erro_Exception;public class erro5 &#123; public static void main(String[] args) &#123; String name = &quot;1234&quot;; int num = Integer.parseInt(name); System.out.println(num); String name2 = &quot;nice&quot;; int num2 = Integer.parseInt(name2); System.out.println(name2); &#125;&#125; 编译异常 编译异常是指在编译期间,就必须处理的异常,否则代码不能通过编译 常见的编译异常 SQLException &#x2F;&#x2F;操作数据库是,查询表可能发生异常 IOException &#x2F;&#x2F;操作文件时,发生的异常 FileNotFoundException &#x2F;&#x2F;当操作一个不存在的文件时,发生异常 ClassNotFoundException &#x2F;&#x2F;加载类,而该类不存在时,异常 EOFException &#x2F;&#x2F;操作文件,到文件末尾,发生异常 ILLegalArgumentException &#x2F;&#x2F;参数异常 异常处理基本介绍异常处理就是当异常发生时,对异常处理的方式 try-catch-finally程序员在代码中捕获发生的异常,自行处理 throws将发生的异常抛出,交给调用者来处理,最顶级的处理者就是jvm try &#123; 代码/可能有异常 &#125;catch(Exception e)&#123; //捕获到异常 1. 当异常发生时 2. 系统将异常封装成Exception对象e,传递给catch &#125;finally&#123; //不管try代码块是否有异常发生,始终要执行finally &#125; try-catch方式处理异常-注意事项 如果异常发生了,则异常发生后面的代码不会执行,直接进入到catch块 如果异常没有发生,则顺序执行try的代码块,不会进入到catch 如果希望不管是否发生异常,都执行某段代码(比如关闭连接,释放资源等),在后面加finally 如果出现异常，则try块中异常发生后，try块中剩余的代码不会执行，将执行catch块中的语句，如果有finally，最后还需要执行finally里面的语句。 123456789101112131415package cn.meowrain.Erro_Exception;public class erro6 &#123; public static void main(String[] args) &#123; try &#123; String name = &quot;hellow&quot;; System.out.println(Integer.parseInt(name)); System.out.println(&quot;helloworld&quot;); &#125; catch (NumberFormatException e) &#123; System.out.println(&quot;错误:&quot; + e.getMessage()); &#125; System.out.println(&quot;程序结束&quot;); &#125;&#125; 运行结果: 可以看到,捕获到异常后没有执行`System.out.println(“helloworld”);验证了1,2,3 捕获多个异常123456789101112131415161718192021222324252627282930package cn.meowrain.Erro_Exception;public class erro7 &#123; public static void main(String[] args) &#123; try &#123; int[] arr = new int[10]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = i; &#125; System.out.println(arr[10]); //ArrayIndexOutOfBoundsException int n1 = 10, n2 = 0; int res = n1 / n2;//ArithmeticException System.out.println(res); Person person = new Person(); person = null; System.out.println(person.getName()); //NullPointerException &#125; catch (NullPointerException | ArrayIndexOutOfBoundsException | ArithmeticException e) &#123; System.out.println(e.getMessage()); &#125; &#125;&#125;class Person &#123; String name = &quot;mike&quot;; public String getName() &#123; return name; &#125;&#125; 运行结果：由上可以看出，是数组下标越界了 try-catch最佳实践12345678910111213141516171819202122package cn.meowrain.Erro_Exception;import java.util.Scanner;public class erro8 &#123; public static void main(String[] args) &#123; String inputStr = &quot;&quot;; int num; System.out.println(&quot;请输入一个整数： &quot;); while (true) &#123; Scanner sc = new Scanner(System.in); inputStr = sc.next(); try&#123; num = Integer.parseInt(inputStr); break; &#125;catch (Exception e)&#123; System.err.println(&quot;你输入的不是整数，请重新输入&quot;); &#125; &#125; &#125;&#125; 运行结果： throws异常处理","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"JAVASE","slug":"Java/JAVASE","permalink":"http://example.com/categories/Java/JAVASE/"}],"tags":[]},{"title":"javascript-克隆节点&&删除节点","slug":"5b879117bcd14d1f8a9850b134549a71","date":"2023-01-25T11:59:02.219Z","updated":"2023-01-25T11:59:20.608Z","comments":true,"path":"2023/01/25/5b879117bcd14d1f8a9850b134549a71/","link":"","permalink":"http://example.com/2023/01/25/5b879117bcd14d1f8a9850b134549a71/","excerpt":"","text":"克隆节点12 元素.cloneNode(布尔值);//克隆一个已有的元素节点 详细说明 123456789101112&lt;ul&gt; &lt;li&gt;df&lt;/li&gt;&lt;/ul&gt; &lt;script&gt;let ul = document.querySelector(&quot;ul&quot;);let newul = ul.cloneNode(false);//默认为false，也就是不会克隆子代节点// 如果为true，就会克隆子代节点div.appendChild(newul);//如果我写成div.appendChild(ul);，会把ul和它的子元素全部加在div下//如果写成上面的这种div.appendChild(newul);就会复制一个ul，放在div下 &lt;/script&gt; false的情况： true的情况： 这里咱们专门放图来看一下，顺便复习一下昨天学习的东西 注意：通过指定元素.appendChild(要插入的元素)这个操作，我们可以把某个元素放到指定元素的内部 Tips:要插入的元素，咱们要通过 let ul = document.querySelector(&quot;ul&quot;);这种类似的操作先获取元素 删除节点如果一个节点在页面中已经不需要的时候，我们可以删除它 在javascript对的原生dom操作中，要删除元素必须通过父元素删除 语法 1父元素.removeChild(要删除的元素); Question1: 删除父元素中的第i个元素 咱们平时用这个只是删除一个元素。 但是要知道的是，假如你在ul标签内有4个li标签，那么通过ul.children我们就可以得到一个伪数组，第一个li标签对应0，第二个li标签对应1，以此类推，第四个li标签对应3.得到伪数组以后，我们要删除第一个元素，直接用ul.removeChild(ul.children[i])就能删除咱们第i个元素啦 Question2: 删除父元素中的所有元素 那么问题来了，假如我要全部把这个父元素下的所有子元素删除掉呢？ 第一种方案：使用for循环加.innerHTML的DOM操作，来把咱们的子元素替换为&#39;&#39; 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button class=&quot;btn&quot;&gt;删除&lt;/button&gt; &lt;ul&gt; &lt;li&gt;湖上秋风病未禁，兴来真欲到山阴。&lt;/li&gt; &lt;li&gt; 渔蓑乱结汀洲草，樵径香分橘柚林。&lt;/li&gt; &lt;li&gt;远谷采薇随鹿迹，閒岩投果见猿心。&lt;/li&gt; &lt;li&gt;放歌未尽空回棹，落日增波忧思侵。 &lt;/li&gt; &lt;/ul&gt; &lt;script&gt; let ul = document.querySelector(&#x27;ul&#x27;);//获取元素ul let btn = document.querySelector(&#x27;.btn&#x27;);//获取元素button function del() &#123; for (let i = 0; i &lt; ul.children.length; i++) &#123; ul.children[i].innerHTML = &#x27;&#x27; &#125;//利用for循环，把ul的子元素li一个一个都替换成&#x27;&#x27;，实现删除的效果 &#125;//构建del()函数，方便下面的监听回调此函数 btn.addEventListener(&#x27;click&#x27;, del);//回调del()函数 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在上面这个代码中，我们点击按钮，就可以把li全部替换为空 第二种方案：通过删除节点的办法来把父元素里面的子元素全部删除 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button class=&quot;btn&quot;&gt;删除&lt;/button&gt; &lt;ul&gt; &lt;li&gt;湖上秋风病未禁，兴来真欲到山阴。&lt;/li&gt; &lt;li&gt; 渔蓑乱结汀洲草，樵径香分橘柚林。&lt;/li&gt; &lt;li&gt;远谷采薇随鹿迹，閒岩投果见猿心。&lt;/li&gt; &lt;li&gt;放歌未尽空回棹，落日增波忧思侵。 &lt;/li&gt; &lt;/ul&gt; &lt;script&gt; let ul = document.querySelector(&#x27;ul&#x27;); let btn = document.querySelector(&#x27;.btn&#x27;); function del() &#123; for (let j = ul.children.length - 1; j &gt;= 0; j--) &#123; ul.removeChild(ul.children[j]); &#125; &#125; //这下大概需要慢慢解释一下，因为循环如果写成正的话，就会从第一个元素开始移除，但是你移除掉[0]对应的元素以后，下面的原来是在[1]上的元素会变成在[0]上的元素，所以最后是删不尽的 //因此我们需要想办法让它倒着删，这样就没有问题了。 //下面讲解一下上面的循环运行过程：//第一步,首先拿到了ul伪数组的个数4，那么最后一个元素对应的就是[3]，为了删掉这个元素，//我们需要让ul.children.length - 1来实现首先删除最后一个元素//第二步，会判断是不是大于等于0，这个是为了能让函数最后删除的是[0]的这个元素 btn.addEventListener(&#x27;click&#x27;, del); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Javascript","slug":"前端/Javascript","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/Javascript/"}],"tags":[]},{"title":"Javascript-展开语法","slug":"2601a78cd4fb449e90738af73cc0370d","date":"2023-01-25T11:58:52.498Z","updated":"2023-01-25T11:58:53.210Z","comments":true,"path":"2023/01/25/2601a78cd4fb449e90738af73cc0370d/","link":"","permalink":"http://example.com/2023/01/25/2601a78cd4fb449e90738af73cc0370d/","excerpt":"","text":"Javascript-展开语法展开数组12const num = [1,2,3];console.log(...num); //打印数组元素1,2.3 数组合并123let a = [1,2,3];let b = [&#x27;a&#x27;,&#x27;nice&#x27;,...a];//使用...可将a合并到b数组console.log(b);//[ &#x27;a&#x27;, &#x27;nice&#x27;, 1, 2, 3 ] 展开对象12345const career = &#123;career:&quot;Student&quot;&#125;;const hobby = &#123;hobby: &quot;game,music,programing&quot;&#125;;const who = &#123;name:&quot;meowrain&quot;,...career,...hobby&#125;;console.log(who);//&#123; name: &#x27;meowrain&#x27;, career: &#x27;Student&#x27;, hobby: &#x27;game,music,programing&#x27; &#125; 函数传参使用...name来接收任意数量的参数 12345function change(...args) &#123; console.log(args);&#125;change(1,2,3,4,5,&#x27;ww&#x27;);//[ 1, 2, 3, 4, 5, &#x27;ww&#x27; ] 案例： 123456let sum = (x, y, z) =&gt; &#123; return x + y + z;&#125; //创建名为sum的函数const num = [1,2,3];console.log(...num); //1,2.3console.log(sum(...num));//传参1,2,3","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Javascript","slug":"前端/Javascript","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/Javascript/"}],"tags":[]},{"title":"Java数据结构-栈","slug":"e7838ce563844f3a9811936eaa09cb09","date":"2023-01-25T11:58:21.166Z","updated":"2023-01-25T11:59:41.433Z","comments":true,"path":"2023/01/25/e7838ce563844f3a9811936eaa09cb09/","link":"","permalink":"http://example.com/2023/01/25/e7838ce563844f3a9811936eaa09cb09/","excerpt":"","text":"Stack.java 123456789101112131415161718192021222324252627282930313233package cn.meowrain.Datastructure.collection;import java.util.NoSuchElementException;public class Stack&lt;E&gt; &#123; private final Node&lt;E&gt; head = new Node&lt;&gt;(null); public void push(E element)&#123; Node&lt;E&gt; node = new Node&lt;&gt;(element); node.next = head.next; head.next = node; &#125; public E pop()&#123; if(head.next == null)&#123; throw new NoSuchElementException(&quot;栈为空&quot;);//如果栈中已经没有元素了,就抛出错误 &#125; E e = head.next.element; //先把待出栈元素取出来 head.next = head.next.next; //直接让头结点的下一个指向下一个的下一个 return e; &#125; public boolean isEmpty()&#123; return head.next == null; &#125; private static class Node&lt;E&gt; &#123; private final E element; private Node&lt;E&gt; next; public Node(E e) &#123; this.element = e; &#125; &#125;&#125; StackRunner.java 123456789101112131415package cn.meowrain.Datastructure;import cn.meowrain.Datastructure.collection.Stack;public class StackRunner &#123; public static void main(String[] args) &#123; Stack&lt;String&gt; stack = new Stack&lt;&gt;(); stack.push(&quot;meowrain&quot;); stack.push(&quot;meow&quot;); stack.push(&quot;nice&quot;); String n = stack.pop(); System.out.println(n); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"JAVASE","slug":"Java/JAVASE","permalink":"http://example.com/categories/Java/JAVASE/"}],"tags":[]},{"title":"Java 访问修饰符","slug":"0b0365b51c0644958b204ed11719a88a","date":"2023-01-25T11:57:50.190Z","updated":"2023-01-25T11:58:05.921Z","comments":true,"path":"2023/01/25/0b0365b51c0644958b204ed11719a88a/","link":"","permalink":"http://example.com/2023/01/25/0b0365b51c0644958b204ed11719a88a/","excerpt":"","text":"Java 访问修饰符","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"JAVASE","slug":"Java/JAVASE","permalink":"http://example.com/categories/Java/JAVASE/"}],"tags":[]},{"title":"Java Object类详解","slug":"65905cb7c01348b0b1ac5264ecc87ab0","date":"2023-01-25T11:57:20.709Z","updated":"2023-01-25T11:57:24.588Z","comments":true,"path":"2023/01/25/65905cb7c01348b0b1ac5264ecc87ab0/","link":"","permalink":"http://example.com/2023/01/25/65905cb7c01348b0b1ac5264ecc87ab0/","excerpt":"","text":"Object类详解equals方法=&#x3D; 是一个比较运算符 区分 123456789101112131415161718192021222324252627282930313233343536373839404142package com.hsp.object;public class Equals_exercise02 &#123; public static void main(String[] args) &#123; String name_1 = &quot;hello&quot;; String name_2 = &quot;hello&quot;; System.out.println(name_2 == name_1);//trye /* * String str1 = &quot;abcd&quot;的实现过程：首先栈区创建str引用， * 然后在String池（独立于栈和堆而存在，存储不可变量） * 中寻找其指向的内容为&quot;abcd&quot;的对象，如果String池中没有， * 则创建一个，然后str指向String池中的对象， * 如果有，则直接将str1指向&quot;abcd&quot;&quot;； * 如果后来又定义了字符串变量 str2 = &quot;abcd&quot;, * 则直接将str2引用指向String池中已经存在的“abcd”， * 不再重新创建对象；当str1进行了赋值（str1=“abc”）， * 则str1将不再指向&quot;abcd&quot;，而是重新指String池中的&quot;abc&quot;， * 此时如果定义String str3 = &quot;abc&quot;,进行str1 == str3操作， * 返回值为true，因为他们的值一样，地址一样， * 但是如果内容为&quot;abc&quot;的str1进行了字符串的+连接str1 = str1+&quot;d&quot; * ；此时str1指向的是在堆中新建的内容为&quot;abcd&quot;的对象， * 即此时进行str1==str2，返回值false，因为地址不一样。 String str3 = new String(&quot;abcd&quot;)的实现过程：* 直接在堆中创建对象。* 如果后来又有* String str4 = new String(&quot;abcd&quot;)，str4不会指向之前的对象，* 而是重新创建一个对象并指向它，* 所以如果此时进行str3==str4返回值是false，* 因为两个对象的地址不一样，如果是str3.equals(str4)，* 返回true,因为内容相同。 * */ String name_3 = new String(&quot;hello&quot;); String name_4 = new String(&quot;hello&quot;); System.out.println(name_3 == name_4);//false System.out.println(name_3.equals(name_4)); System.out.println(name_1.equals(name_2)); &#125;&#125; hashCode方法 提高具有哈希结构的容器效率 两个引用，如果指向的是同一个对象，则哈希值肯定是一样的 两个引用，如果指向的是不同的对象，则哈希值是不一样的 哈希值主要根据地址号来的，不能将哈希值等价于地址 1234567891011121314package com.hsp.object;public class HashCode &#123; public static void main(String[] args) &#123; AA aa = new AA(); AA aa2 = new AA(); System.out.println(aa.hashCode()); System.out.println(aa2.hashCode()); /*460141958 1163157884*/ &#125;&#125;class AA &#123;&#125; toString方法基本介绍： 默认返回： 全类名 + @ + 哈希值的十六进制 子类往往重写toString方法，用于返回对象的属性信息 12345678910111213141516171819package com.hsp.object;public class toString &#123; public static void main(String[] args) &#123; Monster monster = new Monster(&quot;妖怪&quot;,&quot;保安&quot;,1000); System.out.println(monster.toString());//com.hsp.object.Monster@1b6d3586 &#125;&#125;class Monster &#123; private String name; private String job; private double sal; public Monster(String name, String job, double sal) &#123; this.name = name; this.job = job; this.sal = sal; &#125;&#125; 重写toString方法，打印对象或拼接对象时，都会自动调用该对象的toString形式 123456789101112131415161718192021222324252627282930package com.hsp.object;public class toString &#123; public static void main(String[] args) &#123; Monster monster = new Monster(&quot;妖怪&quot;,&quot;保安&quot;,1000); System.out.println(monster.toString());//Monster&#123;name=&#x27;妖怪&#x27;, job=&#x27;保安&#x27;, sal=1000.0&#125; &#125;&#125;class Monster &#123; private String name; private String job; private double sal;// 重写toString方法 @Override public String toString() &#123; return &quot;Monster&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, job=&#x27;&quot; + job + &#x27;\\&#x27;&#x27; + &quot;, sal=&quot; + sal + &#x27;&#125;&#x27;; &#125; public Monster(String name, String job, double sal) &#123; this.name = name; this.job = job; this.sal = sal; &#125;&#125; 当直接输出一个对象时候，toString方法会被默认的调用 123456789101112131415161718192021222324252627282930package com.hsp.object;public class toString &#123; public static void main(String[] args) &#123; Monster monster = new Monster(&quot;妖怪&quot;, &quot;保安&quot;, 1000); System.out.println(monster); &#125;&#125;class Monster &#123; private String name; private String job; private double sal;// 重写toString方法 @Override public String toString() &#123; return &quot;Monster&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, job=&#x27;&quot; + job + &#x27;\\&#x27;&#x27; + &quot;, sal=&quot; + sal + &#x27;&#125;&#x27;; &#125; public Monster(String name, String job, double sal) &#123; this.name = name; this.job = job; this.sal = sal; &#125;&#125; finalize()当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法 1.当对象被回收时，系统自动调用该对象的finalize方法。子类可以重写该方法，做一些释放资源的操作 2.什么时候被回收：当某个对象没有任何引用的时候，则jvm就认为这个对象是一个垃圾对象，就会用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用finalize方法 3.垃圾回收机制的调用，是由系统来决定，也可以由System.gc()主动触发垃圾回收机制 实际开发中基本不会运用，应付面试","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"JAVASE","slug":"Java/JAVASE","permalink":"http://example.com/categories/Java/JAVASE/"}],"tags":[]},{"title":"ES6闭包","slug":"acf1e9f487974ce1853395619e12e44d","date":"2023-01-25T11:57:07.832Z","updated":"2023-01-25T11:57:08.623Z","comments":true,"path":"2023/01/25/acf1e9f487974ce1853395619e12e44d/","link":"","permalink":"http://example.com/2023/01/25/acf1e9f487974ce1853395619e12e44d/","excerpt":"","text":"ES6闭包闭包概念**闭包函数：**声明一个在函数中的函数，有权访问另一个函数作用域中变量，叫做闭包函数。（函数嵌套函数） **闭包：**内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后。 **闭包的主要作用：**延伸了变量的作用范围。 以上来源于： https://www.jianshu.com/p/f56971e5274f 案例： 1234567891011function fn() &#123; let max = 10; function uu(x) &#123; if (x &lt; max) &#123; console.log(x); &#125; &#125; //闭包函数 return uu&#125;let f = fn(); // = uu() qu&#x27;chuf(3);","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Javascript","slug":"前端/Javascript","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/Javascript/"}],"tags":[]},{"title":"Debian修改国内原","slug":"761fa1243125429eb927901f3014a91b","date":"2023-01-25T11:56:50.183Z","updated":"2023-01-25T11:58:50.973Z","comments":true,"path":"2023/01/25/761fa1243125429eb927901f3014a91b/","link":"","permalink":"http://example.com/2023/01/25/761fa1243125429eb927901f3014a91b/","excerpt":"","text":"Debian修改国内原 查看debian版本cat /etc/debian_version 修改方法参考下面的文章即可https://developer.aliyun.com/mirror/debian","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[]},{"title":"Java-Math类","slug":"47c9d6ac38214463ae1ca07fd5b85614","date":"2023-01-25T06:27:13.273Z","updated":"2023-01-25T06:27:29.208Z","comments":true,"path":"2023/01/25/47c9d6ac38214463ae1ca07fd5b85614/","link":"","permalink":"http://example.com/2023/01/25/47c9d6ac38214463ae1ca07fd5b85614/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344package cn.meowrain.Math;public class math &#123; public static void main(String[] args) &#123; //1. abs绝对值 int abs = Math.abs(-19); System.out.println(abs); //2.pow求幂 double pow = Math.pow(2, 3); System.out.println(pow); //3.ceil向上取整 double ceil = Math.ceil(3.1); System.out.println(ceil); //4.floor向下取整 double floor = Math.floor(3.6); System.out.println(floor); //5.round四舍五入 double round1 = Math.round(3.4); double round2 = Math.round(3.6); StringBuffer str = new StringBuffer(); str.append(&quot;the round 1 :&quot;).append(round1); str.append(&quot;\\n&quot;).append(&quot;the round2 :&quot;).append(round2); System.out.println(str); //6.sqrt求开平方 double sqrt = Math.sqrt(16); System.out.println(sqrt); //7. random 求随机数 //random 返回随机数 0&lt;=x&lt;1 //如果想去到 2 - 7的随机数 double random = Math.random(); int num = (int)((random)*6+2); System.out.println(num); //max求两个数的最大值 //min求两个数的最小值 int a = 10; int b = 20; int max = Math.max(a, b); int min = Math.min(a, b); System.out.println(&quot;max :&quot; + max + &quot;\\n&quot; + &quot;min :&quot; + min); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"JAVASE","slug":"Java/JAVASE","permalink":"http://example.com/categories/Java/JAVASE/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"Javascript-三种包装对象","slug":"4f2d10c3153e4c7c89f2ecf584fbc453","date":"2023-01-25T06:26:34.064Z","updated":"2023-01-25T06:26:56.263Z","comments":true,"path":"2023/01/25/4f2d10c3153e4c7c89f2ecf584fbc453/","link":"","permalink":"http://example.com/2023/01/25/4f2d10c3153e4c7c89f2ecf584fbc453/","excerpt":"","text":"12345678910111213141516171819202122232425262728let num = 10; console.log(typeof num.toString()); // string let str = &quot;hello world&quot;; console.log(str.split(&quot; &quot;)); // [&quot;hello&quot;,&quot;world&quot;] console.log(str.length);// 11 //三种包装对象 //1. new String() //2. new Number() //3. new Boolean // 原始类型调用方法或属性的时候,程序的后台会把他们转换为相应的包装对象,因此可以使用上面的那些 //对象方法 str = &quot;helloworld&quot;; str.name = &quot;xiaoming&quot;; console.log(str.name); //undefined //转换成包装对象,并且成功执行方法后,包装对象会立即销毁,变量又重新回到原始类型的状态 let num1 = new Number(123); let num2 = new Number(123); console.log(num1 === num2); //false /*上面两个是引用类型,所以地址不同 */ /* 创建包装对象的构造函数可以用来做类型转换 */ let num3 = 123; console.log(String(num3)); console.log(Boolean(num3)); let num4 = 123; console.log(num4.toString());","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Javascript","slug":"前端/Javascript","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/Javascript/"}],"tags":[]},{"title":"水仙花题解","slug":"dd59a1b3ef8343efb5e60f2fd43084a8","date":"2023-01-25T06:25:38.518Z","updated":"2023-01-25T06:26:06.975Z","comments":true,"path":"2023/01/25/dd59a1b3ef8343efb5e60f2fd43084a8/","link":"","permalink":"http://example.com/2023/01/25/dd59a1b3ef8343efb5e60f2fd43084a8/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/*水仙花数是指一个N位正整数(N&gt;=3),它的海个位上的数字的N次幂之和等于它本身。例如：153=1^3+5^3+3^3.本题要求编写程序计算所有N位水仙花数。*/#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;math.h&amp;gt;int main(void)&#123;int N;scanf(&quot;%d&quot;, &amp;N);long limit = pow(10, N);long n, qianwan, baiwan, shiwan, wan, qian, hun, ten, ge, multi, sum;for (n = 100; n &lt; limit; n++)&#123;qianwan = n / 10000000 % 10;//千万baiwan = n / 1000000 % 10;//百万shiwan = n / 100000 % 10;//十万wan = n / 10000 % 10;//求万位qian = n / 1000 % 10;//求千位数hun = n / 100 % 10; //求百位数ten = n / 10 % 10; //求十位数ge = n % 10; //求个位数multi = qianwan * 10000000 + baiwan * 1000000 + shiwan * 100000 + wan * 10000 + qian * 1000 + hun * 100 + ten * 10 + ge;sum = pow(qianwan, N) + pow(baiwan, N) + pow(shiwan, N) + pow(wan, N) + pow(qian, N) + pow(hun, N) + pow(ten, N) + pow(ge, N);if (sum == multi)&#123;printf(&quot;%ld &quot;, multi);&#125;&#125;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/categories/C-C/"}],"tags":[]},{"title":"Javascript 面向对象(OOP)","slug":"732ec77199574e42aa8a3ef00df24d8d","date":"2023-01-25T06:24:07.248Z","updated":"2023-01-25T06:24:07.996Z","comments":true,"path":"2023/01/25/732ec77199574e42aa8a3ef00df24d8d/","link":"","permalink":"http://example.com/2023/01/25/732ec77199574e42aa8a3ef00df24d8d/","excerpt":"","text":"Javascript 面向对象(OOP)语法12345class 类名 &#123; constructor()&#123; &#125;&#125; 举例: 1234567891011//Person类专门用来创建人的对象class Person &#123; constructor(name,age,hooby)&#123; this.name = name; this.age = age; this.hooby = hooby; &#125;&#125;//调用构造函数创建对象创建对象const xiaoming = new Person(&quot;xiaoming&quot;,18,&#x27;programming&#x27;);console.log(xiaoming) instanceOf用法 可以用来检查一个对象是否是由某个类创建,如果某个对象是由某个类创建,那么我们称这个对象是这个类的实例 1234567891011121314151617//Person类专门用来创建人的对象class Person &#123; constructor(name,age,hooby)&#123; this.name = name; this.age = age; this.hooby = hooby; &#125;&#125;class Dog &#123;&#125;//调用构造函数创建对象创建对象const xiaoming = new Person(&quot;xiaoming&quot;,18,&#x27;programming&#x27;);const dog1 = new Dog();console.log(xiaoming instanceof Person); //trueconsole.log(dog1 instanceof Person); //false 属性1234567891011//Person类专门用来创建人的对象class Person &#123; //在类中写属性,每次创建对象,它都会带有这些实例属性 //实例属性只能通过实例访问 name = &quot;meowrian&quot;; age = 17; hobby = &quot;game&quot;&#125;const meowrain = new Person();console.log(meowrain);console.log(meowrain.name,meowrain.age,meowrain.hobby); 静态属性12345678//Person类专门用来创建人的对象class Person &#123; //静态属性只能通过类名去访问 static test = &quot;test静态属性&quot;;&#125;const meowrain = new Person();console.log(Person.test); 方法12345678910//Person类专门用来创建人的对象class Person &#123; name = &quot;meowrain&quot;; sayHello = ()=&gt;&#123; console.log(&quot;Hello~&quot;); &#125;&#125;const p1 = new Person();console.log(p1)p1.sayHello(); 两种添加方法的方式:1234567891011121314class Person &#123; name = &quot;meowrain&quot;; sayHello = ()=&gt;&#123; console.log(&quot;Hello~&quot;); &#125; sayGoodbye()&#123; console.log(&quot;Goodbye~&quot;); &#125; //这种方式直接打印实例对象看不到这个方法&#125;const p1 = new Person();console.log(p1)p1.sayHello();p1.sayGoodbye(); 静态方法(类方法)12345678//Person类专门用来创建人的对象class Person &#123; static sayGG = ()=&gt;&#123; console.log(&quot;GG~&quot;,this);//静态方法中,this指向的是我们的当前类 &#125;&#125;console.log(Person.sayGG()); //只能通过类名来调用 构造函数1234567891011121314class Person &#123; //在类中添加一个特殊的方法constructor //该方法我们称为构造函数 //构造函数会在我们调用类创建对象时候执行 constructor(name, age, gender) &#123; this.name = name; this.age = age; this.gender = gender; console.log(&quot;构造函数执行了&quot;); &#125;&#125;const p1 = new Person(&quot;meowrian&quot;, 18, &quot;男&quot;); //调用类创建一次对象const p2 = new Person(&quot;meow&quot;, 10, &quot;男&quot;); //调用类创建一次对象console.log(p1.name); 封装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//1. 封装// - 对象就是一个用来存储不同属性的容器//对象不仅负责属性,还要负责数据的安全//直接添加到对象中的属性并不安全,因为它们可以被任意修改// 如何确保数据安全//提供setter和getter方法,来开放我们对数据的操作/*实现封装的方式 * 1. 属性私有化 # * 通过getter和setter方法来操作属性 * get 属性名()&#123; * return this.#属性名; * &#125; * set 属性名(value)&#123; * this._属性名 = value; * &#125; * */class Person &#123; //用#表示是私有属性 private,只能在类的内部访问 #name; #age; #gender; constructor(name, age, gender) &#123; this.#name = name; this.#age = age; this.#gender = gender; this._name = name; this._age = age; this._gender = gender; &#125; //getter方法,用来读取属性 get name() &#123; return this.#name; &#125; //这样写getter方法,在访问的时候直接用 实例.属性名就能获得 get age() &#123; return this.#age; &#125; get gender() &#123; return this.#gender; &#125; //setter方法,用来设置属性 set name(value) &#123; this._name = value; &#125; set age(value) &#123; this._age = value; &#125; set gender(value) &#123; this._gender = value; &#125;&#125;const p1 = new Person(&quot;meow&quot;, 17, &quot;男&quot;);console.log(p1.name, p1.age, p1.gender); //这些都是调用的getter方法p1.name = &quot;meowmeow&quot;; //这里调用的是上面的setter方法console.log(p1.name); 多态12345678910111213141516171819202122232425262728293031323334353637383940//多态/* * 在JS中不会检查参数的类型,所以这就意味着任何数据都可以作为参数传递 * 要调用某个函数,无需指定的类型,只需要对象满足某些条件计即可 * * */class Person &#123; constructor(name) &#123; this.name = name; &#125;&#125;class Dog &#123; constructor(name) &#123; this.name = name; &#125;&#125;class Test &#123;&#125;const dog = new Dog(&#x27;旺财&#x27;);const person = new Person(&quot;喵雨&quot;);const test = new Test();// console.log(dog);// console.log(person);/*定义一个函数,这个函数将会接受一个对象作为参数,可以输出hello,并且打印name属性*/const sayHello = (obj)=&gt; &#123; if (obj.name == undefined) &#123; console.log(&quot;没有name属性,hello毛呢&quot;) &#125; else if(obj instanceof Person)&#123; console.log(&quot;Hello 人:&quot; + obj.name); &#125;else &#123; console.log(&quot;Hello &quot;+ obj.name); &#125;&#125;sayHello(dog);sayHello(person);sayHello(test); 继承12345678910111213141516171819202122232425262728293031323334class Animal &#123; constructor(name) &#123; this.name = name; &#125; sayHello() &#123; console.log(&quot;Animal&quot;) &#125;&#125;class Dog extends Animal&#123; constructor(name) &#123; super(name); &#125; sayHello() &#123; console.log(&quot;旺&quot;) &#125; //重写父类方法&#125;class Cat extends Animal&#123; constructor(name) &#123; super(name); &#125; sayHello() &#123; console.log(&quot;meow&quot;) &#125;&#125;const dog = new Dog(&quot;旺财&quot;);const cat = new Cat(&quot;汤姆&quot;);dog.sayHello();cat.sayHello(); 对象的结构 对象中存储属性的区域实际有两个: 对象自身 直接通过对象添加的属性,位于对象自身中 在类中通过x &#x3D; y的形式添加的属性,位于对象自身中 &#96;&#96;&#96;jsclass Person {name &#x3D; “meowrian”age &#x3D; 18fun &#x3D; ()&#x3D;&gt;{ console.log(‘ffff’);}constructor(hobby) { this.hobby &#x3D; hobby}}const p &#x3D; new Person(“打篮球”); 12345678910111213141516*2. 原型对象(**prototype**) * 对象中还有一些内容,会存储在其他的对象里(原型对象) * 在对象中会有一个属性用来存储原型对象,这个属性叫做 **`__proto__`** * ```js class Person &#123; fun()&#123; console.log(&quot;hello&quot;) &#125; //添加到原型中 constructor(hobby) &#123; this.hobby = hobby &#125; &#125; const p = new Person(&quot;打篮球&quot;); console.log(p) 会添加到原型对象中的情况: 在类中通过xxx()&#123;&#125;方式添加的方法,位于原型中 主动向原型中添加的属性和方法 原型相关链接:__proto__和prototype的区别 __proto__1234567891011121314class Person &#123; name = &quot;meowrain&quot; sayHello()&#123;kde ubuntu console.log(&quot;hello,我是&quot; + this.name); &#125;&#125;const p = new Person();/** 访问一个对象的原型对象 对象.__proto__* console.log(Object.getPrototypeOf(对象));* */console.log(p.__proto__);//&#123;constructor: ƒ, sayHello: ƒ&#125;console.log(Object.getPrototypeOf(p));//&#123;constructor: ƒ, sayHello: ƒ&#125; 原型的作用； 原型就相当于是一个公共的区域，可以被所有该类实例访问可以将一个该类实例中所有的公共属性统一存储到原型中这样我们只需要创建一个属性，即可被所有实例访问 prototype123456789class Person &#123; sayHello()&#123; console.log(&quot;hello&quot;) &#125;&#125;const p1 = new Person();console.log(Person.prototype);console.log(Person.prototype === p1.__proto__); //true 可以通过上面两种方式完成类的修改 Object.hasOwn用法 用来检查一个对象的自身是否含有某个属性MDN文档-Object.hasOwn 123456class Man &#123; name = &quot;liming&quot;;&#125;const man1 = new Man();console.log(Object.hasOwn(man1, &quot;name&quot;)) //true 旧类 早期js中,直接通过函数来定义类一个函数如果直接调用xx(),那么这个函数就是一个普通函数一个函数如果通过调用new xxx()那么这个函数就是一个构造函数 1234function Person ()&#123;&#125;const p = new Person(); 上面的等价于下面的 1234class Person &#123; &#125;const p = new Person(); 123456789101112131415161718function Person(name,age)&#123; //构造函数里面写的内容就是class中constructor写的内容 this.name = name; this.age = age; this.sayHello = function ()&#123; console.log(&quot;hello&quot;) &#125;&#125;//向原型中添加Person.prototype.sayNice = function ()&#123; console.log(&quot;nice&quot;)&#125;const p = new Person(&quot;meowrain&quot;,12);console.log(p.name); // meowrainconsole.log(p.age); // 12p.sayHello(); //hellop.sayNice();//niceconsole.log(p); 如上图,从上图我们可以看到,sayNice方法被添加到原型中了 旧类静态属性,静态方法…123456789101112131415161718192021222324252627var Person = ( function () &#123; //构造函数 function Person(name, age) &#123; this.name = name; this.age = age; &#125; //静态属性 Person.staticProperty = &quot;hobby&quot;; Person.hobby = &quot;nice&quot;; console.log(Person.hobby);//nice //静态方法 Person.staticMethod = function () &#123; console.log(&quot;good&quot;); &#125;; Person.staticMethod(); // good //创建实例 const p = new Person(&quot;meowrain&quot;, 12); console.log(p.name); console.log(p.age); //返回对象 return Person; &#125;)(); 继承: 1234567891011121314151617181920var Animal = (function () &#123; function Animal(name, age) &#123; this.name = name; this.age = age; &#125; return Animal;&#125;)();var Cat = (function () &#123; function Cat(name, age) &#123; this.name = name; this.age = age; &#125; //继承Animal Cat.prototype = new Animal(); return Cat;&#125;)();const cat1 = new Cat(&quot;meow&quot;, 2);console.log(cat1); new运算符 new运算符是创建对象时候使用的运算符new运算符-MDN docs","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Javascript","slug":"前端/Javascript","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/Javascript/"}],"tags":[]},{"title":"Node-包管理工具","slug":"ac95840c294b45909b8a32b5a3c7b1f7","date":"2023-01-25T06:23:04.099Z","updated":"2023-01-25T06:23:05.591Z","comments":true,"path":"2023/01/25/ac95840c294b45909b8a32b5a3c7b1f7/","link":"","permalink":"http://example.com/2023/01/25/ac95840c294b45909b8a32b5a3c7b1f7/","excerpt":"","text":"Node-包管理工具1.1 快速创建package.jsonnpm包管理工具提供了一个快捷命令。可以再执行命令时所处的目录中，快速创建package.json这个包管理配置文件 npm init -y 1.2 depenndecies节点 专门用来记录使用npm install命令安装了哪些包 1.3 一次性安装所有的包如果你之前安装过一些包，现在换了机器，想要还原之前的运行环境，那么就可以直接把package.json文件导出去，然后在另一台机器上直接 输入 npm install 即可自动安装之前安装过的所有包 1.4 卸载包npm uninstall 包名 1.5 开发期间使用 1.6 包的分类项目包那些被安装到项目的node_modules 目录中的包，都是项目包 项目包分为两类：分别是 开发依赖包（被记录到devDependencies节点中的包，只在开发期间会用到） 核心依赖包(会被记录到dependencies节点中的包，在开发期间和项目上线之后都会用到 12npm i 包名 -D #开发依赖包，会被记录到 devDependencies节点目录下npm i 包名 #核心依赖包(会被记录到dependencies目录下) 全局包1npm i 包名 -g","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Node.js","slug":"前端/Node-js","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/Node-js/"}],"tags":[]},{"title":"Linux 目录结构","slug":"76440ac4b9d649d0923e1dc7808d6d9e","date":"2023-01-25T06:21:06.905Z","updated":"2023-01-25T06:21:08.944Z","comments":true,"path":"2023/01/25/76440ac4b9d649d0923e1dc7808d6d9e/","link":"","permalink":"http://example.com/2023/01/25/76440ac4b9d649d0923e1dc7808d6d9e/","excerpt":"","text":"Linux 目录结构结构说明：&#x2F;bin：bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。&#x2F;boot：这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。&#x2F;dev ：dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。&#x2F;etc：etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。&#x2F;home：用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。&#x2F;lib：lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。&#x2F;lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。&#x2F;media：linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。&#x2F;mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 &#x2F;mnt&#x2F; 上，然后进入该目录就可以查看光驱里的内容了。&#x2F;opt：opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。&#x2F;proc：proc 是 Processes(进程) 的缩写，&#x2F;proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。&#x2F;root：该目录为系统管理员，也称作超级权限者的用户主目录。&#x2F;sbin：s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。&#x2F;selinux：这个目录是 Redhat&#x2F;CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。&#x2F;srv：该目录存放一些服务启动之后需要提取的数据。&#x2F;sys：当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。&#x2F;tmp：tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。&#x2F;usr：usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。&#x2F;usr&#x2F;bin：系统用户使用的应用程序。&#x2F;usr&#x2F;sbin：超级用户使用的比较高级的管理程序和系统守护程序。&#x2F;usr&#x2F;src：内核源代码默认的放置目录。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[]},{"title":"Linux用户管理","slug":"e2660f8d01d24bafbcab08e0a21766ae","date":"2023-01-25T06:20:47.691Z","updated":"2023-01-25T06:21:16.394Z","comments":true,"path":"2023/01/25/e2660f8d01d24bafbcab08e0a21766ae/","link":"","permalink":"http://example.com/2023/01/25/e2660f8d01d24bafbcab08e0a21766ae/","excerpt":"","text":"用户管理添加用户基本语法useradd 用户名useradd -d 目录 用户名 -可指定用户目录 修改用户密码passwd 用户名 删除用户userdel 用户名 —》删除用户userdel -r 用户名 —-》删除用户以及其家目录 查询用户信息id 用户名who am i 用户组新增组groupadd 组名 删除组groupdel 组名 增加用户时直接加入用户组useradd -g 用户组 用户名 修改用户的组usermod -g 用户组 用户名","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[]},{"title":"Linux压缩和解压缩","slug":"6555fe10b1904e6f8ad9e999d5bb8c09","date":"2023-01-25T06:20:29.723Z","updated":"2023-01-25T06:21:21.170Z","comments":true,"path":"2023/01/25/6555fe10b1904e6f8ad9e999d5bb8c09/","link":"","permalink":"http://example.com/2023/01/25/6555fe10b1904e6f8ad9e999d5bb8c09/","excerpt":"","text":"gzip&#x2F;gunzip指令gzip用于压缩文件，gunzip用于解压基本语法gzip 文件(功能描述：压缩文件，只能把文件压缩为*.gz文件)gunzip 文件.gz （功能描述：解压缩文件指令） zip&#x2F;unzip指令zip用于压缩文件夹，unzip用于解压，这个在项目打包发布中很有用 基本语法：zip [选项]xxx.zip 将要压缩的内容 （功能描述：压缩文件或者文件夹的命令）unzip [选项]xxxx.zip (功能描述：解压缩文件) zip常用选项：-r : 递归压缩，即压缩目录 unzip常用选项-d&lt;目录&gt;：指定解压后文件的存放目录 应用案例：案例1： 将&#x2F;home下的所闻文件进行压缩成myhome.zip 1zip -r myhome.zip /home/* 案例2：将myhome.zip解压到&#x2F;opt&#x2F;tmp目录下 1unzip -d /opt/tmp/ myhome.zip tar指令tar指令是打包指令，最后打包的文件是.tar.gz的文件基本语法：tar [选项] xxx.tar.gz 打包的内容（功能描述：打包目录，压缩后的文件格式.tar.gz）选项说明： 选项 功能 -c 产生.tar打包文件 -v 显示详情信息 -f 指定压缩后的文件名 -z 打包的同时压缩 -x 解包.tar文件 应用实例：案例1： 压缩多个文件，将&#x2F;home&#x2F;pig.txt和&#x2F;home&#x2F;cat.txt压缩成pc.tar.gztar -zcvf pc.tar.gz cat.txt pig.txt案例2： 将&#x2F;home的文件夹压缩成myhome.tar.gztar -zcvf myhome.tar.gz /home/案例3： 将pc.tar.gz解压到当前目录tar -zxvf pc.tar.gz 案例 4： 把myhome.tar.gz解压到/opt/tmp2目录下tar -zxvf /myhome/myhome.tar.gz -C /opt/tmp2/-C指定解压目录","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[]},{"title":"Linux 同步时间","slug":"c701f1c34bb44b30a2fa83eafe2f97b5","date":"2023-01-25T06:20:17.119Z","updated":"2023-01-25T06:20:17.940Z","comments":true,"path":"2023/01/25/c701f1c34bb44b30a2fa83eafe2f97b5/","link":"","permalink":"http://example.com/2023/01/25/c701f1c34bb44b30a2fa83eafe2f97b5/","excerpt":"","text":"Linux 同步时间 今天发现我的小服务器时间不准了，想着怎么同步一下标准北京时间 一. ntpdate 同步网络时间1234567# 安装ntpdatesudo apt-get install ntpdate //debian系sudo pacman -S ntpdate // Arch系# 执行时间同步sudo ntpdate -u ntp.api.bz //同步上海授时服务器 二.NTP服务器阿里云NTP服务器 1234567ntp1.aliyun.comntp2.aliyun.comntp3.aliyun.comntp4.aliyun.comntp5.aliyun.comntp6.aliyun.comntp7.aliyun.com","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[]},{"title":"CSS-position位置-绝对定位和相对定位","slug":"d3a6f3f0a7314b8c96148565dead839f","date":"2023-01-25T06:19:08.484Z","updated":"2023-01-25T06:19:09.240Z","comments":true,"path":"2023/01/25/d3a6f3f0a7314b8c96148565dead839f/","link":"","permalink":"http://example.com/2023/01/25/d3a6f3f0a7314b8c96148565dead839f/","excerpt":"","text":"CSS-position位置-绝对定位和相对定位position: relative 相对定位当元素的定位设置为relative时，它允许你通过CSS指定该元素在当前文档流页面下的相对偏移量。 CSS中，控制各个方向偏移量的属性是left,right,top和bottom 它们代表从原来位置向远离该方向偏移指定的像素，百分比或者em。 123456789101112&lt;style&gt; h2 &#123;position: relative;bottom: 10px; &#125;&lt;/style&gt;&lt;body&gt; &lt;h1&gt;On Being Well-Positioned&lt;/h1&gt; &lt;h2&gt;Move me!&lt;/h2&gt; &lt;p&gt;I still think the h2 is where it normally sits.&lt;/p&gt;&lt;/body&gt; 把元素的位置设置成相对，不会改变该元素在布局中所占的位置，也不会对其它元素的位置产生影响 使用CSS偏移移动相对定位的元素top:10px就是让元素向下移动10像素，同理，bottom:10px相当于让元素向上移动10像素。 left:10px就是让元素向右移动10px，right:10px让元素向左移动10px positon: absolute 绝对定位当position的值设置为absolute时，绝对定位会将元素从当前的文档流里面移除，周围的元素会忽略它，这样我们可以使用CSS的top,bottom,left,right的属性来调整元素的位置 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div &#123; width: 400px; height: 400px; background-color: burlywood; position: absolute; top: 20px; &#125; p &#123; text-transform: capitalize; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;let us see the position&lt;/p&gt; &lt;div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 上面是绝对定位，我们看看相对定位 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div &#123; width: 400px; height: 400px; background-color: burlywood; position: relative; top: 20px; &#125; p &#123; text-transform: capitalize; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;let us see the position&lt;/p&gt; &lt;div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 从上面我们能看出来，这个positon设置为absolute的话，再设置top:20px，就是忽略周围所有元素，然后把它自己的位置设置为距离浏览器窗口顶部的10px的距离 position:fixed 特殊的绝对定位其类似于绝对位置，也会将元素从当前的文档流中移除 但fixed和absolute的最明显的区别就在于，前者定位的元素不会随着皮姆滚动而移动 案例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #navbar &#123; position: fixed; top: 0; left: 0; width: 100%; background-color: bisque; color: blueviolet; &#125; nav ul &#123; text-decoration: none; &#125; nav ul li &#123; display: inline; padding-left: 20px; &#125; div &#123; box-sizing: border-box; margin: 150px auto; width: 400px; height: 400px; background-color: burlywood; text-transform: capitalize; text-align: center; line-height: 400px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;header&gt; &lt;nav id=&quot;navbar&quot;&gt;&lt;ul&gt; &lt;li&gt;Home&lt;/li&gt; &lt;li&gt;Archive&lt;/li&gt; &lt;li&gt;Image&lt;/li&gt; &lt;li&gt;Experiment&lt;/li&gt; &lt;li&gt;Contact&lt;/li&gt;&lt;/ul&gt; &lt;/nav&gt;&lt;/header&gt; &lt;div&gt; &lt;p&gt;let us see the position&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt;let us see the position&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt;let us see the position&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"前端/CSS","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/CSS/"}],"tags":[{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"}]},{"title":"C++求和的多种方式","slug":"a2acb1e85c084003b09433633a27ec8f","date":"2023-01-25T06:17:35.589Z","updated":"2023-01-25T06:17:59.649Z","comments":true,"path":"2023/01/25/a2acb1e85c084003b09433633a27ec8f/","link":"","permalink":"http://example.com/2023/01/25/a2acb1e85c084003b09433633a27ec8f/","excerpt":"","text":"第一种-多维数组+ 位运算法123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;int sum(int n);int main(void) &#123; int n; scanf(&quot;%d&quot;,&amp;n); printf(&quot;%d&quot;,sum(n)); return 0;&#125;int sum(int n) &#123; char arr[n][n+1]; /*原理： * arr[n][n+1]相当于定义一个n*(n+1)的矩阵 * 因为定义的是char类型，所以说每个元素占一个字节 * 求sizeof(arr)求得就是n*(n+1)的值 * 然后用位运算符，向右一位，相当于除以2 * 这样就完成了等差数列求和公式 * n* (n+1) /2 */ return sizeof(arr) &gt;&gt; 1;//右移一位相当于除以2&#125; 递归法123456#include &lt;iostream&gt;using namespace std;int getSum(int n) &#123; n &gt; 0 &amp;&amp; getSum(n-1) + n;&#125;/*这种方法采取了递归的方法*/","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/categories/C-C/"}],"tags":[]},{"title":"SprintBoot笔记（四）","slug":"3636e46047924c11b7ec162ffc9f9271","date":"2023-01-24T14:05:23.619Z","updated":"2023-01-24T14:05:43.123Z","comments":true,"path":"2023/01/24/3636e46047924c11b7ec162ffc9f9271/","link":"","permalink":"http://example.com/2023/01/24/3636e46047924c11b7ec162ffc9f9271/","excerpt":"","text":"Redis数据库**灵魂拷问：**不是学了MySQL吗，存数据也能存了啊，又学一个数据库干嘛？ 在前面我们学习了MySQL数据库，它是一种传统的关系型数据库，我们可以使用MySQL来更好地管理和组织我们的数据，虽然在小型Web应用下，只需要一个MySQL+Mybatis自带的缓存系统就可以胜任大部分的数据存储工作。但是MySQL的缺点也很明显，它的数据始终是存储在硬盘上的，对于我们的用户信息这种不需要经常发生修改的内容，使用MySQL存储确实可以，但是如果是快速更新或是频繁使用的数据，比如微博热搜、双十一秒杀，这些数据不仅要求服务器需要提供更高的响应速度，而且还需要面对短时间内上百万甚至上千万次访问，而MySQL的磁盘IO读写性能完全不能满足上面的需求，能够满足上述需求的只有内存，因为速度远高于磁盘IO。 因此，我们需要寻找一种更好的解决方案，来存储上述这类特殊数据，弥补MySQL的不足，以应对大数据时代的重重考验。 NoSQL概论NoSQL全称是Not Only SQL（不仅仅是SQL）它是一种非关系型数据库，相比传统SQL关系型数据库，它： 不保证关系数据的ACID特性 并不遵循SQL标准 消除数据之间关联性 乍一看，这玩意不比MySQL垃圾？我们再来看看它的优势： 远超传统关系型数据库的性能 非常易于扩展 数据模型更加灵活 高可用 这样，NoSQL的优势一下就出来了，这不就是我们正要寻找的高并发海量数据的解决方案吗！ NoSQL数据库分为以下几种： **键值存储数据库：**所有的数据都是以键值方式存储的，类似于我们之前学过的HashMap，使用起来非常简单方便，性能也非常高。 **列存储数据库：**这部分数据库通常是用来应对分布式存储的海量数据。键仍然存在，但是它们的特点是指向了多个列。 **文档型数据库：**它是以一种特定的文档格式存储数据，比如JSON格式，在处理网页等复杂数据时，文档型数据库比传统键值数据库的查询效率更高。 **图形数据库：**利用类似于图的数据结构存储数据，结合图相关算法实现高速访问。 其中我们要学习的Redis数据库，就是一个开源的键值存储数据库，所有的数据全部存放在内存中，它的性能大大高于磁盘IO，并且它也可以支持数据持久化，他还支持横向扩展、主从复制等。 实际生产中，我们一般会配合使用Redis和MySQL以发挥它们各自的优势，取长补短。 Redis安装和部署我们这里还是使用Windows安装Redis服务器，但是官方指定是安装到Linux服务器上，我们后面学习了Linux之后，再来安装到Linux服务器上。由于官方并没有提供Windows版本的安装包，我们需要另外寻找： 官网地址：https://redis.io GitHub Windows版本维护地址：https://github.com/tporadowski/redis/releases 基本操作在我们之前使用MySQL时，我们需要先在数据库中创建一张表，并定义好表的每个字段内容，最后再通过insert语句向表中添加数据，而Redis并不具有MySQL那样的严格的表结构，Redis是一个键值数据库，因此，可以像Map一样的操作方式，通过键值对向Redis数据库中添加数据（操作起来类似于向一个HashMap中存放数据） 在Redis下，数据库是由一个整数索引标识，而不是由一个数据库名称。 默认情况下，我们连接Redis数据库之后，会使用0号数据库，我们可以通过Redis配置文件中的参数来修改数据库总数，默认为16个。 我们可以通过select语句进行切换： 1select 序号; 数据操作我们来看看，如何向Redis数据库中添加数据： 123set &lt;key&gt; &lt;value&gt;-- 一次性多个mset [&lt;key&gt; &lt;value&gt;]... 所有存入的数据默认会以字符串的形式保存，键值具有一定的命名规范，以方便我们可以快速定位我们的数据属于哪一个部分，比如用户的数据： 12-- 使用冒号来进行板块分割，比如下面表示用户XXX的信息中的name属性，值为lbwset user:info:用户ID:name lbw 我们可以通过键值获取存入的值： 1get &lt;key&gt; 你以为Redis就仅仅只是存取个数据吗？它还支持数据的过期时间设定： 12set &lt;key&gt; &lt;value&gt; EX 秒set &lt;key&gt; &lt;value&gt; PX 毫秒 当数据到达指定时间时，会被自动删除。我们也可以单独为其他的键值对设置过期时间： 1expire &lt;key&gt; 秒 通过下面的命令来查询某个键值对的过期时间还剩多少： 12345ttl &lt;key&gt;-- 毫秒显示pttl &lt;key&gt;-- 转换为永久persist &lt;key&gt; 那么当我们想直接删除这个数据时呢？直接使用： 1del &lt;key&gt;... 删除命令可以同时拼接多个键值一起删除。 当我们想要查看数据库中所有的键值时： 1keys * 也可以查询某个键是否存在： 1exists &lt;key&gt;... 还可以随机拿一个键： 1randomkey 我们可以将一个数据库中的内容移动到另一个数据库中： 1move &lt;key&gt; 数据库序号 修改一个键为另一个键： 123rename &lt;key&gt; &lt;新的名称&gt;-- 下面这个会检查新的名称是否已经存在renamex &lt;key&gt; &lt;新的名称&gt; 如果存放的数据是一个数字，我们还可以对其进行自增自减操作： 123456-- 等价于a = a + 1incr &lt;key&gt;-- 等价于a = a + bincrby &lt;key&gt; b-- 等价于a = a - 1decr &lt;key&gt; 最后就是查看值的数据类型： 1type &lt;key&gt; Redis数据库也支持多种数据类型，但是它更偏向于我们在Java中认识的那些数据类型。 数据类型介绍一个键值对除了存储一个String类型的值以外，还支持多种常用的数据类型。 Hash这种类型本质上就是一个HashMap，也就是嵌套了一个HashMap罢了，在Java中就像这样： 1234#Redis默认存String类似于这样：Map&lt;String, String&gt; hash = new HashMap&lt;&gt;();#Redis存Hash类型的数据类似于这样：Map&lt;String, Map&lt;String, String&gt;&gt; hash = new HashMap&lt;&gt;(); 它比较适合存储类这样的数据，由于值本身又是一个Map，因此我们可以在此Map中放入类的各种属性和值，以实现一个Hash数据类型存储一个类的数据。 我们可以像这样来添加一个Hash类型的数据： 1hset &lt;key&gt; [&lt;字段&gt; &lt;值&gt;]... 我们可以直接获取： 123hget &lt;key&gt; &lt;字段&gt;-- 如果想要一次性获取所有的字段和值hgetall &lt;key&gt; 同样的，我们也可以判断某个字段是否存在： 1hexists &lt;key&gt; &lt;字段&gt; 删除Hash中的某个字段： 1hdel &lt;key&gt; 我们发现，在操作一个Hash时，实际上就是我们普通操作命令前面添加一个h，这样就能以同样的方式去操作Hash里面存放的键值对了，这里就不一一列出所有的操作了。我们来看看几个比较特殊的。 我们现在想要知道Hash中一共存了多少个键值对： 1hlen &lt;key&gt; 我们也可以一次性获取所有字段的值： 1hvals &lt;key&gt; 唯一需要注意的是，Hash中只能存放字符串值，不允许出现嵌套的的情况。 List我们接着来看List类型，实际上这个猜都知道，它就是一个列表，而列表中存放一系列的字符串，它支持随机访问，支持双端操作，就像我们使用Java中的LinkedList一样。 我们可以直接向一个已存在或是不存在的List中添加数据，如果不存在，会自动创建： 123456-- 向列表头部添加元素lpush &lt;key&gt; &lt;element&gt;...-- 向列表尾部添加元素rpush &lt;key&gt; &lt;element&gt;...-- 在指定元素前面/后面插入元素linsert &lt;key&gt; before/after &lt;指定元素&gt; &lt;element&gt; 同样的，获取元素也非常简单： 12345678-- 根据下标获取元素lindex &lt;key&gt; &lt;下标&gt;-- 获取并移除头部元素lpop &lt;key&gt;-- 获取并移除尾部元素rpop &lt;key&gt;-- 获取指定范围内的lrange &lt;key&gt; start stop 注意下标可以使用负数来表示从后到前数的数字（Python：搁这儿抄呢是吧）: 12-- 获取列表a中的全部元素lrange a 0 -1 没想到吧，push和pop还能连着用呢： 12-- 从前一个数组的最后取一个数出来放到另一个数组的头部，并返回元素rpoplpush 当前数组 目标数组 它还支持阻塞操作，类似于生产者和消费者，比如我们想要等待列表中有了数据后再进行pop操作： 12-- 如果列表中没有元素，那么就等待，如果指定时间（秒）内被添加了数据，那么就执行pop操作，如果超时就作废，支持同时等待多个列表，只要其中一个列表有元素了，那么就能执行blpop &lt;key&gt;... timeout Set和SortedSetSet集合其实就像Java中的HashSet一样（我们在JavaSE中已经讲解过了，HashSet本质上就是利用了一个HashMap，但是Value都是固定对象，仅仅是Key不同）它不允许出现重复元素，不支持随机访问，但是能够利用Hash表提供极高的查找效率。 向Set中添加一个或多个值： 1sadd &lt;key&gt; &lt;value&gt;... 查看Set集合中有多少个值： 1scard &lt;key&gt; 判断集合中是否包含： 1234-- 是否包含指定值sismember &lt;key&gt; &lt;value&gt;-- 列出所有值smembers &lt;key&gt; 集合之间的运算： 123456789101112-- 集合之间的差集sdiff &lt;key1&gt; &lt;key2&gt;-- 集合之间的交集sinter &lt;key1&gt; &lt;key2&gt;-- 求并集sunion &lt;key1&gt; &lt;key2&gt;-- 将集合之间的差集存到目标集合中sdiffstore 目标 &lt;key1&gt; &lt;key2&gt;-- 同上sinterstore 目标 &lt;key1&gt; &lt;key2&gt;-- 同上sunionstore 目标 &lt;key1&gt; &lt;key2&gt; 移动指定值到另一个集合中： 1smove &lt;key&gt; 目标 value 移除操作： 1234-- 随机移除一个幸运儿spop &lt;key&gt;-- 移除指定srem &lt;key&gt; &lt;value&gt;... 那么如果我们要求Set集合中的数据按照我们指定的顺序进行排列怎么办呢？这时就可以使用SortedSet，它支持我们为每个值设定一个分数，分数的大小决定了值的位置，所以它是有序的。 我们可以添加一个带分数的值： 1zadd &lt;key&gt; [&lt;value&gt; &lt;score&gt;]... 同样的： 123456-- 查询有多少个值zcard &lt;key&gt;-- 移除zrem &lt;key&gt; &lt;value&gt;...-- 获取区间内的所有zrange &lt;key&gt; start stop 由于所有的值都有一个分数，我们也可以根据分数段来获取： 123456-- 通过分数段查看zrangebyscore &lt;key&gt; start stop [withscores] [limit]-- 统计分数段内的数量zcount &lt;key&gt; start stop-- 根据分数获取指定值的排名zrank &lt;key&gt; &lt;value&gt; https://www.jianshu.com/p/32b9fe8c20e1 有关Bitmap、HyperLogLog和Geospatial等数据类型，这里暂时不做介绍，感兴趣可以自行了解。 持久化我们知道，Redis数据库中的数据都是存放在内存中，虽然很高效，但是这样存在一个非常严重的问题，如果突然停电，那我们的数据不就全部丢失了吗？它不像硬盘上的数据，断电依然能够保存。 这个时候我们就需要持久化，我们需要将我们的数据备份到硬盘上，防止断电或是机器故障导致的数据丢失。 持久化的实现方式有两种方案：一种是直接保存当前已经存储的数据，相当于复制内存中的数据到硬盘上，需要恢复数据时直接读取即可；还有一种就是保存我们存放数据的所有过程，需要恢复数据时，只需要将整个过程完整地重演一遍就能保证与之前数据库中的内容一致。 RDBRDB就是我们所说的第一种解决方案，那么如何将数据保存到本地呢？我们可以使用命令： 123save-- 注意上面这个命令是直接保存，会占用一定的时间，也可以单独开一个子进程后台执行保存bgsave 执行后，会在服务端目录下生成一个dump.rdb文件，而这个文件中就保存了内存中存放的数据，当服务器重启后，会自动加载里面的内容到对应数据库中。保存后我们可以关闭服务器： 1shutdown 重启后可以看到数据依然存在。 虽然这种方式非常方便，但是由于会完整复制所有的数据，如果数据库中的数据量比较大，那么复制一次可能就需要花费大量的时间，所以我们可以每隔一段时间自动进行保存；还有就是，如果我们基本上都是在进行读操作，而没有进行写操作，实际上只需要偶尔保存一次即可，因为数据几乎没有怎么变化，可能两次保存的都是一样的数据。 我们可以在配置文件中设置自动保存，并设定在一段时间内写入多少数据时，执行一次保存操作： save 300 10 # 300秒（5分钟）内有10个写入 save 60 10000 # 60秒（1分钟）内有10000个写入 配置的save使用的都是bgsave后台执行。 AOF虽然RDB能够很好地解决数据持久化问题，但是它的缺点也很明显：每次都需要去完整地保存整个数据库中的数据，同时后台保存过程中也会产生额外的内存开销，最严重的是它并不是实时保存的，如果在自动保存触发之前服务器崩溃，那么依然会导致少量数据的丢失。 而AOF就是另一种方式，它会以日志的形式将我们每次执行的命令都进行保存，服务器重启时会将所有命令依次执行，通过这种重演的方式将数据恢复，这样就能很好解决实时性存储问题。 但是，我们多久写一次日志呢？我们可以自己配置保存策略，有三种策略： always：每次执行写操作都会保存一次 everysec：每秒保存一次（默认配置），这样就算丢失数据也只会丢一秒以内的数据 no：看系统心情保存 可以在配置文件中配置： 123456# 注意得改成也是appendonly yes# appendfsync alwaysappendfsync everysec# appendfsync no 重启服务器后，可以看到服务器目录下多了一个appendonly.aof文件，存储的就是我们执行的命令。 AOF的缺点也很明显，每次服务器启动都需要进行过程重演，相比RDB更加耗费时间，并且随着我们的操作变多，不断累计，可能到最后我们的aof文件会变得无比巨大，我们需要一个改进方案来优化这些问题。 Redis有一个AOF重写机制进行优化，比如我们执行了这样的语句： lpush test 666 lpush test 777 lpush test 888 实际上用一条语句也可以实现： lpush test 666 777 888 正是如此，只要我们能够保证最终的重演结果和原有语句的结果一致，无论语句如何修改都可以，所以我们可以通过这种方式将多条语句进行压缩。 我们可以输入命令来手动执行重写操作： 1bgrewriteaof 或是在配置文件中配置自动重写： # 百分比计算，这里不多介绍 auto-aof-rewrite-percentage 100 # 当达到这个大小时，触发自动重写 auto-aof-rewrite-min-size 64mb 至此，我们就完成了两种持久化方案的介绍，最后我们再来进行一下总结： AOF： 优点：存储速度快、消耗资源少、支持实时存储 缺点：加载速度慢、数据体积大 RDB： 优点：加载速度快、数据体积小 缺点：存储速度慢大量消耗资源、会发生数据丢失 事务和锁机制和MySQL一样，在Redis中也有事务机制，当我们需要保证多条命令一次性完整执行而中途不受到其他命令干扰时，就可以使用事务机制。 我们可以使用命令来直接开启事务： 1multi 当我们输入完所有要执行的命令时，可以使用命令来立即执行事务： 1exec 我们也可以中途取消事务： 1discard 实际上整个事务是创建了一个命令队列，它不像MySQL那种在事务中也能单独得到结果，而是我们提前将所有的命令装在队列中，但是并不会执行，而是等我们提交事务的时候再统一执行。 锁又提到锁了，实际上这个概念对我们来说已经不算是陌生了。实际上在Redis中也会出现多个命令同时竞争同一个数据的情况，比如现在有两条命令同时执行，他们都要去修改a的值，那么这个时候就只能动用锁机制来保证同一时间只能有一个命令操作。 虽然Redis中也有锁机制，但是它是一种乐观锁，不同于MySQL，我们在MySQL中认识的锁是悲观锁，那么什么是乐观锁什么是悲观锁呢？ 悲观锁：时刻认为别人会来抢占资源，禁止一切外来访问，直到释放锁，具有强烈的排他性质。 乐观锁：并不认为会有人来抢占资源，所以会直接对数据进行操作，在操作时再去验证是否有其他人抢占资源。 Redis中可以使用watch来监视一个目标，如果执行事务之前被监视目标发生了修改，则取消本次事务： 1watch 我们可以开两个客户端进行测试。 取消监视可以使用： 1unwatch 至此，Redis的基础内容就讲解完毕了，在之后的SpringCloud阶段，我们还会去讲解集群相关的知识，包括主从复制、哨兵模式等。 使用Java与Redis交互既然了解了如何通过命令窗口操作Redis数据库，那么我们如何使用Java来操作呢？ 这里我们需要使用到Jedis框架，它能够实现Java与Redis数据库的交互，依赖： 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 基本操作我们来看看如何连接Redis数据库，非常简单，只需要创建一个对象即可： 1234567public static void main(String[] args) &#123; //创建Jedis对象 Jedis jedis = new Jedis(&quot;localhost&quot;, 6379); //使用之后关闭连接 jedis.close();&#125; 通过Jedis对象，我们就可以直接调用命令的同名方法来执行Redis命令了，比如： 1234567public static void main(String[] args) &#123; //直接使用try-with-resouse，省去close try(Jedis jedis = new Jedis(&quot;192.168.10.3&quot;, 6379))&#123; jedis.set(&quot;test&quot;, &quot;lbwnb&quot;); //等同于 set test lbwnb 命令 System.out.println(jedis.get(&quot;test&quot;)); //等同于 get test 命令 &#125;&#125; Hash类型的数据也是这样： 1234567public static void main(String[] args) &#123; try(Jedis jedis = new Jedis(&quot;192.168.10.3&quot;, 6379))&#123; jedis.hset(&quot;hhh&quot;, &quot;name&quot;, &quot;sxc&quot;); //等同于 hset hhh name sxc jedis.hset(&quot;hhh&quot;, &quot;sex&quot;, &quot;19&quot;); //等同于 hset hhh age 19 jedis.hgetAll(&quot;hhh&quot;).forEach((k, v) -&gt; System.out.println(k+&quot;: &quot;+v)); &#125;&#125; 我们接着来看看列表操作： 1234567public static void main(String[] args) &#123; try(Jedis jedis = new Jedis(&quot;192.168.10.3&quot;, 6379))&#123; jedis.lpush(&quot;mylist&quot;, &quot;111&quot;, &quot;222&quot;, &quot;333&quot;); //等同于 lpush mylist 111 222 333 命令 jedis.lrange(&quot;mylist&quot;, 0, -1) .forEach(System.out::println); //等同于 lrange mylist 0 -1 &#125;&#125; 实际上我们只需要按照对应的操作去调用同名方法即可，所有的类型封装Jedis已经帮助我们完成了。 SpringBoot整合Redis我们接着来看如何在SpringBoot项目中整合Redis操作框架，只需要一个starter即可，但是它底层没有用Jedis，而是Lettuce： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; starter提供的默认配置会去连接本地的Redis服务器，并使用0号数据库，当然你也可以手动进行修改： 12345678spring: redis: #Redis服务器地址 host: 192.168.10.3 #端口 port: 6379 #使用几号数据库 database: 0 starter已经给我们提供了两个默认的模板类： 12345678910111213141516171819202122232425262728@Configuration( proxyBeanMethods = false)@ConditionalOnClass(&#123;RedisOperations.class&#125;)@EnableConfigurationProperties(&#123;RedisProperties.class&#125;)@Import(&#123;LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class&#125;)public class RedisAutoConfiguration &#123; public RedisAutoConfiguration() &#123; &#125; @Bean @ConditionalOnMissingBean( name = &#123;&quot;redisTemplate&quot;&#125; ) @ConditionalOnSingleCandidate(RedisConnectionFactory.class) public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123; RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template; &#125; @Bean @ConditionalOnMissingBean @ConditionalOnSingleCandidate(RedisConnectionFactory.class) public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) &#123; return new StringRedisTemplate(redisConnectionFactory); &#125;&#125; 那么如何去使用这两个模板类呢？我们可以直接注入StringRedisTemplate来使用模板： 1234567891011121314151617@SpringBootTestclass SpringBootTestApplicationTests &#123; @Autowired StringRedisTemplate template; @Test void contextLoads() &#123; ValueOperations&lt;String, String&gt; operations = template.opsForValue(); operations.set(&quot;c&quot;, &quot;xxxxx&quot;); //设置值 System.out.println(operations.get(&quot;c&quot;)); //获取值 template.delete(&quot;c&quot;); //删除键 System.out.println(template.hasKey(&quot;c&quot;)); //判断是否包含键 &#125;&#125; 实际上所有的值的操作都被封装到了ValueOperations对象中，而普通的键操作直接通过模板对象就可以使用了，大致使用方式其实和Jedis一致。 我们接着来看看事务操作，由于Spring没有专门的Redis事务管理器，所以只能借用JDBC提供的，只不过无所谓，正常情况下反正我们也要用到这玩意： 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 123456789101112131415161718@Servicepublic class RedisService &#123; @Resource StringRedisTemplate template; @PostConstruct public void init()&#123; template.setEnableTransactionSupport(true); //需要开启事务 &#125; @Transactional //需要添加此注解 public void test()&#123; template.multi(); template.opsForValue().set(&quot;d&quot;, &quot;xxxxx&quot;); template.exec(); &#125;&#125; 我们还可以为RedisTemplate对象配置一个Serializer来实现对象的JSON存储： 123456@Testvoid contextLoad2() &#123; //注意Student需要实现序列化接口才能存入Redis template.opsForValue().set(&quot;student&quot;, new Student()); System.out.println(template.opsForValue().get(&quot;student&quot;));&#125; 使用Redis做缓存我们可以轻松地使用Redis来实现一些框架的缓存和其他存储。 Mybatis二级缓存还记得我们在学习Mybatis讲解的缓存机制吗，我们当时介绍了二级缓存，它是Mapper级别的缓存，能够作用与所有会话。但是当时我们提出了一个问题，由于Mybatis的默认二级缓存只能是单机的，如果存在多台服务器访问同一个数据库，实际上二级缓存只会在各自的服务器上生效，但是我们希望的是多台服务器都能使用同一个二级缓存，这样就不会造成过多的资源浪费。 我们可以将Redis作为Mybatis的二级缓存，这样就能实现多台服务器使用同一个二级缓存，因为它们只需要连接同一个Redis服务器即可，所有的缓存数据全部存储在Redis服务器上。我们需要手动实现Mybatis提供的Cache接口，这里我们简单编写一下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//实现Mybatis的Cache接口public class RedisMybatisCache implements Cache &#123; private final String id; private static RedisTemplate&lt;Object, Object&gt; template; //注意构造方法必须带一个String类型的参数接收id public RedisMybatisCache(String id)&#123; this.id = id; &#125; //初始化时通过配置类将RedisTemplate给过来 public static void setTemplate(RedisTemplate&lt;Object, Object&gt; template) &#123; RedisMybatisCache.template = template; &#125; @Override public String getId() &#123; return id; &#125; @Override public void putObject(Object o, Object o1) &#123; //这里直接向Redis数据库中丢数据即可，o就是Key，o1就是Value，60秒为过期时间 template.opsForValue().set(o, o1, 60, TimeUnit.SECONDS); &#125; @Override public Object getObject(Object o) &#123; //这里根据Key直接从Redis数据库中获取值即可 return template.opsForValue().get(o); &#125; @Override public Object removeObject(Object o) &#123; //根据Key删除 return template.delete(o); &#125; @Override public void clear() &#123; //由于template中没封装清除操作，只能通过connection来执行 template.execute((RedisCallback&lt;Void&gt;) connection -&gt; &#123; //通过connection对象执行清空操作 connection.flushDb(); return null; &#125;); &#125; @Override public int getSize() &#123; //这里也是使用connection对象来获取当前的Key数量 return template.execute(RedisServerCommands::dbSize).intValue(); &#125;&#125; 缓存类编写完成后，我们接着来编写配置类： 1234567891011@Configurationpublic class MainConfiguration &#123; @Resource RedisTemplate&lt;Object, Object&gt; template; @PostConstruct public void init()&#123; //把RedisTemplate给到RedisMybatisCache RedisMybatisCache.setTemplate(template); &#125;&#125; 最后我们在Mapper上启用此缓存即可： 12345678//只需要修改缓存实现类implementation为我们的RedisMybatisCache即可@CacheNamespace(implementation = RedisMybatisCache.class)@Mapperpublic interface MainMapper &#123; @Select(&quot;select name from student where sid = 1&quot;) String getSid();&#125; 最后我们提供一个测试用例来查看当前的二级缓存是否生效： 123456789101112131415@SpringBootTestclass SpringBootTestApplicationTests &#123; @Resource MainMapper mapper; @Test void contextLoads() &#123; System.out.println(mapper.getSid()); System.out.println(mapper.getSid()); System.out.println(mapper.getSid()); &#125;&#125; 手动使用客户端查看Redis数据库，可以看到已经有一条Mybatis生成的缓存数据了。 Token持久化存储我们之前使用SpringSecurity时，remember-me的Token是支持持久化存储的，而我们当时是存储在数据库中，那么Token信息能否存储在缓存中呢，当然也是可以的，我们可以手动实现一个： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//实现PersistentTokenRepository接口@Componentpublic class RedisTokenRepository implements PersistentTokenRepository &#123; //Key名称前缀，用于区分 private final static String REMEMBER_ME_KEY = &quot;spring:security:rememberMe:&quot;; @Resource RedisTemplate&lt;Object, Object&gt; template; @Override public void createNewToken(PersistentRememberMeToken token) &#123; //这里要放两个，一个存seriesId-&gt;Token，一个存username-&gt;seriesId，因为删除时是通过username删除 template.opsForValue().set(REMEMBER_ME_KEY+&quot;username:&quot;+token.getUsername(), token.getSeries()); template.expire(REMEMBER_ME_KEY+&quot;username:&quot;+token.getUsername(), 1, TimeUnit.DAYS); this.setToken(token); &#125; //先获取，然后修改创建一个新的，再放入 @Override public void updateToken(String series, String tokenValue, Date lastUsed) &#123; PersistentRememberMeToken token = this.getToken(series); if(token != null) this.setToken(new PersistentRememberMeToken(token.getUsername(), series, tokenValue, lastUsed)); &#125; @Override public PersistentRememberMeToken getTokenForSeries(String seriesId) &#123; return this.getToken(seriesId); &#125; //通过username找seriesId直接删除这两个 @Override public void removeUserTokens(String username) &#123; String series = (String) template.opsForValue().get(REMEMBER_ME_KEY+&quot;username:&quot;+username); template.delete(REMEMBER_ME_KEY+series); template.delete(REMEMBER_ME_KEY+&quot;username:&quot;+username); &#125; //由于PersistentRememberMeToken没实现序列化接口，这里只能用Hash来存储了，所以单独编写一个set和get操作 private PersistentRememberMeToken getToken(String series)&#123; Map&lt;Object, Object&gt; map = template.opsForHash().entries(REMEMBER_ME_KEY+series); if(map.isEmpty()) return null; return new PersistentRememberMeToken( (String) map.get(&quot;username&quot;), (String) map.get(&quot;series&quot;), (String) map.get(&quot;tokenValue&quot;), new Date(Long.parseLong((String) map.get(&quot;date&quot;)))); &#125; private void setToken(PersistentRememberMeToken token)&#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;username&quot;, token.getUsername()); map.put(&quot;series&quot;, token.getSeries()); map.put(&quot;tokenValue&quot;, token.getTokenValue()); map.put(&quot;date&quot;, &quot;&quot;+token.getDate().getTime()); template.opsForHash().putAll(REMEMBER_ME_KEY+token.getSeries(), map); template.expire(REMEMBER_ME_KEY+token.getSeries(), 1, TimeUnit.DAYS); &#125;&#125; 接着把验证Service实现了： 1234567891011121314151617@Servicepublic class AuthService implements UserDetailsService &#123; @Resource UserMapper mapper; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; Account account = mapper.getAccountByUsername(username); if(account == null) throw new UsernameNotFoundException(&quot;&quot;); return User .withUsername(username) .password(account.getPassword()) .roles(account.getRole()) .build(); &#125;&#125; Mapper也安排上： 1234567@Datapublic class Account implements Serializable &#123; int id; String username; String password; String role;&#125; 1234567@CacheNamespace(implementation = MybatisRedisCache.class)@Mapperpublic interface UserMapper &#123; @Select(&quot;select * from users where username = #&#123;username&#125;&quot;) Account getAccountByUsername(String username);&#125; 最后配置文件配一波： 123456789101112131415161718@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http .authorizeRequests() .anyRequest().authenticated() .and() .formLogin() .and() .rememberMe() .tokenRepository(repository);&#125;@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth .userDetailsService(service) .passwordEncoder(new BCryptPasswordEncoder());&#125; OK，启动服务器验证一下吧。 三大缓存问题**注意：**这部分内容作为选学内容。 虽然我们可以利用缓存来大幅度提升我们程序的数据获取效率，但是使用缓存也存在着一些潜在的问题。 缓存穿透 当我们去查询一个一定不存在的数据，比如Mybatis在缓存是未命中的情况下需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。 这显然是很浪费资源的，我们希望的是，如果这个数据不存在，为什么缓存这一层不直接返回空呢，这时就不必再去查数据库了，但是也有一个问题，缓存不去查数据库怎么知道数据库里面到底有没有这个数据呢？ 这时我们就可以使用布隆过滤器来进行判断。什么是布隆过滤器？（当然不是打辅助的那个布隆，只不过也挺像，辅助布隆也是挡子弹的） 使用布隆过滤器，能够告诉你某样东西一定不存在或是某样东西可能存在。 布隆过滤器本质是一个存放二进制位的bit数组，如果我们要添加一个值到布隆过滤器中，我们需要使用N个不同的哈希函数来生成N个哈希值，并对每个生成的哈希值指向的bit位置1，如上图所示，一共添加了三个值abc。 接着我们给一个d，那么这时就可以进行判断，如果说d计算的N个哈希值的位置上都是1，那么就说明d可能存在；这时候又来了个e，计算后我们发现有一个位置上的值是0，这时就可以直接断定e一定不存在。 缓存击穿 某个 Key 属于热点数据，访问非常频繁，同一时间很多人都在访问，在这个Key失效的瞬间，大量的请求到来，这时发现缓存中没有数据，就全都直接请求数据库，相当于击穿了缓存屏障，直接攻击整个系统核心。 这种情况下，最好的解决办法就是不让Key那么快过期，如果一个Key处于高频访问，那么可以适当地延长过期时间。 缓存雪崩 当你的Redis服务器炸了或是大量的Key在同一时间过期，这时相当于缓存直接GG了，那么如果这时又有很多的请求来访问不同的数据，同一时间内缓存服务器就得向数据库大量发起请求来重新建立缓存，很容易把数据库也搞GG。 解决这种问题最好的办法就是设置高可用，也就是搭建Redis集群，当然也可以采取一些服务熔断降级机制，这些内容我们会在SpringCloud阶段再进行探讨。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"Springboot笔记","slug":"Java/Springboot笔记","permalink":"http://example.com/categories/Java/Springboot%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"SpringBoot笔记（三）","slug":"99650712d4104d00a2c4a5ccfc3f525e","date":"2023-01-24T14:04:47.287Z","updated":"2023-01-24T14:05:21.766Z","comments":true,"path":"2023/01/24/99650712d4104d00a2c4a5ccfc3f525e/","link":"","permalink":"http://example.com/2023/01/24/99650712d4104d00a2c4a5ccfc3f525e/","excerpt":"","text":"Redis数据库**灵魂拷问：**不是学了MySQL吗，存数据也能存了啊，又学一个数据库干嘛？ 在前面我们学习了MySQL数据库，它是一种传统的关系型数据库，我们可以使用MySQL来更好地管理和组织我们的数据，虽然在小型Web应用下，只需要一个MySQL+Mybatis自带的缓存系统就可以胜任大部分的数据存储工作。但是MySQL的缺点也很明显，它的数据始终是存储在硬盘上的，对于我们的用户信息这种不需要经常发生修改的内容，使用MySQL存储确实可以，但是如果是快速更新或是频繁使用的数据，比如微博热搜、双十一秒杀，这些数据不仅要求服务器需要提供更高的响应速度，而且还需要面对短时间内上百万甚至上千万次访问，而MySQL的磁盘IO读写性能完全不能满足上面的需求，能够满足上述需求的只有内存，因为速度远高于磁盘IO。 因此，我们需要寻找一种更好的解决方案，来存储上述这类特殊数据，弥补MySQL的不足，以应对大数据时代的重重考验。 NoSQL概论NoSQL全称是Not Only SQL（不仅仅是SQL）它是一种非关系型数据库，相比传统SQL关系型数据库，它： 不保证关系数据的ACID特性 并不遵循SQL标准 消除数据之间关联性 乍一看，这玩意不比MySQL垃圾？我们再来看看它的优势： 远超传统关系型数据库的性能 非常易于扩展 数据模型更加灵活 高可用 这样，NoSQL的优势一下就出来了，这不就是我们正要寻找的高并发海量数据的解决方案吗！ NoSQL数据库分为以下几种： **键值存储数据库：**所有的数据都是以键值方式存储的，类似于我们之前学过的HashMap，使用起来非常简单方便，性能也非常高。 **列存储数据库：**这部分数据库通常是用来应对分布式存储的海量数据。键仍然存在，但是它们的特点是指向了多个列。 **文档型数据库：**它是以一种特定的文档格式存储数据，比如JSON格式，在处理网页等复杂数据时，文档型数据库比传统键值数据库的查询效率更高。 **图形数据库：**利用类似于图的数据结构存储数据，结合图相关算法实现高速访问。 其中我们要学习的Redis数据库，就是一个开源的键值存储数据库，所有的数据全部存放在内存中，它的性能大大高于磁盘IO，并且它也可以支持数据持久化，他还支持横向扩展、主从复制等。 实际生产中，我们一般会配合使用Redis和MySQL以发挥它们各自的优势，取长补短。 Redis安装和部署我们这里还是使用Windows安装Redis服务器，但是官方指定是安装到Linux服务器上，我们后面学习了Linux之后，再来安装到Linux服务器上。由于官方并没有提供Windows版本的安装包，我们需要另外寻找： 官网地址：https://redis.io GitHub Windows版本维护地址：https://github.com/tporadowski/redis/releases 基本操作在我们之前使用MySQL时，我们需要先在数据库中创建一张表，并定义好表的每个字段内容，最后再通过insert语句向表中添加数据，而Redis并不具有MySQL那样的严格的表结构，Redis是一个键值数据库，因此，可以像Map一样的操作方式，通过键值对向Redis数据库中添加数据（操作起来类似于向一个HashMap中存放数据） 在Redis下，数据库是由一个整数索引标识，而不是由一个数据库名称。 默认情况下，我们连接Redis数据库之后，会使用0号数据库，我们可以通过Redis配置文件中的参数来修改数据库总数，默认为16个。 我们可以通过select语句进行切换： select 序号; 数据操作我们来看看，如何向Redis数据库中添加数据： set – 一次性多个 mset [ ]… 所有存入的数据默认会以字符串的形式保存，键值具有一定的命名规范，以方便我们可以快速定位我们的数据属于哪一个部分，比如用户的数据： – 使用冒号来进行板块分割，比如下面表示用户XXX的信息中的name属性，值为lbw set user:info:用户ID:name lbw 我们可以通过键值获取存入的值： get 你以为Redis就仅仅只是存取个数据吗？它还支持数据的过期时间设定： set EX 秒 set PX 毫秒 当数据到达指定时间时，会被自动删除。我们也可以单独为其他的键值对设置过期时间： expire 秒 通过下面的命令来查询某个键值对的过期时间还剩多少： ttl – 毫秒显示 pttl – 转换为永久 persist 那么当我们想直接删除这个数据时呢？直接使用： del … 删除命令可以同时拼接多个键值一起删除。 当我们想要查看数据库中所有的键值时： keys * 也可以查询某个键是否存在： exists &lt;key&gt;… 还可以随机拿一个键： randomkey 我们可以将一个数据库中的内容移动到另一个数据库中： move &lt;key&gt; 数据库序号 修改一个键为另一个键： rename &lt;key&gt; &lt;新的名称&gt;-- 下面这个会检查新的名称是否已经存在renamex &lt;key&gt; &lt;新的名称&gt; 如果存放的数据是一个数字，我们还可以对其进行自增自减操作： -- 等价于a &#x3D; a + 1incr &lt;key&gt;-- 等价于a &#x3D; a + bincrby &lt;key&gt; b-- 等价于a &#x3D; a - 1decr &lt;key&gt; 最后就是查看值的数据类型： type &lt;key&gt; Redis数据库也支持多种数据类型，但是它更偏向于我们在Java中认识的那些数据类型。 数据类型介绍一个键值对除了存储一个String类型的值以外，还支持多种常用的数据类型。 Hash这种类型本质上就是一个HashMap，也就是嵌套了一个HashMap罢了，在Java中就像这样： #Redis默认存String类似于这样：Map&lt;String, String&gt; hash &#x3D; new HashMap&lt;&gt;();#Redis存Hash类型的数据类似于这样：Map&lt;String, Map&lt;String, String&gt;&gt; hash &#x3D; new HashMap&lt;&gt;(); 它比较适合存储类这样的数据，由于值本身又是一个Map，因此我们可以在此Map中放入类的各种属性和值，以实现一个Hash数据类型存储一个类的数据。 我们可以像这样来添加一个Hash类型的数据： hset &lt;key&gt; [&lt;字段&gt; &lt;值&gt;]… 我们可以直接获取： hget &lt;key&gt; &lt;字段&gt;-- 如果想要一次性获取所有的字段和值hgetall &lt;key&gt; 同样的，我们也可以判断某个字段是否存在： hexists &lt;key&gt; &lt;字段&gt; 删除Hash中的某个字段： hdel &lt;key&gt; 我们发现，在操作一个Hash时，实际上就是我们普通操作命令前面添加一个h，这样就能以同样的方式去操作Hash里面存放的键值对了，这里就不一一列出所有的操作了。我们来看看几个比较特殊的。 我们现在想要知道Hash中一共存了多少个键值对： hlen &lt;key&gt; 我们也可以一次性获取所有字段的值： hvals &lt;key&gt; 唯一需要注意的是，Hash中只能存放字符串值，不允许出现嵌套的的情况。 List我们接着来看List类型，实际上这个猜都知道，它就是一个列表，而列表中存放一系列的字符串，它支持随机访问，支持双端操作，就像我们使用Java中的LinkedList一样。 我们可以直接向一个已存在或是不存在的List中添加数据，如果不存在，会自动创建： -- 向列表头部添加元素lpush &lt;key&gt; &lt;element&gt;…-- 向列表尾部添加元素rpush &lt;key&gt; &lt;element&gt;…-- 在指定元素前面&#x2F;后面插入元素linsert &lt;key&gt; before&#x2F;after &lt;指定元素&gt; &lt;element&gt; 同样的，获取元素也非常简单： -- 根据下标获取元素lindex &lt;key&gt; &lt;下标&gt;-- 获取并移除头部元素lpop &lt;key&gt;-- 获取并移除尾部元素rpop &lt;key&gt;-- 获取指定范围内的lrange &lt;key&gt; start stop 注意下标可以使用负数来表示从后到前数的数字（Python：搁这儿抄呢是吧）: -- 获取列表a中的全部元素lrange a 0 -1 没想到吧，push和pop还能连着用呢： -- 从前一个数组的最后取一个数出来放到另一个数组的头部，并返回元素rpoplpush 当前数组 目标数组 它还支持阻塞操作，类似于生产者和消费者，比如我们想要等待列表中有了数据后再进行pop操作： -- 如果列表中没有元素，那么就等待，如果指定时间（秒）内被添加了数据，那么就执行pop操作，如果超时就作废，支持同时等待多个列表，只要其中一个列表有元素了，那么就能执行blpop &lt;key&gt;… timeout Set和SortedSetSet集合其实就像Java中的HashSet一样（我们在JavaSE中已经讲解过了，HashSet本质上就是利用了一个HashMap，但是Value都是固定对象，仅仅是Key不同）它不允许出现重复元素，不支持随机访问，但是能够利用Hash表提供极高的查找效率。 向Set中添加一个或多个值： sadd &lt;key&gt; &lt;value&gt;… 查看Set集合中有多少个值： scard &lt;key&gt; 判断集合中是否包含： -- 是否包含指定值sismember &lt;key&gt; &lt;value&gt;-- 列出所有值smembers &lt;key&gt; 集合之间的运算： -- 集合之间的差集sdiff &lt;key1&gt; &lt;key2&gt;-- 集合之间的交集sinter &lt;key1&gt; &lt;key2&gt;-- 求并集sunion &lt;key1&gt; &lt;key2&gt;-- 将集合之间的差集存到目标集合中sdiffstore 目标 &lt;key1&gt; &lt;key2&gt;-- 同上sinterstore 目标 &lt;key1&gt; &lt;key2&gt;-- 同上sunionstore 目标 &lt;key1&gt; &lt;key2&gt; 移动指定值到另一个集合中： smove &lt;key&gt; 目标 value 移除操作： -- 随机移除一个幸运儿spop &lt;key&gt;-- 移除指定srem &lt;key&gt; &lt;value&gt;… 那么如果我们要求Set集合中的数据按照我们指定的顺序进行排列怎么办呢？这时就可以使用SortedSet，它支持我们为每个值设定一个分数，分数的大小决定了值的位置，所以它是有序的。 我们可以添加一个带分数的值： zadd &lt;key&gt; [&lt;value&gt; &lt;score&gt;]… 同样的： -- 查询有多少个值zcard &lt;key&gt;-- 移除zrem &lt;key&gt; &lt;value&gt;…-- 获取区间内的所有zrange &lt;key&gt; start stop 由于所有的值都有一个分数，我们也可以根据分数段来获取： -- 通过分数段查看zrangebyscore &lt;key&gt; start stop [withscores] [limit]-- 统计分数段内的数量zcount &lt;key&gt; start stop-- 根据分数获取指定值的排名zrank &lt;key&gt; &lt;value&gt; https://www.jianshu.com/p/32b9fe8c20e1 有关Bitmap、HyperLogLog和Geospatial等数据类型，这里暂时不做介绍，感兴趣可以自行了解。 持久化我们知道，Redis数据库中的数据都是存放在内存中，虽然很高效，但是这样存在一个非常严重的问题，如果突然停电，那我们的数据不就全部丢失了吗？它不像硬盘上的数据，断电依然能够保存。 这个时候我们就需要持久化，我们需要将我们的数据备份到硬盘上，防止断电或是机器故障导致的数据丢失。 持久化的实现方式有两种方案：一种是直接保存当前已经存储的数据，相当于复制内存中的数据到硬盘上，需要恢复数据时直接读取即可；还有一种就是保存我们存放数据的所有过程，需要恢复数据时，只需要将整个过程完整地重演一遍就能保证与之前数据库中的内容一致。 RDBRDB就是我们所说的第一种解决方案，那么如何将数据保存到本地呢？我们可以使用命令： save-- 注意上面这个命令是直接保存，会占用一定的时间，也可以单独开一个子进程后台执行保存bgsave 执行后，会在服务端目录下生成一个dump.rdb文件，而这个文件中就保存了内存中存放的数据，当服务器重启后，会自动加载里面的内容到对应数据库中。保存后我们可以关闭服务器： shutdown 重启后可以看到数据依然存在。 虽然这种方式非常方便，但是由于会完整复制所有的数据，如果数据库中的数据量比较大，那么复制一次可能就需要花费大量的时间，所以我们可以每隔一段时间自动进行保存；还有就是，如果我们基本上都是在进行读操作，而没有进行写操作，实际上只需要偶尔保存一次即可，因为数据几乎没有怎么变化，可能两次保存的都是一样的数据。 我们可以在配置文件中设置自动保存，并设定在一段时间内写入多少数据时，执行一次保存操作： save 300 10 # 300秒（5分钟）内有10个写入save 60 10000 # 60秒（1分钟）内有10000个写入 配置的save使用的都是bgsave后台执行。 AOF虽然RDB能够很好地解决数据持久化问题，但是它的缺点也很明显：每次都需要去完整地保存整个数据库中的数据，同时后台保存过程中也会产生额外的内存开销，最严重的是它并不是实时保存的，如果在自动保存触发之前服务器崩溃，那么依然会导致少量数据的丢失。 而AOF就是另一种方式，它会以日志的形式将我们每次执行的命令都进行保存，服务器重启时会将所有命令依次执行，通过这种重演的方式将数据恢复，这样就能很好解决实时性存储问题。 但是，我们多久写一次日志呢？我们可以自己配置保存策略，有三种策略： always：每次执行写操作都会保存一次 everysec：每秒保存一次（默认配置），这样就算丢失数据也只会丢一秒以内的数据 no：看系统心情保存 可以在配置文件中配置： # 注意得改成也是appendonly yes# appendfsync alwaysappendfsync everysec# appendfsync no 重启服务器后，可以看到服务器目录下多了一个appendonly.aof文件，存储的就是我们执行的命令。 AOF的缺点也很明显，每次服务器启动都需要进行过程重演，相比RDB更加耗费时间，并且随着我们的操作变多，不断累计，可能到最后我们的aof文件会变得无比巨大，我们需要一个改进方案来优化这些问题。 Redis有一个AOF重写机制进行优化，比如我们执行了这样的语句： lpush test 666lpush test 777lpush test 888 实际上用一条语句也可以实现： lpush test 666 777 888 正是如此，只要我们能够保证最终的重演结果和原有语句的结果一致，无论语句如何修改都可以，所以我们可以通过这种方式将多条语句进行压缩。 我们可以输入命令来手动执行重写操作： bgrewriteaof 或是在配置文件中配置自动重写： # 百分比计算，这里不多介绍auto-aof-rewrite-percentage 100# 当达到这个大小时，触发自动重写auto-aof-rewrite-min-size 64mb 至此，我们就完成了两种持久化方案的介绍，最后我们再来进行一下总结： AOF： 优点：存储速度快、消耗资源少、支持实时存储 缺点：加载速度慢、数据体积大 RDB： 优点：加载速度快、数据体积小 缺点：存储速度慢大量消耗资源、会发生数据丢失 事务和锁机制和MySQL一样，在Redis中也有事务机制，当我们需要保证多条命令一次性完整执行而中途不受到其他命令干扰时，就可以使用事务机制。 我们可以使用命令来直接开启事务： multi 当我们输入完所有要执行的命令时，可以使用命令来立即执行事务： exec 我们也可以中途取消事务： discard 实际上整个事务是创建了一个命令队列，它不像MySQL那种在事务中也能单独得到结果，而是我们提前将所有的命令装在队列中，但是并不会执行，而是等我们提交事务的时候再统一执行。 锁又提到锁了，实际上这个概念对我们来说已经不算是陌生了。实际上在Redis中也会出现多个命令同时竞争同一个数据的情况，比如现在有两条命令同时执行，他们都要去修改a的值，那么这个时候就只能动用锁机制来保证同一时间只能有一个命令操作。 虽然Redis中也有锁机制，但是它是一种乐观锁，不同于MySQL，我们在MySQL中认识的锁是悲观锁，那么什么是乐观锁什么是悲观锁呢？ 悲观锁：时刻认为别人会来抢占资源，禁止一切外来访问，直到释放锁，具有强烈的排他性质。 乐观锁：并不认为会有人来抢占资源，所以会直接对数据进行操作，在操作时再去验证是否有其他人抢占资源。 Redis中可以使用watch来监视一个目标，如果执行事务之前被监视目标发生了修改，则取消本次事务： watch 我们可以开两个客户端进行测试。 取消监视可以使用： unwatch 至此，Redis的基础内容就讲解完毕了，在之后的SpringCloud阶段，我们还会去讲解集群相关的知识，包括主从复制、哨兵模式等。 使用Java与Redis交互既然了解了如何通过命令窗口操作Redis数据库，那么我们如何使用Java来操作呢？ 这里我们需要使用到Jedis框架，它能够实现Java与Redis数据库的交互，依赖： &lt;dependencies&gt;&lt;dependency&gt;&lt;groupId&gt;redis.clients&lt;&#x2F;groupId&gt;&lt;artifactId&gt;jedis&lt;&#x2F;artifactId&gt;&lt;version&gt;4.0.0&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt; 基本操作我们来看看如何连接Redis数据库，非常简单，只需要创建一个对象即可： public static void main(String[] args) {&#x2F;&#x2F;创建Jedis对象Jedis jedis &#x3D; new Jedis(“localhost”, 6379); //使用之后关闭连接 jedis.close(); } 通过Jedis对象，我们就可以直接调用命令的同名方法来执行Redis命令了，比如： public static void main(String[] args) {&#x2F;&#x2F;直接使用try-with-resouse，省去closetry(Jedis jedis &#x3D; new Jedis(“192.168.10.3”, 6379)){jedis.set(“test”, “lbwnb”); &#x2F;&#x2F;等同于 set test lbwnb 命令System.out.println(jedis.get(“test”)); &#x2F;&#x2F;等同于 get test 命令}} Hash类型的数据也是这样： public static void main(String[] args) {try(Jedis jedis &#x3D; new Jedis(“192.168.10.3”, 6379)){jedis.hset(“hhh”, “name”, “sxc”); &#x2F;&#x2F;等同于 hset hhh name sxcjedis.hset(“hhh”, “sex”, “19”); &#x2F;&#x2F;等同于 hset hhh age 19jedis.hgetAll(“hhh”).forEach((k, v) -&gt; System.out.println(k+”: “+v));}} 我们接着来看看列表操作： public static void main(String[] args) {try(Jedis jedis &#x3D; new Jedis(“192.168.10.3”, 6379)){jedis.lpush(“mylist”, “111”, “222”, “333”); &#x2F;&#x2F;等同于 lpush mylist 111 222 333 命令jedis.lrange(“mylist”, 0, -1).forEach(System.out::println); &#x2F;&#x2F;等同于 lrange mylist 0 -1}} 实际上我们只需要按照对应的操作去调用同名方法即可，所有的类型封装Jedis已经帮助我们完成了。 SpringBoot整合Redis我们接着来看如何在SpringBoot项目中整合Redis操作框架，只需要一个starter即可，但是它底层没有用Jedis，而是Lettuce： &lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt; starter提供的默认配置会去连接本地的Redis服务器，并使用0号数据库，当然你也可以手动进行修改： spring:redis:#Redis服务器地址host: 192.168.10.3#端口port: 6379#使用几号数据库database: 0 starter已经给我们提供了两个默认的模板类： @Configuration(proxyBeanMethods &#x3D; false)@ConditionalOnClass({RedisOperations.class})@EnableConfigurationProperties({RedisProperties.class})@Import({LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class})public class RedisAutoConfiguration {public RedisAutoConfiguration() {}@Bean@ConditionalOnMissingBean(name &#x3D; {“redisTemplate”})@ConditionalOnSingleCandidate(RedisConnectionFactory.class)public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) {RedisTemplate&lt;Object, Object&gt; template &#x3D; new RedisTemplate();template.setConnectionFactory(redisConnectionFactory);return template;}@Bean@ConditionalOnMissingBean@ConditionalOnSingleCandidate(RedisConnectionFactory.class)public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) {return new StringRedisTemplate(redisConnectionFactory);}} 那么如何去使用这两个模板类呢？我们可以直接注入StringRedisTemplate来使用模板： @SpringBootTestclass SpringBootTestApplicationTests {@AutowiredStringRedisTemplate template;@Testvoid contextLoads() {ValueOperations&lt;String, String&gt; operations &#x3D; template.opsForValue();operations.set(“c”, “xxxxx”); &#x2F;&#x2F;设置值System.out.println(operations.get(“c”)); &#x2F;&#x2F;获取值 template.delete(&quot;c&quot;); //删除键 System.out.println(template.hasKey(&quot;c&quot;)); //判断是否包含键 &#125; } 实际上所有的值的操作都被封装到了ValueOperations对象中，而普通的键操作直接通过模板对象就可以使用了，大致使用方式其实和Jedis一致。 我们接着来看看事务操作，由于Spring没有专门的Redis事务管理器，所以只能借用JDBC提供的，只不过无所谓，正常情况下反正我们也要用到这玩意： &lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-boot-starter-jdbc&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;&lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;&lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt; @Servicepublic class RedisService {@ResourceStringRedisTemplate template;@PostConstructpublic void init(){template.setEnableTransactionSupport(true); &#x2F;&#x2F;需要开启事务}@Transactional &#x2F;&#x2F;需要添加此注解public void test(){template.multi();template.opsForValue().set(“d”, “xxxxx”);template.exec();}} 我们还可以为RedisTemplate对象配置一个Serializer来实现对象的JSON存储： @Testvoid contextLoad2() {&#x2F;&#x2F;注意Student需要实现序列化接口才能存入Redistemplate.opsForValue().set(“student”, new Student());System.out.println(template.opsForValue().get(“student”));} 使用Redis做缓存我们可以轻松地使用Redis来实现一些框架的缓存和其他存储。 Mybatis二级缓存还记得我们在学习Mybatis讲解的缓存机制吗，我们当时介绍了二级缓存，它是Mapper级别的缓存，能够作用与所有会话。但是当时我们提出了一个问题，由于Mybatis的默认二级缓存只能是单机的，如果存在多台服务器访问同一个数据库，实际上二级缓存只会在各自的服务器上生效，但是我们希望的是多台服务器都能使用同一个二级缓存，这样就不会造成过多的资源浪费。 我们可以将Redis作为Mybatis的二级缓存，这样就能实现多台服务器使用同一个二级缓存，因为它们只需要连接同一个Redis服务器即可，所有的缓存数据全部存储在Redis服务器上。我们需要手动实现Mybatis提供的Cache接口，这里我们简单编写一下： &#x2F;&#x2F;实现Mybatis的Cache接口public class RedisMybatisCache implements Cache {private final String id;private static RedisTemplate&lt;Object, Object&gt; template;&#x2F;&#x2F;注意构造方法必须带一个String类型的参数接收idpublic RedisMybatisCache(String id){this.id &#x3D; id;}&#x2F;&#x2F;初始化时通过配置类将RedisTemplate给过来public static void setTemplate(RedisTemplate&lt;Object, Object&gt; template) {RedisMybatisCache.template &#x3D; template;}@Overridepublic String getId() {return id;}@Overridepublic void putObject(Object o, Object o1) {&#x2F;&#x2F;这里直接向Redis数据库中丢数据即可，o就是Key，o1就是Value，60秒为过期时间template.opsForValue().set(o, o1, 60, TimeUnit.SECONDS);}@Overridepublic Object getObject(Object o) {&#x2F;&#x2F;这里根据Key直接从Redis数据库中获取值即可return template.opsForValue().get(o);}@Overridepublic Object removeObject(Object o) {&#x2F;&#x2F;根据Key删除return template.delete(o);}@Overridepublic void clear() {&#x2F;&#x2F;由于template中没封装清除操作，只能通过connection来执行template.execute((RedisCallback&lt;Void&gt;) connection -&gt; {&#x2F;&#x2F;通过connection对象执行清空操作connection.flushDb();return null;});}@Overridepublic int getSize() {&#x2F;&#x2F;这里也是使用connection对象来获取当前的Key数量return template.execute(RedisServerCommands::dbSize).intValue();}} 缓存类编写完成后，我们接着来编写配置类： @Configurationpublic class MainConfiguration {@ResourceRedisTemplate&lt;Object, Object&gt; template;@PostConstructpublic void init(){&#x2F;&#x2F;把RedisTemplate给到RedisMybatisCacheRedisMybatisCache.setTemplate(template);}} 最后我们在Mapper上启用此缓存即可： &#x2F;&#x2F;只需要修改缓存实现类implementation为我们的RedisMybatisCache即可@CacheNamespace(implementation &#x3D; RedisMybatisCache.class)@Mapperpublic interface MainMapper {@Select(“select name from student where sid &#x3D; 1”)String getSid();} 最后我们提供一个测试用例来查看当前的二级缓存是否生效： @SpringBootTestclass SpringBootTestApplicationTests {@ResourceMainMapper mapper;@Testvoid contextLoads() {System.out.println(mapper.getSid());System.out.println(mapper.getSid());System.out.println(mapper.getSid());}} 手动使用客户端查看Redis数据库，可以看到已经有一条Mybatis生成的缓存数据了。 Token持久化存储我们之前使用SpringSecurity时，remember-me的Token是支持持久化存储的，而我们当时是存储在数据库中，那么Token信息能否存储在缓存中呢，当然也是可以的，我们可以手动实现一个： &#x2F;&#x2F;实现PersistentTokenRepository接口@Componentpublic class RedisTokenRepository implements PersistentTokenRepository {&#x2F;&#x2F;Key名称前缀，用于区分private final static String REMEMBER_ME_KEY &#x3D; “spring:security:rememberMe:”;@ResourceRedisTemplate&lt;Object, Object&gt; template;@Overridepublic void createNewToken(PersistentRememberMeToken token) {&#x2F;&#x2F;这里要放两个，一个存seriesId-&gt;Token，一个存username-&gt;seriesId，因为删除时是通过username删除template.opsForValue().set(REMEMBER_ME_KEY+”username:”+token.getUsername(), token.getSeries());template.expire(REMEMBER_ME_KEY+”username:”+token.getUsername(), 1, TimeUnit.DAYS);this.setToken(token);}&#x2F;&#x2F;先获取，然后修改创建一个新的，再放入@Overridepublic void updateToken(String series, String tokenValue, Date lastUsed) {PersistentRememberMeToken token &#x3D; this.getToken(series);if(token !&#x3D; null)this.setToken(new PersistentRememberMeToken(token.getUsername(), series, tokenValue, lastUsed));}@Overridepublic PersistentRememberMeToken getTokenForSeries(String seriesId) {return this.getToken(seriesId);}&#x2F;&#x2F;通过username找seriesId直接删除这两个@Overridepublic void removeUserTokens(String username) {String series &#x3D; (String) template.opsForValue().get(REMEMBER_ME_KEY+”username:”+username);template.delete(REMEMBER_ME_KEY+series);template.delete(REMEMBER_ME_KEY+”username:”+username);} //由于PersistentRememberMeToken没实现序列化接口，这里只能用Hash来存储了，所以单独编写一个set和get操作 private PersistentRememberMeToken getToken(String series)&#123; Map&amp;lt;Object, Object&amp;gt; map = template.opsForHash().entries(REMEMBER\\_ME\\_KEY+series); if(map.isEmpty()) return null; return new PersistentRememberMeToken( (String) map.get(&quot;username&quot;), (String) map.get(&quot;series&quot;), (String) map.get(&quot;tokenValue&quot;), new Date(Long.parseLong((String) map.get(&quot;date&quot;)))); &#125; private void setToken(PersistentRememberMeToken token)&#123; Map&amp;lt;String, String&amp;gt; map = new HashMap&lt;&gt;(); map.put(&quot;username&quot;, token.getUsername()); map.put(&quot;series&quot;, token.getSeries()); map.put(&quot;tokenValue&quot;, token.getTokenValue()); map.put(&quot;date&quot;, &quot;&quot;+token.getDate().getTime()); template.opsForHash().putAll(REMEMBER\\_ME\\_KEY+token.getSeries(), map); template.expire(REMEMBER\\_ME\\_KEY+token.getSeries(), 1, TimeUnit.DAYS); &#125; } 接着把验证Service实现了： @Servicepublic class AuthService implements UserDetailsService {@ResourceUserMapper mapper;@Overridepublic UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {Account account &#x3D; mapper.getAccountByUsername(username);if(account &#x3D;&#x3D; null) throw new UsernameNotFoundException(“”);return User.withUsername(username).password(account.getPassword()).roles(account.getRole()).build();}} Mapper也安排上： @Datapublic class Account implements Serializable {int id;String username;String password;String role;} @CacheNamespace(implementation &#x3D; MybatisRedisCache.class)@Mapperpublic interface UserMapper {@Select(“select * from users where username &#x3D; #{username}”)Account getAccountByUsername(String username);} 最后配置文件配一波： @Overrideprotected void configure(HttpSecurity http) throws Exception {http.authorizeRequests().anyRequest().authenticated().and().formLogin().and().rememberMe().tokenRepository(repository);}@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception {auth.userDetailsService(service).passwordEncoder(new BCryptPasswordEncoder());} OK，启动服务器验证一下吧。 三大缓存问题**注意：**这部分内容作为选学内容。 虽然我们可以利用缓存来大幅度提升我们程序的数据获取效率，但是使用缓存也存在着一些潜在的问题。 缓存穿透 当我们去查询一个一定不存在的数据，比如Mybatis在缓存是未命中的情况下需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。 这显然是很浪费资源的，我们希望的是，如果这个数据不存在，为什么缓存这一层不直接返回空呢，这时就不必再去查数据库了，但是也有一个问题，缓存不去查数据库怎么知道数据库里面到底有没有这个数据呢？ 这时我们就可以使用布隆过滤器来进行判断。什么是布隆过滤器？（当然不是打辅助的那个布隆，只不过也挺像，辅助布隆也是挡子弹的） 使用布隆过滤器，能够告诉你某样东西一定不存在或是某样东西可能存在。 布隆过滤器本质是一个存放二进制位的bit数组，如果我们要添加一个值到布隆过滤器中，我们需要使用N个不同的哈希函数来生成N个哈希值，并对每个生成的哈希值指向的bit位置1，如上图所示，一共添加了三个值abc。 接着我们给一个d，那么这时就可以进行判断，如果说d计算的N个哈希值的位置上都是1，那么就说明d可能存在；这时候又来了个e，计算后我们发现有一个位置上的值是0，这时就可以直接断定e一定不存在。 缓存击穿 某个 Key 属于热点数据，访问非常频繁，同一时间很多人都在访问，在这个Key失效的瞬间，大量的请求到来，这时发现缓存中没有数据，就全都直接请求数据库，相当于击穿了缓存屏障，直接攻击整个系统核心。 这种情况下，最好的解决办法就是不让Key那么快过期，如果一个Key处于高频访问，那么可以适当地延长过期时间。 缓存雪崩 当你的Redis服务器炸了或是大量的Key在同一时间过期，这时相当于缓存直接GG了，那么如果这时又有很多的请求来访问不同的数据，同一时间内缓存服务器就得向数据库大量发起请求来重新建立缓存，很容易把数据库也搞GG。 解决这种问题最好的办法就是设置高可用，也就是搭建Redis集群，当然也可以采取一些服务熔断降级机制，这些内容我们会在SpringCloud阶段再进行探讨。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"Springboot笔记","slug":"Java/Springboot笔记","permalink":"http://example.com/categories/Java/Springboot%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"SpringBoot笔记（二）","slug":"e28befc0f1c24c7d99df9847b5d91cb7","date":"2023-01-24T14:04:13.242Z","updated":"2023-01-24T14:04:44.706Z","comments":true,"path":"2023/01/24/e28befc0f1c24c7d99df9847b5d91cb7/","link":"","permalink":"http://example.com/2023/01/24/e28befc0f1c24c7d99df9847b5d91cb7/","excerpt":"","text":"Git版本控制**注意：**开始学习之前，确保自己的网络可以畅通的连接Github：https://github.com，这个是一个国外网站，连起来特别卡，至于用什么方式实现流畅访问，懂的都懂。 其实版本控制在我们的生活中无处不在，比如你的期末或是毕业答辩论文，由于你写得不规范或是老师不满意，你的老师可能会让你改了又改，于是就会出现下面这种情况： 我们手里的论文可能会经过多次版本迭代，最终我们会选取一个最好的版本作为最终提交的论文。使用版本控制不仅仅是为了去记录版本迭代历史，更是为了能够随时回退到之前的版本，实现时间回溯。同时，可能我们的论文是多个人一同完成，那么多个人如何去实现同步，如何保证每个人提交的更改都能够正常汇总，如何解决冲突，这些问题都需要一个优秀的版本控制系统来解决。 走进Git我们开发的项目，也需要一个合适的版本控制系统来协助我们更好地管理版本迭代，而Git正是因此而诞生的（有关Git的历史，这里就不多做阐述了，感兴趣的小伙伴可以自行了解，是一位顶级大佬在一怒之下只花了2周时间用C语言开发的，之后的章节还会遇到他） 首先我们来了解一下Git是如何工作的： 可以看到，它大致分为4个板块： 工作目录：存放我们正在写的代码（当我们新版本开发完成之后，就可以进行新版本的提交） 暂存区：暂时保存待提交的内容（新版本提交后会存放到本地仓库） 本地仓库：位于我们电脑上的一个版本控制仓库（存放的就是当前项目各个版本代码的增删信息） 远程仓库：位于服务器上的版本控制仓库（服务器上的版本信息可以由本地仓库推送上去，也可以从服务器抓取到本地仓库） 它是一个分布式的控制系统，因此一般情况下我们每个人的电脑上都有一个本地仓库，由大家共同向远程仓库去推送版本迭代信息。 通过这一系列操作，我们就可以实现每开发完一个版本或是一个功能，就提交一次新版本，这样，我们就可以很好地控制项目的版本迭代，想回退到之前的版本随时都可以回退，想查看新版本添加或是删除了什么代码，随时都可以查看。 安装Git首先请前往Git官网去下载最新的安装包：https://git-scm.com/download/win 这手把手演示一下如何安装Git环境。 安装完成后，需要设定用户名和邮箱来区分不同的用户： 12git config --global user.name &quot;Your Name&quot;git config --global user.email &quot;email@example.com&quot; 基本命令介绍创建本地仓库我们可以将任意一个文件夹作为一个本地仓库，输入： 1git init 输入后，会自动生成一个.git目录，注意这个目录是一个隐藏目录，而当前目录就是我们的工作目录。 创建成功后，我们可以查看一下当前的一个状态，输入： 1git status 如果已经成功配置为Git本地仓库，那么输入后可以看到： 123On branch masterNo commits yet 这表示我们还没有向仓库中提交任何内容，也就是一个空的状态。 添加和提交接着我们来看看，如何使用git来管理我们文档的版本，我们创建一个文本文档，随便写入一点内容，接着输入： 1git status 我们会得到如下提示： 12345Untracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) hello.txtnothing added to commit but untracked files present (use &quot;git add&quot; to track) 其中Untracked files是未追踪文件的意思，也就是说，如果一个文件处于未追踪状态，那么git不会记录它的变化，始终将其当做一个新创建的文件，这里我们将其添加到暂存区，那么它会自动变为被追踪状态： 1git add hello.txt #也可以 add . 一次性添加目录下所有的 再次查看当前状态： 123Changes to be committed: (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) new file: hello.txt 现在文件名称的颜色变成了绿色，并且是处于Changes to be committed下面，因此，我们的hello.txt现在已经被添加到暂存区了。 接着我们来尝试将其提交到Git本地仓库中，注意需要输入提交的描述以便后续查看，比如你这次提交修改了或是新增了哪些内容： 1git commit -m &#x27;Hello World&#x27; 接着我们可以查看我们的提交记录： 12git loggit log --graph 我们还可以查看最近一次变更的详细内容： 1git show [也可以加上commit ID查看指定的提交记录] 再次查看当前状态，已经是清空状态了： 12On branch masternothing to commit, working tree clean 接着我们可以尝试修改一下我们的文本文档，由于当前文件已经是被追踪状态，那么git会去跟踪它的变化，如果说文件发生了修改，那么我们再次查看状态会得到下面的结果： 1234Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: hello.txt 也就是说现在此文件是处于已修改状态，我们如果修改好了，就可以提交我们的新版本到本地仓库中： 12git add .git commit -m &#x27;Modify Text&#x27; 接着我们来查询一下提交记录，可以看到一共有两次提交记录。 我们可以创建一个.gitignore文件来确定一个文件忽略列表，如果忽略列表中的文件存在且不是被追踪状态，那么git不会对其进行任何检查： 12345678910# 这样就会匹配所有以txt结尾的文件*.txt# 虽然上面排除了所有txt结尾的文件，但是这个不排除!666.txt# 也可以直接指定一个文件夹，文件夹下的所有文件将全部忽略test/# 目录中所有以txt结尾的文件，但不包括子目录xxx/*.txt# 目录中所有以txt结尾的文件，包括子目录xxx/**/*.txt 创建后，我们来看看是否还会检测到我们忽略的文件。 回滚当我们想要回退到过去的版本时，就可以执行回滚操作，执行后，可以将工作空间的内容恢复到指定提交的状态： 1git reset --hard commitID 执行后，会直接重置为那个时候的状态。再次查看提交日志，我们发现之后的日志全部消失了。 那么要是现在我又想回去呢？我们可以通过查看所有分支的所有操作记录： 1git reflog 这样就能找到之前的commitID，再次重置即可。 分支分支就像我们树上的一个树枝一样，它们可能一开始的时候是同一根树枝，但是长着长着就开始分道扬镳了，这就是分支。我们的代码也是这样，可能一开始写基础功能的时候使用的是单个分支，但是某一天我们希望基于这些基础的功能，把我们的项目做成两个不同方向的项目，比如一个方向做Web网站，另一个方向做游戏服务端。 因此，我们可以在一个主干上分出N个分支，分别对多个分支的代码进行维护。 创建分支我们可以通过以下命令来查看当前仓库中存在的分支： 1git branch 我们发现，默认情况下是有一个master分支的，并且我们使用的也是master分支，一般情况下master分支都是正式版本的更新，而其他分支一般是开发中才频繁更新的。我们接着来基于当前分支创建一个新的分支： 123git branch test# 对应的删除分支是git branch -d yyds 现在我们修改一下文件，提交，再查看一下提交日志： 1git commit -a -m &#x27;branch master commit&#x27; 通过添加-a来自动将未放入暂存区的已修改文件放入暂存区并执行提交操作。查看日志，我们发现现在我们的提交只生效于master分支，而新创建的分支并没有发生修改。 我们将分支切换到另一个分支： 1git checkout test 我们会发现，文件变成了此分支创建的时的状态，也就是说，在不同分支下我们的文件内容是相互隔离的。 我们现在再来提交一次变更，会发现它只生效在yyds分支上。我们可以看看当前的分支状态： 1git log --all --graph 合并分支我们也可以将两个分支更新的内容最终合并到同一个分支上，我们先切换回主分支： 1git checkout master 接着使用分支合并命令： 1git merge test 会得到如下提示： Auto-merging hello.txt CONFLICT (content): Merge conflict in hello.txt Automatic merge failed; fix conflicts and then commit the result. 在合并过程中产生了冲突，因为两个分支都对hello.txt文件进行了修改，那么现在要合并在一起，到底保留谁的hello文件呢？ 我们可以查看一下是哪里发生了冲突： 1git diff 因此，现在我们将master分支的版本回退到修改hello.txt之前或是直接修改为最新版本的内容，这样就不会有冲突了，接着再执行一次合并操作，现在两个分支成功合并为同一个分支。 变基分支除了直接合并分支以外，我们还可以进行变基操作，它跟合并不同，合并是分支回到主干的过程，而变基是直接修改分支开始的位置，比如我们希望将yyds变基到master上，那么yyds会将分支起点移动到master最后一次提交位置： 1git rebase master 变基后，yyds分支相当于同步了此前master分支的全部提交。 优选我们还可以选择其将他分支上的提交作用于当前分支上，这种操作称为cherrypick： 1git cherry-pick &lt;commit id&gt;:单独合并一个提交 这里我们在master分支上创建一个新的文件，提交此次更新，接着通过cherry-pick的方式将此次更新作用于test分支上。 使用IDEA版本控制虽然前面我们基本讲解了git的命令行使用方法，但是没有一个图形化界面，始终会感觉到很抽象，所以这里我们使用IDEA来演示，IDEA内部集成了git模块，它可以让我们的git版本管理图形化显示，当然除了IDEA也有一些独立的软件比如：SourceTree（挺好用） 打开IDEA后，找到版本控模块，我们直接点击创建本地仓库，它会自动将当前项目的根目录作为我们的本地仓库，而我们编写的所有代码和项目目录下其他的文件都可以进行版本控制。 我们发现所有项目中正在编写的类文件全部变红了，也就是处于未追踪状态，接着我们进行第一次初始化提交，提交之后我们可以在下方看到所有的本地仓库提交记录。 接着我们来整合一下Web环境，创建新的类之后，IDEA会提示我们是否将文件添加到Git，也就是是否放入暂存区并开启追踪，我们可以直接对比两次代码的相同和不同之处。 接着我们来演示一下分支创建和分支管理。 远程仓库远程仓库实际上就是位于服务器上的仓库，它能在远端保存我们的版本历史，并且可以实现多人同时合作编写项目，每个人都能够同步他人的版本，能够看到他人的版本提交，相当于将我们的代码放在服务器上进行托管。 远程仓库有公有和私有的，公有的远程仓库有GitHub、码云、Coding等，他们都是对外开放的，我们注册账号之后就可以使用远程仓库进行版本控制，其中最大的就是GitHub，但是它服务器在国外，我们国内连接可能会有一点卡。私有的一般是GitLab这种自主搭建的远程仓库私服，在公司中比较常用，它只对公司内部开放，不对外开放。 这里我们以GitHub做讲解，官网：https://github.com，首先完成用户注册。 远程账户认证和推送接着我们就可以创建一个自定义的远程仓库了。 创建仓库后，我们可以通过推送来将本地仓库中的内容推送到远程仓库。 12git remote add 名称 远程仓库地址git push 远程仓库名称 本地分支名称[:远端分支名称] 注意push后面两个参数，一个是远端名称，还有一个就是本地分支名称，但是如果本地分支名称和远端分支名称一致，那么不用指定远端分支名称，但是如果我们希望推送的分支在远端没有同名的，那么需要额外指定。推送前需要登陆账户，GitHub现在不允许使用用户名密码验证，只允许使用个人AccessToken来验证身份，所以我们需要先去生成一个Token才可以。 推送后，我们发现远程仓库中的内容已经与我们本地仓库中的内容保持一致了，注意，远程仓库也可以有很多个分支。 但是这样比较麻烦，我们每次都需要去输入用户名和密码，有没有一劳永逸的方法呢？当然，我们也可以使用SSH来实现一次性校验，我们可以在本地生成一个rsa公钥： 12ssh-keygen -t rsacat ~/.ssh/github.pub 接着我们需要在GitHub上上传我们的公钥，当我们再次去访问GitHub时，会自动验证，就无需进行登录了，之后在Linux部分我们会详细讲解SSH的原理。 接着我们修改一下工作区的内容，提交到本地仓库后，再推送到远程仓库，提交的过程中我们注意观察提交记录： 1234git commit -a -m &#x27;Modify files&#x27;git log --all --oneline --graphgit push origin master git log --all --oneline --graph 我们可以将远端和本地的分支进行绑定，绑定后就不需要指定分支名称了： 12git push --set-upstream origin master:mastergit push origin 在一个本地仓库对应一个远程仓库的情况下，远程仓库基本上就是纯粹的代码托管了（云盘那种感觉，就纯粹是存你代码的） 克隆项目如果我们已经存在一个远程仓库的情况下，我们需要在远程仓库的代码上继续编写代码，这个时候怎么办呢？ 我们可以使用克隆操作来将远端仓库的内容全部复制到本地： 1git clone 远程仓库地址 这样本地就能够直接与远程保持同步。 抓取、拉取和冲突解决我们接着来看，如果这个时候，出现多个本地仓库对应一个远程仓库的情况下，比如一个团队里面，N个人都在使用同一个远程仓库，但是他们各自只负责编写和推送自己业务部分的代码，也就是我们常说的协同工作，那么这个时候，我们就需要协调。 比如程序员A完成了他的模块，那么他就可以提交代码并推送到远程仓库，这时程序员B也要开始写代码了，由于远程仓库有其他程序员的提交记录，因此程序员B的本地仓库和远程仓库不一致，这时就需要有先进行pull操作，获取远程仓库中最新的提交： 12git fetch 远程仓库 #抓取：只获取但不合并远端分支，后面需要我们手动合并才能提交git pull 远程仓库 #拉取：获取+合并 在程序员B拉取了最新的版本后，再编写自己的代码然后提交就可以实现多人合作编写项目了，并且在拉取过程中就能将别人提交的内容同步到本地，开发效率大大提升。 如果工作中存在不协调的地方，比如现在我们本地有两个仓库，一个仓库去修改hello.txt并直接提交，另一个仓库也修改hello.txt并直接提交，会得到如下错误： To https://github.com/xx/xxx.git ! [rejected] master -&gt; master (fetch first) error: failed to push some refs to &#39;https://github.com/xx/xxx.git&#39; hint: Updates were rejected because the remote contains work that you do hint: not have locally. This is usually caused by another repository pushing hint: to the same ref. You may want to first integrate the remote changes hint: (e.g., &#39;git pull ...&#39;) before pushing again. hint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details. 一旦一个本地仓库推送了代码，那么另一个本地仓库的推送会被拒绝，原因是当前文件已经被其他的推送给修改了，我们这边相当于是另一个版本，和之前两个分支合并一样，产生了冲突，因此我们只能去解决冲突问题。 如果远程仓库中的提交和本地仓库中的提交没有去编写同一个文件，那么就可以直接拉取： 1git pull 远程仓库 拉取后会自动进行合并，合并完成之后我们再提交即可。 但是如果两次提交都修改了同一个文件，那么就会遇到和多分支合并一样的情况，在合并时会产生冲突，这时就需要我们自己去解决冲突了。 我们可以在IDEA中演示一下，实际开发场景下可能会遇到的问题。 至此，Git版本控制就讲解到这里，下一章我们会继续认识一个全新的数据库：Redis。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"Springboot笔记","slug":"Java/Springboot笔记","permalink":"http://example.com/categories/Java/Springboot%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"SpringBoot笔记（一）","slug":"05176b8a3d5648d6b1fe75092e4c293b","date":"2023-01-24T14:03:14.433Z","updated":"2023-01-24T14:04:36.300Z","comments":true,"path":"2023/01/24/05176b8a3d5648d6b1fe75092e4c293b/","link":"","permalink":"http://example.com/2023/01/24/05176b8a3d5648d6b1fe75092e4c293b/","excerpt":"","text":"SpringBoot一站式开发官网：https://spring.io/projects/spring-boot Spring Boot可以轻松创建独立的、基于Spring的生产级应用程序，它可以让你“运行即可”。大多数Spring Boot应用程序只需要少量的Spring配置。 SpringBoot功能： 创建独立的Spring应用程序 直接嵌入Tomcat、Jetty或Undertow（无需部署WAR包，打包成Jar本身就是一个可以运行的应用程序） 提供一站式的“starter”依赖项，以简化Maven配置（需要整合什么框架，直接导对应框架的starter依赖） 尽可能自动配置Spring和第三方库（除非特殊情况，否则几乎不需要你进行什么配置） 提供生产就绪功能，如指标、运行状况检查和外部化配置 没有代码生成，也没有XML配置的要求（XML是什么，好吃吗） SpringBoot是现在最主流的开发框架，它提供了一站式的开发体验，大幅度提高了我们的开发效率。 走进SpringBoot在SSM阶段，当我们需要搭建一个基于Spring全家桶的Web应用程序时，我们不得不做大量的依赖导入和框架整合相关的Bean定义，光是整合框架就花费了我们大量的时间，但是实际上我们发现，整合框架其实基本都是一些固定流程，我们每创建一个新的Web应用程序，基本都会使用同样的方式去整合框架，我们完全可以将一些重复的配置作为约定，只要框架遵守这个约定，为我们提供默认的配置就好，这样就不用我们再去配置了，约定优于配置！ 而SpringBoot正是将这些过程大幅度进行了简化，它可以自动进行配置，我们只需要导入对应的启动器（starter）依赖即可。 完成本阶段的学习，基本能够胜任部分网站系统的后端开发工作，也建议同学们学习完SpringBoot之后寻找合适的队友去参加计算机项目相关的高校竞赛。 我们可以通过IDEA来演示如何快速创建一个SpringBoot项目，并且无需任何配置，就可以实现Bean注册。 SpringBoot项目文件结构我们在创建SpringBoot项目之后，首先会自动生成一个主类，而主类中的main方法中调用了SpringApplication类的静态方法来启动整个SpringBoot项目，并且我们可以看到主类的上方有一个@SpringBootApplication注解： @SpringBootApplication public class SpringBootTestApplication { ​ public static void main(String[] args) { SpringApplication.run(SpringBootTestApplication.class, args); } ​ } 同时还自带了一个测试类，测试类的上方仅添加了一个@SpringBootTest注解： @SpringBootTest class SpringBootTestApplicationTests { ​ @Test void contextLoads() { } ​ } 我们接着来看Maven中写了哪些内容： &lt;project xmlns&#x3D;”http://maven.apache.org/POM/4.0.0“ xmlns:xsi&#x3D;”http://www.w3.org/2001/XMLSchema-instance“ xsi:schemaLocation&#x3D;”http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"> 4.0.0 &lt;!– 父工程 –&gt; org.springframework.boot spring-boot-starter-parent 2.6.2 &lt;!– lookup parent from repository –&gt; com.example springboot-study 0.0.1-SNAPSHOT SpringBootTest SpringBootTest &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt; &lt;!– spring-boot-starter SpringBoot核心启动器 –&gt; org.springframework.boot spring-boot-starter &lt;!– spring-boot-starter-test SpringBoot测试模块启动器 –&gt; org.springframework.boot spring-boot-starter-test test ​ &lt;!– SpringBoot Maven插件，打包Jar都不用你操心了 –&gt; org.springframework.boot spring-boot-maven-plugin ​ 除了以上这些文件以外，我们的项目目录下还有： .gitignore - Git忽略名单，下一章我们会专门讲解Git版本控制。 application.properties - SpringBoot的配置文件，所有依赖的配置都在这里编写，但是一般情况下只需要配置必要项即可。 整合Web相关框架我们来看一下，既然我们前面提到SpringBoot会内嵌一个Tomcat服务器，也就是说我们的Jar打包后，相当于就是一个可以直接运行的应用程序，我们来看一下如何创建一个SpringBootWeb项目。 这里我们演示使用IDEA来创建一个基于SpringBoot的Web应用程序。 它是真的快创建完成后，直接开启项目，我们就可以直接访问：http://localhost:8080/，我们可以看到，但是由于我们没有编写任何的请求映射，所以没有数据。我们可以来看看日志： 2022-01-06 22:17:46.308 INFO 853 — [ main] c.example.SpringBootWebTestApplication : Starting SpringBootWebTestApplication using Java 1.8.0_312 on NagodeMacBook-Pro.local with PID 853 (&#x2F;Users&#x2F;nagocoler&#x2F;Downloads&#x2F;SpringBootWebTest&#x2F;target&#x2F;classes started by nagocoler in &#x2F;Users&#x2F;nagocoler&#x2F;Downloads&#x2F;SpringBootWebTest) 2022-01-06 22:17:46.309 INFO 853 — [ main] c.example.SpringBootWebTestApplication : No active profile set, falling back to default profiles: default 2022-01-06 22:17:46.629 INFO 853 — [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat initialized with port(s): 8080 (http) 2022-01-06 22:17:46.632 INFO 853 — [ main] o.apache.catalina.core.StandardService : Starting service [Tomcat] 2022-01-06 22:17:46.632 INFO 853 — [ main] org.apache.catalina.core.StandardEngine : Starting Servlet engine: [Apache Tomcat&#x2F;9.0.56] 2022-01-06 22:17:46.654 INFO 853 — [ main] o.a.c.c.C.[Tomcat].[localhost].[&#x2F;] : Initializing Spring embedded WebApplicationContext 2022-01-06 22:17:46.654 INFO 853 — [ main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 325 ms 2022-01-06 22:17:46.780 INFO 853 — [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8080 (http) with context path ‘’ 2022-01-06 22:17:46.785 INFO 853 — [ main] c.example.SpringBootWebTestApplication : Started SpringBootWebTestApplication in 0.62 seconds (JVM running for 0.999) 2022-01-06 22:18:02.979 INFO 853 — [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[&#x2F;] : Initializing Spring DispatcherServlet ‘dispatcherServlet’ 2022-01-06 22:18:02.979 INFO 853 — [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet : Initializing Servlet ‘dispatcherServlet’ 2022-01-06 22:18:02.980 INFO 853 — [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet : Completed initialization in 1 ms 我们可以看到，日志中除了最基本的SpringBoot启动日志以外，还新增了内嵌Web服务器（Tomcat）的启动日志，并且显示了当前Web服务器所开放的端口，并且自动帮助我们初始化了DispatcherServlet，但是我们只是创建了项目，导入了web相关的starter依赖，没有进行任何的配置，实际上它使用的是starter提供的默认配置进行初始化的。 由于SpringBoot是自动扫描的，因此我们直接创建一个Controller即可被加载： @Controller public class MainController { ​ &#x2F;&#x2F;直接访问http://localhost:8080/index即可，不用加web应用程序名称了 @RequestMapping(“&#x2F;index”) @ResponseBody public String index(){ return “你好，欢迎访问主页！”; } } 我们几乎没有做任何配置，但是可以直接开始配置Controller，SpringBoot创建一个Web项目的速度就是这么快！ 它还可以自动识别类型，如果我们返回的是一个对象类型的数据，那么它会自动转换为JSON数据格式，无需配置： @Data public class Student { int sid; String name; String sex; } @RequestMapping(“&#x2F;student”) @ResponseBody public Student student(){ Student student &#x3D; new Student(); student.setName(“小明”); student.setSex(“男”); student.setSid(10); return student; } 最后浏览器能够直接得到application/json的响应数据，就是这么方便。 修改Web相关配置如果我们需要修改Web服务器的端口或是一些其他的内容，我们可以直接在application.properties中进行修改，它是整个SpringBoot的配置文件： # 修改端口为80 server.port&#x3D;80 我们还可以编写自定义的配置项，并在我们的项目中通过@Value直接注入： test.data&#x3D;100 @Controllerpublic class MainController {@Value(“${test.data}”)int data; 通过这种方式，我们就可以更好地将一些需要频繁修改的配置项写在配置文件中，并通过注解方式去获取值。 配置文件除了使用properties格式以外，还有一种叫做yaml格式，它的语法如下： 一级目录:二级目录:三级目录1: 值三级目录2: 值三级目录List:- 元素1- 元素2- 元素3 我们可以看到，每一级目录都是通过缩进（不能使用Tab，只能使用空格）区分，并且键和值之间需要添加冒号+空格来表示。 SpringBoot也支持这种格式的配置文件，我们可以将application.properties修改为application.yml或是application.yaml来使用YAML语法编写配置： server:port: 80 整合SpringSecurity依赖我们接着来整合一下SpringSecurity依赖，继续感受SpringBoot带来的光速开发体验，只需要导入SpringSecurity的Starter依赖即可： &lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-boot-starter-security&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt; 导入依赖后，我们直接启动SpringBoot应用程序，可以发现SpringSecurity已经生效了。 并且SpringSecurity会自动为我们生成一个默认用户user，它的密码会出现在日志中： 2022-01-06 23:10:51.329 INFO 2901 — [ main] o.apache.catalina.core.StandardService : Starting service [Tomcat]2022-01-06 23:10:51.329 INFO 2901 — [ main] org.apache.catalina.core.StandardEngine : Starting Servlet engine: [Apache Tomcat&#x2F;9.0.56]2022-01-06 23:10:51.350 INFO 2901 — [ main] o.a.c.c.C.[Tomcat].[localhost].[&#x2F;] : Initializing Spring embedded WebApplicationContext2022-01-06 23:10:51.351 INFO 2901 — [ main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 341 ms2022-01-06 23:10:51.469 INFO 2901 — [ main] .s.s.UserDetailsServiceAutoConfiguration :Using generated security password: ff24bee3-e1b7-4309-9609-d32618baf5cb 其中ff24bee3-e1b7-4309-9609-d32618baf5cb就是随机生成的一个密码，我们可以使用此用户登录。 我们也可以在配置文件中直接配置： spring:security:user:name: test # 用户名password: 123456 # 密码roles: # 角色- user- admin 实际上这样的配置方式就是一个inMemoryAuthentication，只是我们可以直接配置而已。 当然，页面的控制和数据库验证我们还是需要提供WebSecurityConfigurerAdapter的实现类去完成： @Configurationpublic class SecurityConfiguration extends WebSecurityConfigurerAdapter {@Overrideprotected void configure(HttpSecurity http) throws Exception {http.authorizeRequests().antMatchers(“&#x2F;login”).permitAll().anyRequest().hasRole(“user”).and().formLogin();}} 注意这里不需要再添加@EnableWebSecurity了，因为starter依赖已经帮我们添加了。 使用了SpringBoot之后，我们发现，需要什么功能，只需要导入对应的starter依赖即可，甚至都不需要你去进行额外的配置，你只需要关注依赖本身的必要设置即可，大大提高了我们的开发效率。 整合Mybatis框架我们接着来看如何整合Mybatis框架，同样的，我们只需要导入对应的starter依赖即可： &lt;dependency&gt;&lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;&lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;&lt;version&gt;2.2.0&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;&lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;&lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt; 导入依赖后，直接启动会报错，是因为有必要的配置我们没有去编写，我们需要指定数据源的相关信息： spring:datasource:url: jdbc:mysql:&#x2F;&#x2F;localhost:3306username: rootpassword: 123456driver-class-name: com.mysql.cj.jdbc.Driver 再次启动，成功。 我们发现日志中会出现这样一句话： 2022-01-07 12:32:09.106 WARN 6917 — [ main] o.m.s.mapper.ClassPathMapperScanner : No MyBatis mapper was found in ‘[com.example]’ package. Please check your configuration. 这是Mybatis自动扫描输出的语句，导入依赖后，我们不需要再去设置Mybatis的相关Bean了，也不需要添加任何@MapperSacn注解，因为starter已经帮助我们做了，它会自动扫描项目中添加了@Mapper注解的接口，直接将其注册为Bean，不需要进行任何配置。 @Mapperpublic interface MainMapper {@Select(“select * from users where username &#x3D; #{username}”)UserData findUserByName(String username);} 当然，如果你觉得每个接口都去加一个@Mapper比较麻烦的话也可以用回之前的方式，直接@MapperScan使用包扫描。 添加Mapper之后，使用方法和SSM阶段是一样的，我们可以将其与SpringSecurity结合使用： @Servicepublic class UserAuthService implements UserDetailsService {@ResourceMainMapper mapper;@Overridepublic UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {UserData data &#x3D; mapper.findUserByName(username);if(data &#x3D;&#x3D; null) throw new UsernameNotFoundException(“用户 “+username+” 登录失败，用户名不存在！”);return User.withUsername(data.getUsername()).password(data.getPassword()).roles(data.getRole()).build();}} 最后配置一下自定义验证即可，注意这样之前配置文件里面配置的用户就失效了： @Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception {auth.userDetailsService(service).passwordEncoder(new BCryptPasswordEncoder());} 在首次使用时，我们发现日志中输出以以下语句： 2022-01-07 12:39:40.559 INFO 6930 — [nio-8080-exec-3] com.zaxxer.hikari.HikariDataSource : HikariPool-1 - Starting…2022-01-07 12:39:41.033 INFO 6930 — [nio-8080-exec-3] com.zaxxer.hikari.HikariDataSource : HikariPool-1 - Start completed. 实际上，SpringBoot会自动为Mybatis配置数据源，默认使用的就是HikariCP数据源。 整合Thymeleaf框架整合Thymeleaf也只需导入对应的starter即可： &lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt; 接着我们只需要直接使用即可： @RequestMapping(“&#x2F;index”)public String index(){return “index”;} 但是注意，这样只能正常解析HTML页面，但是js、css等静态资源我们需要进行路径指定，不然无法访问，我们在配文件中配置一下静态资源的访问前缀： spring:mvc:static-path-pattern: &#x2F;static&#x2F;** 接着我们像之前一样，把登陆页面实现一下吧。 日志系统SpringBoot为我们提供了丰富的日志系统，它几乎是开箱即用的。 日志门面和日志实现我们首先要区分一下，什么是日志门面（Facade）什么是日志实现，我们之前学习的JUL实际上就是一种日志实现，我们可以直接使用JUL为我们提供的日志框架来规范化打印日志，而日志门面，如Slf4j，是把不同的日志系统的实现进行了具体的抽象化，只提供了统一的日志使用接口，使用时只需要按照其提供的接口方法进行调用即可，由于它只是一个接口，并不是一个具体的可以直接单独使用的日志框架，所以最终日志的格式、记录级别、输出方式等都要通过接口绑定的具体的日志系统来实现，这些具体的日志系统就有log4j、logback、java.util.logging等，它们才实现了具体的日志系统的功能。 日志门面和日志实现就像JDBC和数据库驱动一样，一个是画大饼的，一个是真的去做饼的。 但是现在有一个问题就是，不同的框架可能使用了不同的日志框架，如果这个时候出现众多日志框架并存的情况，我们现在希望的是所有的框架一律使用日志门面（Slf4j）进行日志打印，这时该怎么去解决？我们不可能将其他框架依赖的日志框架替换掉，直接更换为Slf4j吧，这样显然不现实。 这时，可以采取类似于偷梁换柱的做法，只保留不同日志框架的接口和类定义等关键信息，而将实现全部定向为Slf4j调用。相当于有着和原有日志框架一样的外壳，对于其他框架来说依然可以使用对应的类进行操作，而具体如何执行，真正的内心已经是Slf4j的了。 所以，SpringBoot为了统一日志框架的使用，做了这些事情： 直接将其他依赖以前的日志框架剔除 导入对应日志框架的Slf4j中间包 导入自己官方指定的日志实现，并作为Slf4j的日志实现层 在SpringBoot中打印日志信息SpringBoot使用的是Slf4j作为日志门面，Logback（Logback 是log4j 框架的作者开发的新一代日志框架，它效率更高、能够适应诸多的运行环境，同时天然支持SLF4J）作为日志实现，对应的依赖为： &lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-boot-starter-logging&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt; 此依赖已经被包含了，所以我们如果需要打印日志，可以像这样： @RequestMapping(“&#x2F;login”)public String login(){Logger logger &#x3D; LoggerFactory.getLogger(MainController.class);logger.info(“用户访问了一次登陆界面”);return “login”;} 因为我们使用了Lombok，所以直接一个注解也可以搞定哦： @Slf4j@Controllerpublic class MainController {@RequestMapping(“&#x2F;login”)public String login(){log.info(“用户访问了一次登陆界面”);return “login”;} 日志级别从低到高分为TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，SpringBoot默认只会打印INFO以上级别的信息。 配置Logback日志Logback官网：https://logback.qos.ch 和JUL一样，Logback也能实现定制化，我们可以编写对应的配置文件，SpringBoot推荐将配置文件名称命名为logback-spring.xml表示这是SpringBoot下Logback专用的配置，可以使用SpringBoot 的高级Proﬁle功能，它的内容类似于这样： &lt;?xml version&#x3D;”1.0” encoding&#x3D;”UTF-8”?&gt;&lt;configuration&gt;&lt;!– 配置 –&gt;&lt;&#x2F;configuration&gt; 最外层由configuration包裹，一旦编写，那么就会替换默认的配置，所以如果内部什么都不写的话，那么会导致我们的SpringBoot项目没有配置任何日志输出方式，控制台也不会打印日志。 我们接着来看如何配置一个控制台日志打印，我们可以直接导入并使用SpringBoot为我们预设好的日志格式，在org/springframework/boot/logging/logback/defaults.xml中已经帮我们把日志的输出格式定义好了，我们只需要设置对应的appender即可： &lt;included&gt;&lt;conversionRule conversionWord&#x3D;”clr” converterClass&#x3D;”org.springframework.boot.logging.logback.ColorConverter” &#x2F;&gt;&lt;conversionRule conversionWord&#x3D;”wex” converterClass&#x3D;”org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter” &#x2F;&gt;&lt;conversionRule conversionWord&#x3D;”wEx” converterClass&#x3D;”org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter” &#x2F;&gt;&lt;property name&#x3D;”CONSOLE_LOG_PATTERN” value&#x3D;”${CONSOLE_LOG_PATTERN:-%clr(%d{${LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd HH:mm:ss.SSS}}){faint} %clr(${LOG_LEVEL_PATTERN:-%5p}) %clr(${PID:- }){magenta} %clr(—){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}}”&#x2F;&gt;&lt;property name&#x3D;”CONSOLE_LOG_CHARSET” value&#x3D;”${CONSOLE_LOG_CHARSET:-${file.encoding:-UTF-8}}”&#x2F;&gt;&lt;property name&#x3D;”FILE_LOG_PATTERN” value&#x3D;”${FILE_LOG_PATTERN:-%d{${LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd HH:mm:ss.SSS}} ${LOG_LEVEL_PATTERN:-%5p} ${PID:- } — [%t] %-40.40logger{39} : %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}}”&#x2F;&gt;&lt;property name&#x3D;”FILE_LOG_CHARSET” value&#x3D;”${FILE_LOG_CHARSET:-${file.encoding:-UTF-8}}”&#x2F;&gt;&lt;logger name&#x3D;”org.apache.catalina.startup.DigesterFactory” level&#x3D;”ERROR”&#x2F;&gt;&lt;logger name&#x3D;”org.apache.catalina.util.LifecycleBase” level&#x3D;”ERROR”&#x2F;&gt;&lt;logger name&#x3D;”org.apache.coyote.http11.Http11NioProtocol” level&#x3D;”WARN”&#x2F;&gt;&lt;logger name&#x3D;”org.apache.sshd.common.util.SecurityUtils” level&#x3D;”WARN”&#x2F;&gt;&lt;logger name&#x3D;”org.apache.tomcat.util.net.NioSelectorPool” level&#x3D;”WARN”&#x2F;&gt;&lt;logger name&#x3D;”org.eclipse.jetty.util.component.AbstractLifeCycle” level&#x3D;”ERROR”&#x2F;&gt;&lt;logger name&#x3D;”org.hibernate.validator.internal.util.Version” level&#x3D;”WARN”&#x2F;&gt;&lt;logger name&#x3D;”org.springframework.boot.actuate.endpoint.jmx” level&#x3D;”WARN”&#x2F;&gt;&lt;&#x2F;included&gt; 导入后，我们利用预设的日志格式创建一个控制台日志打印： &lt;?xml version&#x3D;”1.0” encoding&#x3D;”UTF-8”?&gt;&lt;configuration&gt;&lt;!– 导入其他配置文件，作为预设 –&gt;&lt;include resource&#x3D;”org&#x2F;springframework&#x2F;boot&#x2F;logging&#x2F;logback&#x2F;defaults.xml” &#x2F;&gt;&lt;!– Appender作为日志打印器配置，这里命名随意 –&gt;&lt;!– ch.qos.logback.core.ConsoleAppender是专用于控制台的Appender –&gt;&lt;appender name&#x3D;”CONSOLE” class&#x3D;”ch.qos.logback.core.ConsoleAppender”&gt;&lt;encoder&gt;&lt;pattern&gt;${CONSOLE_LOG_PATTERN}&lt;&#x2F;pattern&gt;&lt;charset&gt;${CONSOLE_LOG_CHARSET}&lt;&#x2F;charset&gt;&lt;&#x2F;encoder&gt;&lt;&#x2F;appender&gt;&lt;!– 指定日志输出级别，以及启用的Appender，这里就使用了我们上面的ConsoleAppender –&gt;&lt;root level&#x3D;”INFO”&gt;&lt;appender-ref ref&#x3D;”CONSOLE”&#x2F;&gt;&lt;&#x2F;root&gt;&lt;&#x2F;configuration&gt; 配置完成后，我们发现控制台已经可以正常打印日志信息了。 接着我们来看看如何开启文件打印，我们只需要配置一个对应的Appender即可： &lt;!– ch.qos.logback.core.rolling.RollingFileAppender用于文件日志记录，它支持滚动 –&gt;&lt;appender name&#x3D;”FILE” class&#x3D;”ch.qos.logback.core.rolling.RollingFileAppender”&gt;&lt;encoder&gt;&lt;pattern&gt;${FILE_LOG_PATTERN}&lt;&#x2F;pattern&gt;&lt;charset&gt;${FILE_LOG_CHARSET}&lt;&#x2F;charset&gt;&lt;&#x2F;encoder&gt;&lt;!– 自定义滚动策略，防止日志文件无限变大，也就是日志文件写到什么时候为止，重新创建一个新的日志文件开始写 –&gt;&lt;rollingPolicy class&#x3D;”ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy”&gt;&lt;!– 文件保存位置以及文件命名规则，这里用到了%d{yyyy-MM-dd}表示当前日期，%i表示这一天的第N个日志 –&gt;&lt;FileNamePattern&gt;log&#x2F;%d{yyyy-MM-dd}-spring-%i.log&lt;&#x2F;FileNamePattern&gt;&lt;!– 到期自动清理日志文件 –&gt;&lt;cleanHistoryOnStart&gt;true&lt;&#x2F;cleanHistoryOnStart&gt;&lt;!– 最大日志保留时间 –&gt;&lt;maxHistory&gt;7&lt;&#x2F;maxHistory&gt;&lt;!– 最大单个日志文件大小 –&gt;&lt;maxFileSize&gt;10MB&lt;&#x2F;maxFileSize&gt;&lt;&#x2F;rollingPolicy&gt;&lt;&#x2F;appender&gt;&lt;!– 指定日志输出级别，以及启用的Appender，这里就使用了我们上面的ConsoleAppender –&gt;&lt;root level&#x3D;”INFO”&gt;&lt;appender-ref ref&#x3D;”CONSOLE”&#x2F;&gt;&lt;appender-ref ref&#x3D;”FILE”&#x2F;&gt;&lt;&#x2F;root&gt; 配置完成后，我们可以看到日志文件也能自动生成了。 我们也可以魔改官方提供的日志格式，官方文档：https://logback.qos.ch/manual/layouts.html 这里需要提及的是MDC机制，Logback内置的日志字段还是比较少，如果我们需要打印有关业务的更多的内容，包括自定义的一些数据，需要借助logback MDC机制，MDC为“Mapped Diagnostic Context”（映射诊断上下文），即将一些运行时的上下文数据通过logback打印出来；此时我们需要借助org.sl4j.MDC类。 比如我们现在需要记录是哪个用户访问我们网站的日志，只要是此用户访问我们网站，都会在日志中携带该用户的ID，我们希望每条日志中都携带这样一段信息文本，而官方提供的字段无法实现此功能，这时就需要使用MDC机制： @Slf4j@Controllerpublic class MainController {@RequestMapping(“&#x2F;login”)public String login(){&#x2F;&#x2F;这里就用Session代替ID吧MDC.put(“reqId”, request.getSession().getId());log.info(“用户访问了一次登陆界面”);return “login”;} 通过这种方式，我们就可以向日志中传入自定义参数了，我们日志中添加这样一个占位符%X&#123;键值&#125;，名字保持一致： %clr([%X{reqId}]){faint} 这样当我们向MDC中添加信息后，只要是当前线程（本质是ThreadLocal实现）下输出的日志，都会自动替换占位符。 自定义Banner我们在之前发现，实际上Banner部分和日志部分是独立的，SpringBoot启动后，会先打印Banner部分，那么这个Banner部分是否可以自定义呢？答案是可以的。 我们可以直接来配置文件所在目录下创建一个名为banner.txt的文本文档，内容随便你： &#x2F;&#x2F; _ooOoo_ &#x2F;&#x2F;&#x2F;&#x2F; o8888888o &#x2F;&#x2F;&#x2F;&#x2F; 88” . “88 &#x2F;&#x2F;&#x2F;&#x2F; (| ^^ |) &#x2F;&#x2F;&#x2F;&#x2F; O\\ &#x3D; &#x2F;O &#x2F;&#x2F;&#x2F;&#x2F; __**&#x2F;---&#39;\\\\____ // // .&#39; \\\\\\| |// . &#x2F;&#x2F;&#x2F;&#x2F; &#x2F; \\||| : |||&#x2F;&#x2F; \\ &#x2F;&#x2F;&#x2F;&#x2F; &#x2F; ||||| -:- |||||- \\ &#x2F;&#x2F;&#x2F;&#x2F; | | \\\\ - &#x2F;&#x2F;&#x2F; | | &#x2F;&#x2F;&#x2F;&#x2F; | \\| ‘’\\—&#x2F;‘’ | | &#x2F;&#x2F;&#x2F;&#x2F; \\ .-\\* - __*&#x2F;-. &#x2F; &#x2F;&#x2F;&#x2F;&#x2F; ***. .&#39; /--.--\\ . . ___ &#x2F;&#x2F;&#x2F;&#x2F; .”” ‘&lt; .___\\\\_&lt;|&amp;gt;_/___.&#39; &gt;&#39;&quot;&quot;. // // | | : - \\.;\\ _ &#x2F;;.&#x2F; - : | | // // \\ \\-. \\* **\\ &#x2F;** *&#x2F; .- / / // // ========-.****-.___\\\\_____/___.-*___.-‘&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x2F;&#x2F;&#x2F;&#x2F; `&#x3D;—&#x3D;’ &#x2F;&#x2F;&#x2F;&#x2F; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ &#x2F;&#x2F;&#x2F;&#x2F; 佛祖保佑 永无BUG 永不修改 &#x2F;&#x2F; 可以使用在线生成网站进行生成自己的个性Banner：https://www.bootschool.net/ascii 我们甚至还可以使用颜色代码来为文本切换颜色： ${AnsiColor.BRIGHT_GREEN} &#x2F;&#x2F;绿色 也可以获取一些常用的变量信息： ${AnsiColor.YELLOW} 当前 Spring Boot 版本：${spring-boot.version} 玩的开心！ 多环境配置在日常开发中，我们项目会有多个环境。例如开发环境（develop）也就是我们研发过程中疯狂敲代码修BUG阶段，生产环境（production ）项目开发得差不多了，可以放在服务器上跑了。不同的环境下，可能我们的配置文件也存在不同，但是我们不可能切换环境的时候又去重新写一次配置文件，所以我们可以将多个环境的配置文件提前写好，进行自由切换。 由于SpringBoot只会读取application.properties或是application.yml文件，那么怎么才能实现自由切换呢？SpringBoot给我们提供了一种方式，我们可以通过配置文件指定： spring:profiles:active: dev 接着我们分别创建两个环境的配置文件，application-dev.yml和application-prod.yml分别表示开发环境和生产环境的配置文件，比如开发环境我们使用的服务器端口为8080，而生产环境下可能就需要设置为80或是443端口，那么这个时候就需要不同环境下的配置文件进行区分： server:port: 8080 server:port: 80 这样我们就可以灵活切换生产环境和开发环境下的配置文件了。 SpringBoot自带的Logback日志系统也是支持多环境配置的，比如我们想在开发环境下输出日志到控制台，而生产环境下只需要输出到文件即可，这时就需要进行环境配置： &lt;springProfile name&#x3D;”dev”&gt;&lt;root level&#x3D;”INFO”&gt;&lt;appender-ref ref&#x3D;”CONSOLE”&#x2F;&gt;&lt;appender-ref ref&#x3D;”FILE”&#x2F;&gt;&lt;&#x2F;root&gt;&lt;&#x2F;springProfile&gt;&lt;springProfile name&#x3D;”prod”&gt;&lt;root level&#x3D;”INFO”&gt;&lt;appender-ref ref&#x3D;”FILE”&#x2F;&gt;&lt;&#x2F;root&gt;&lt;&#x2F;springProfile&gt; 注意springProfile是区分大小写的！ 那如果我们希望生产环境中不要打包开发环境下的配置文件呢，我们目前虽然可以切换开发环境，但是打包的时候依然是所有配置文件全部打包，这样总感觉还欠缺一点完美，因此，打包的问题就只能找Maven解决了，Maven也可以设置多环境： &lt;!–分别设置开发，生产环境–&gt;&lt;profiles&gt;&lt;!– 开发环境 –&gt;&lt;profile&gt;&lt;id&gt;dev&lt;&#x2F;id&gt;&lt;activation&gt;&lt;activeByDefault&gt;true&lt;&#x2F;activeByDefault&gt;&lt;&#x2F;activation&gt;&lt;properties&gt;&lt;environment&gt;dev&lt;&#x2F;environment&gt;&lt;&#x2F;properties&gt;&lt;&#x2F;profile&gt;&lt;!– 生产环境 –&gt;&lt;profile&gt;&lt;id&gt;prod&lt;&#x2F;id&gt;&lt;activation&gt;&lt;activeByDefault&gt;false&lt;&#x2F;activeByDefault&gt;&lt;&#x2F;activation&gt;&lt;properties&gt;&lt;environment&gt;prod&lt;&#x2F;environment&gt;&lt;&#x2F;properties&gt;&lt;&#x2F;profile&gt;&lt;&#x2F;profiles&gt; 接着，我们需要根据环境的不同，排除其他环境的配置文件： &lt;resources&gt;&lt;!–排除配置文件–&gt;&lt;resource&gt;&lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;&lt;!–先排除所有的配置文件–&gt;&lt;excludes&gt;&lt;!–使用通配符，当然可以定义多个exclude标签进行排除–&gt;&lt;exclude&gt;application*.yml&lt;&#x2F;exclude&gt;&lt;&#x2F;excludes&gt;&lt;&#x2F;resource&gt;&lt;!–根据激活条件引入打包所需的配置和文件–&gt;&lt;resource&gt;&lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;&lt;!–引入所需环境的配置文件–&gt;&lt;filtering&gt;true&lt;&#x2F;filtering&gt;&lt;includes&gt;&lt;include&gt;application.yml&lt;&#x2F;include&gt;&lt;!–根据maven选择环境导入配置文件–&gt;&lt;include&gt;application-${environment}.yml&lt;&#x2F;include&gt;&lt;&#x2F;includes&gt;&lt;&#x2F;resource&gt;&lt;&#x2F;resources&gt; 接着，我们可以直接将Maven中的environment属性，传递给SpringBoot的配置文件，在构建时替换为对应的值： spring:profiles:active: ‘@environment@’ #注意YAML配置文件需要加单引号，否则会报错 这样，根据我们Maven环境的切换，SpringBoot的配置文件也会进行对应的切换。 最后我们打开Maven栏目，就可以自由切换了，直接勾选即可，注意切换环境之后要重新加载一下Maven项目，不然不会生效！ 打包运行现在我们的SpringBoot项目编写完成了，那么如何打包运行呢？非常简单，只需要点击Maven生命周期中的package即可，它会自动将其打包为可直接运行的Jar包，第一次打包可能会花费一些时间下载部分依赖的源码一起打包进Jar文件。 我们发现在打包的过程中还会完整的将项目跑一遍进行测试，如果我们不想测试直接打包，可以手动使用以下命令： mvn package -DskipTests 打包后，我们会直接得到一个名为springboot-study-0.0.1-SNAPSHOT.jar的文件，这时在CMD窗口中输入命令： java -jar springboot-study-0.0.1-SNAPSHOT.jar 输入后，可以看到我们的Java项目成功运行起来了，如果手动关闭窗口会导致整个项目终止运行。 再谈Spring框架**注意：**开始本部分前，建议先完成SSM阶段的Spring源码讲解部分。 我们在SpringBoot阶段，需要继续扩充Spring框架的相关知识，来巩固和强化对于Spring框架的认识。 任务调度为了执行某些任务，我们可能需要一些非常规的操作，比如我们希望使用多线程来处理我们的结果或是执行一些定时任务，到达指定时间再去执行。 这时我们首先想到的就是创建一个新的线程来处理，或是使用TimerTask来完成定时任务，但是我们有了Spring框架之后，就不用这样了，因为Spring框架为我们提供了更加便捷的方式进行任务调度。 异步任务需要使用Spring异步任务支持，我们需要在配置类上添加@EnableAsync或是在SpringBoot的启动类上添加也可以。 @EnableAsync@SpringBootApplicationpublic class SpringBootWebTestApplication {public static void main(String[] args) {SpringApplication.run(SpringBootWebTestApplication.class, args);}} 接着我们只需要在需要异步执行的方法上，添加@Async注解即可将此方法标记为异步，当此方法被调用时，会异步执行，也就是新开一个线程执行，不是在当前线程执行。 @Servicepublic class TestService {@Asyncpublic void test(){try {Thread.sleep(3000);System.out.println(“我是异步任务！”);} catch (InterruptedException e) {e.printStackTrace();}}} @RequestMapping(“&#x2F;login”)public String login(HttpServletRequest request){service.test();System.out.println(“我是同步任务！”);return “login”;} 实际上这也是得益于AOP机制，通过线程池实现，但是也要注意，正是因为它是AOP机制的产物，所以它只能是在Bean中才会生效！ 使用 @Async 注释的方法可以返回 ‘void’ 或 “Future” 类型，Future是一种用于接收任务执行结果的一种类型，我们会在Java并发编程中进行讲解，这里暂时不做介绍。 定时任务看完了异步任务，我们接着来看定时任务，定时任务其实就是指定在哪个时候再去执行，在JavaSE阶段我们使用过TimerTask来执行定时任务。 Spring中的定时任务是全局性质的，当我们的Spring程序启动后，那么定时任务也就跟着启动了，我们可以在配置类上添加@EnableScheduling或是在SpringBoot的启动类上添加也可： @EnableAsync@EnableScheduling@SpringBootApplicationpublic class SpringBootWebTestApplication {public static void main(String[] args) {SpringApplication.run(SpringBootWebTestApplication.class, args);}} 接着我们可以创建一个定时任务配置类，在配置类里面编写定时任务： @Configurationpublic class ScheduleConfiguration {@Scheduled(fixedRate &#x3D; 2000)public void task(){System.out.println(“我是定时任务！”+new Date());}} 我们注意到@Scheduled中有很多参数，我们需要指定’cron’, ‘fixedDelay(String)’, or ‘fixedRate(String)’的其中一个，否则无法创建定时任务，他们的区别如下： fixedDelay：在上一次定时任务执行完之后，间隔多久继续执行。 fixedRate：无论上一次定时任务有没有执行完成，两次任务之间的时间间隔。 cron：使用cron表达式来指定任务计划。 这里重点讲解一下cron表达式：https://blog.csdn.net/sunnyzyq/article/details/98597252 监听器监听器对我们来说也是一个比较陌生的概念，那么何谓监听呢？ 监听实际上就是等待某个事件的触发，当事件触发时，对应事件的监听器就会被通知。 @Componentpublic class TestListener implements ApplicationListener&lt;ContextRefreshedEvent&gt; {@Overridepublic void onApplicationEvent(ContextRefreshedEvent event) {System.out.println(event.getApplicationContext());}} 通过监听事件，我们就可以在对应的时机进行一些额外的处理，我们可以通过断点调试来查看一个事件是如何发生，以及如何通知监听器的。 通过阅读源码，我们得知，一个事件实际上就是通过publishEvent方法来进行发布的，我们也可以自定义我们自己项目中的事件，并注册对应的监听器进行处理。 public class TestEvent extends ApplicationEvent { &#x2F;&#x2F;需要继承ApplicationEventpublic TestEvent(Object source) {super(source);}} @Componentpublic class TestListener implements ApplicationListener&lt;TestEvent&gt; {@Overridepublic void onApplicationEvent(TestEvent event) {System.out.println(“自定义事件发生了：”+event.getSource());}} @ResourceApplicationContext context;@RequestMapping(“&#x2F;login”)public String login(HttpServletRequest request){context.publishEvent(new TestEvent(“有人访问了登录界面！”));return “login”;} 这样，我们就实现了自定义事件发布和监听。 Aware系列接口我们在之前讲解Spring源码时，经常会发现某些类的定义上，除了我们当时讲解的继承关系以外，还实现了一些接口，他们的名称基本都是xxxxAware，比如我们在讲解SpringSecurity的源码中，AbstractAuthenticationProcessingFilter类就是这样： public abstract class AbstractAuthenticationProcessingFilter extends GenericFilterBean implements ApplicationEventPublisherAware, MessageSourceAware {protected ApplicationEventPublisher eventPublisher;protected AuthenticationDetailsSource&lt;HttpServletRequest, ?&gt; authenticationDetailsSource &#x3D; new WebAuthenticationDetailsSource();private AuthenticationManager authenticationManager;… 我们发现它除了继承自GenericFilterBean之外，还实现了ApplicationEventPublisherAware和MessageSourceAware接口，那么这些Aware接口到底是干嘛的呢？ Aware的中文意思为感知。简单来说，他就是一个标识，实现此接口的类会获得某些感知能力，Spring容器会在Bean被加载时，根据类实现的感知接口，会调用类中实现的对应感知方法。 比如AbstractAuthenticationProcessingFilter就实现了ApplicationEventPublisherAware接口，此接口的感知功能为事件发布器，在Bean加载时，会调用实现类中的setApplicationEventPublisher方法，而AbstractAuthenticationProcessingFilter类则利用此方法，在Bean加载阶段获得了容器的事件发布器，以便之后发布事件使用。 public void setApplicationEventPublisher(ApplicationEventPublisher eventPublisher) {this.eventPublisher &#x3D; eventPublisher; &#x2F;&#x2F;直接存到成员变量} protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException {SecurityContext context &#x3D; SecurityContextHolder.createEmptyContext();context.setAuthentication(authResult);SecurityContextHolder.setContext(context);if (this.logger.isDebugEnabled()) {this.logger.debug(LogMessage.format(“Set SecurityContextHolder to %s”, authResult));}this.rememberMeServices.loginSuccess(request, response, authResult);&#x2F;&#x2F;在这里使用if (this.eventPublisher !&#x3D; null) {this.eventPublisher.publishEvent(new InteractiveAuthenticationSuccessEvent(authResult, this.getClass()));}this.successHandler.onAuthenticationSuccess(request, response, authResult);} 同样的，除了ApplicationEventPublisherAware接口外，我们再来演示一个接口，比如： @Servicepublic class TestService implements BeanNameAware {@Overridepublic void setBeanName(String s) {System.out.println(s);}} BeanNameAware就是感知Bean名称的一个接口，当Bean被加载时，会调用setBeanName方法并将Bean名称作为参数传递。 有关所有的Aware这里就不一一列举了。 探究SpringBoot实现原理**注意：**难度较大，本版块作为选学内容，在开始前，必须完成SSM阶段源码解析部分的学习。 我们在前面的学习中切实感受到了SpringBoot为我们带来的便捷，那么它为何能够实现如此快捷的开发模式，starter又是一个怎样的存在，它是如何进行自动配置的，我们现在就开始研究。 启动原理首先我们来看看，SpringBoot项目启动之后，做了什么事情，SpringApplication中的静态run方法： public static ConfigurableApplicationContext run(Class&lt;?&gt; primarySource, String… args) {return run(new Class[]{primarySource}, args);} 套娃如下： public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources, String[] args) {return (new SpringApplication(primarySources)).run(args);} 我们发现，这里直接new了一个新的SpringApplication对象，传入我们的主类作为构造方法参数，并调用了非static的run方法，我们先来看看构造方法里面做了什么事情： public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;… primarySources) {…this.resourceLoader &#x3D; resourceLoader;Assert.notNull(primarySources, “PrimarySources must not be null”);this.primarySources &#x3D; new LinkedHashSet(Arrays.asList(primarySources));&#x2F;&#x2F;这里是关键，这里会判断当前SpringBoot应用程序是否为Web项目，并返回当前的项目类型&#x2F;&#x2F;deduceFromClasspath是根据类路径下判断是否包含SpringBootWeb依赖，如果不包含就是NONE类型，包含就是SERVLET类型this.webApplicationType &#x3D; WebApplicationType.deduceFromClasspath();this.bootstrapRegistryInitializers &#x3D; new ArrayList(this.getSpringFactoriesInstances(BootstrapRegistryInitializer.class));&#x2F;&#x2F;创建所有ApplicationContextInitializer实现类的对象this.setInitializers(this.getSpringFactoriesInstances(ApplicationContextInitializer.class));this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));this.mainApplicationClass &#x3D; this.deduceMainApplicationClass();} 关键就在这里了，它是如何知道哪些类是ApplicationContextInitializer的实现类的呢？ 这里就要提到spring.factories了，它是 Spring 仿造Java SPI实现的一种类加载机制。它在 META-INF&#x2F;spring.factories 文件中配置接口的实现类名称，然后在程序中读取这些配置文件并实例化。这种自定义的SPI机制是 Spring Boot Starter 实现的基础。 SPI的常见例子： 数据库驱动加载接口实现类的加载：JDBC加载不同类型数据库的驱动 日志门面接口实现类加载：SLF4J加载不同提供商的日志实现类 说白了就是人家定义接口，但是实现可能有很多种，但是核心只提供接口，需要我们按需选择对应的实现，这种方式是高度解耦的。 我们来看看getSpringFactoriesInstances方法做了什么： private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object… args) {&#x2F;&#x2F;获取当前的类加载器ClassLoader classLoader &#x3D; this.getClassLoader();&#x2F;&#x2F;获取所有依赖中 META-INF&#x2F;spring.factories 中配置的对应接口类的实现类列表Set&lt;String&gt; names &#x3D; new LinkedHashSet(SpringFactoriesLoader.loadFactoryNames(type, classLoader));&#x2F;&#x2F;根据上方列表，依次创建实例对象List&lt;T&gt; instances &#x3D; this.createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);&#x2F;&#x2F;根据对应类上的Order接口或是注解进行排序AnnotationAwareOrderComparator.sort(instances);&#x2F;&#x2F;返回实例return instances;} 其中SpringFactoriesLoader.loadFactoryNames正是读取配置的核心部分，我们后面还会遇到。 接着我们来看run方法里面做了什么事情。 public ConfigurableApplicationContext run(String… args) {long startTime &#x3D; System.nanoTime();DefaultBootstrapContext bootstrapContext &#x3D; this.createBootstrapContext();ConfigurableApplicationContext context &#x3D; null;this.configureHeadlessProperty();&#x2F;&#x2F;获取所有的SpringApplicationRunListener，并通知启动事件，默认只有一个实现类EventPublishingRunListener&#x2F;&#x2F;EventPublishingRunListener会将初始化各个阶段的事件转发给所有监听器SpringApplicationRunListeners listeners &#x3D; this.getRunListeners(args);listeners.starting(bootstrapContext, this.mainApplicationClass);try {&#x2F;&#x2F;环境配置ApplicationArguments applicationArguments &#x3D; new DefaultApplicationArguments(args);ConfigurableEnvironment environment &#x3D; this.prepareEnvironment(listeners, bootstrapContext, applicationArguments);this.configureIgnoreBeanInfo(environment);&#x2F;&#x2F;打印BannerBanner printedBanner &#x3D; this.printBanner(environment);&#x2F;&#x2F;创建ApplicationContext，注意这里会根据是否为Web容器使用不同的ApplicationContext实现类context &#x3D; this.createApplicationContext();context.setApplicationStartup(this.applicationStartup);&#x2F;&#x2F;初始化ApplicationContextthis.prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);&#x2F;&#x2F;执行ApplicationContext的refresh方法this.refreshContext(context);this.afterRefresh(context, applicationArguments);Duration timeTakenToStartup &#x3D; Duration.ofNanos(System.nanoTime() - startTime);if (this.logStartupInfo) {(new StartupInfoLogger(this.mainApplicationClass)).logStarted(this.getApplicationLog(), timeTakenToStartup);}….} 我们发现，实际上SpringBoot就是Spring的一层壳罢了，离不开最关键的ApplicationContext，也就是说，在启动后会自动配置一个ApplicationContext，只不过是进行了大量的扩展。 我们来看ApplicationContext是怎么来的，打开createApplicationContext方法： protected ConfigurableApplicationContext createApplicationContext() {return this.applicationContextFactory.create(this.webApplicationType);} 我们发现在构造方法中applicationContextFactory直接使用的是DEFAULT： this.applicationContextFactory &#x3D; ApplicationContextFactory.DEFAULT; ApplicationContextFactory DEFAULT &#x3D; (webApplicationType) -&gt; {try {switch(webApplicationType) {case SERVLET:return new AnnotationConfigServletWebServerApplicationContext();case REACTIVE:return new AnnotationConfigReactiveWebServerApplicationContext();default:return new AnnotationConfigApplicationContext();}} catch (Exception var2) {throw new IllegalStateException(“Unable create a default ApplicationContext instance, you may need a custom ApplicationContextFactory”, var2);}};ConfigurableApplicationContext create(WebApplicationType webApplicationType); DEFAULT是直接编写的一个匿名内部类，其实已经很明确了，正是根据webApplicationType类型进行判断，如果是SERVLET，那么久返回专用于Web环境的AnnotationConfigServletWebServerApplicationContext对象（SpringBoot中新增的），否则返回普通的AnnotationConfigApplicationContext对象，也就是到这里为止，Spring的容器就基本已经确定了。 注意AnnotationConfigApplicationContext是Spring框架提供的类，从这里开始相当于我们在讲Spring的底层源码了，我们继续深入，AnnotationConfigApplicationContext对象在创建过程中会创建AnnotatedBeanDefinitionReader，它是用于通过注解解析Bean定义的工具类： public AnnotationConfigApplicationContext() {StartupStep createAnnotatedBeanDefReader &#x3D; this.getApplicationStartup().start(“spring.context.annotated-bean-reader.create”);this.reader &#x3D; new AnnotatedBeanDefinitionReader(this);createAnnotatedBeanDefReader.end();this.scanner &#x3D; new ClassPathBeanDefinitionScanner(this);} 其构造方法： public AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry, Environment environment) {…&#x2F;&#x2F;这里会注册很多的后置处理器AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);} public static Set&lt;BeanDefinitionHolder&gt; registerAnnotationConfigProcessors(BeanDefinitionRegistry registry, @Nullable Object source) {DefaultListableBeanFactory beanFactory &#x3D; unwrapDefaultListableBeanFactory(registry);….Set&lt;BeanDefinitionHolder&gt; beanDefs &#x3D; new LinkedHashSet(8);RootBeanDefinition def;if (!registry.containsBeanDefinition(“org.springframework.context.annotation.internalConfigurationAnnotationProcessor”)) {&#x2F;&#x2F;注册了ConfigurationClassPostProcessor用于处理@Configuration、@Import等注解&#x2F;&#x2F;注意这里是关键，之后Selector还要讲到它&#x2F;&#x2F;它是继承自BeanDefinitionRegistryPostProcessor，所以它的执行时间在Bean定义加载完成后，Bean初始化之前def &#x3D; new RootBeanDefinition(ConfigurationClassPostProcessor.class);def.setSource(source);beanDefs.add(registerPostProcessor(registry, def, “org.springframework.context.annotation.internalConfigurationAnnotationProcessor”));}if (!registry.containsBeanDefinition(“org.springframework.context.annotation.internalAutowiredAnnotationProcessor”)) {&#x2F;&#x2F;AutowiredAnnotationBeanPostProcessor用于处理@Value等注解自动注入def &#x3D; new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);def.setSource(source);beanDefs.add(registerPostProcessor(registry, def, “org.springframework.context.annotation.internalAutowiredAnnotationProcessor”));} ... 回到SpringBoot，我们最后来看，prepareContext方法中又做了什么事情： private void prepareContext(DefaultBootstrapContext bootstrapContext, ConfigurableApplicationContext context, ConfigurableEnvironment environment, SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner) {&#x2F;&#x2F;环境配置context.setEnvironment(environment);this.postProcessApplicationContext(context);this.applyInitializers(context);listeners.contextPrepared(context);bootstrapContext.close(context);if (this.logStartupInfo) {this.logStartupInfo(context.getParent() &#x3D;&#x3D; null);this.logStartupProfileInfo(context);}&#x2F;&#x2F;将Banner注册为BeanConfigurableListableBeanFactory beanFactory &#x3D; context.getBeanFactory();beanFactory.registerSingleton(“springApplicationArguments”, applicationArguments);if (printedBanner !&#x3D; null) {beanFactory.registerSingleton(“springBootBanner”, printedBanner);}if (beanFactory instanceof AbstractAutowireCapableBeanFactory) {((AbstractAutowireCapableBeanFactory)beanFactory).setAllowCircularReferences(this.allowCircularReferences);if (beanFactory instanceof DefaultListableBeanFactory) {((DefaultListableBeanFactory)beanFactory).setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);}}if (this.lazyInitialization) {context.addBeanFactoryPostProcessor(new LazyInitializationBeanFactoryPostProcessor());}&#x2F;&#x2F;这里会获取我们一开始传入的项目主类Set&lt;Object&gt; sources &#x3D; this.getAllSources();Assert.notEmpty(sources, “Sources must not be empty”);&#x2F;&#x2F;这里会将我们的主类直接注册为Bean，这样就可以通过注解加载了this.load(context, sources.toArray(new Object[0]));listeners.contextLoaded(context);} 因此，在prepareContext执行完成之后，我们的主类成功完成Bean注册，接下来，就该类上注解大显身手了。 自动配置原理既然主类已经在初始阶段注册为Bean，那么在加载时，就会根据注解定义，进行更多的额外操作。所以我们来看看主类上的@SpringBootApplication注解做了什么事情。 @Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters &#x3D; {@Filter(type &#x3D; FilterType.CUSTOM,classes &#x3D; {TypeExcludeFilter.class}), @Filter(type &#x3D; FilterType.CUSTOM,classes &#x3D; {AutoConfigurationExcludeFilter.class})})public @interface SpringBootApplication { 我们发现，@SpringBootApplication上添加了@ComponentScan注解，此注解我们此前已经认识过了，但是这里并没有配置具体扫描的包，因此它会自动将声明此接口的类所在的包作为basePackage，因此当添加@SpringBootApplication之后也就等于直接开启了自动扫描，但是一定注意不能在主类之外的包进行Bean定义，否则无法扫描到，需要手动配置。 接着我们来看第二个注解@EnableAutoConfiguration，它就是自动配置的核心了，我们来看看它是如何定义的： @Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import({AutoConfigurationImportSelector.class})public @interface EnableAutoConfiguration { 老套路了，直接一手@Import，通过这种方式来将一些外部的Bean加载到容器中。我们来看看AutoConfigurationImportSelector做了什么事情： public class AutoConfigurationImportSelector implements DeferredImportSelector, BeanClassLoaderAware, ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered {…} 我们看到它实现了很多接口，包括大量的Aware接口，实际上就是为了感知某些必要的对象，并将其存到当前类中。 其中最核心的是DeferredImportSelector接口，它是ImportSelector的子类，它定义了selectImports方法，用于返回需要加载的类名称，在Spring加载ImportSelector类型的Bean时，会调用此方法来获取更多需要加载的类，并将这些类一并注册为Bean： public interface ImportSelector {String[] selectImports(AnnotationMetadata importingClassMetadata);@Nullabledefault Predicate&lt;String&gt; getExclusionFilter() {return null;}} 到目前为止，我们了解了两种使用@Import有特殊机制的接口：ImportSelector（这里用到的）和ImportBeanDefinitionRegistrar（之前Mybatis-spring源码有讲）当然还有普通的@Configuration配置类。 我们可以来阅读一下ConfigurationClassPostProcessor的源码，看看它到底是如何处理@Import的： public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {List&lt;BeanDefinitionHolder&gt; configCandidates &#x3D; new ArrayList();&#x2F;&#x2F;注意这个阶段仅仅是已经完成扫描了所有的Bean，得到了所有的BeanDefinition，但是还没有进行任何区分&#x2F;&#x2F;candidate是候选者的意思，一会会将标记了@Configuration的类作为ConfigurationClass加入到configCandidates中String[] candidateNames &#x3D; registry.getBeanDefinitionNames();String[] var4 &#x3D; candidateNames;int var5 &#x3D; candidateNames.length;for(int var6 &#x3D; 0; var6 &lt; var5; ++var6) {String beanName &#x3D; var4[var6];BeanDefinition beanDef &#x3D; registry.getBeanDefinition(beanName);if (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) !&#x3D; null) {if (this.logger.isDebugEnabled()) {this.logger.debug(“Bean definition has already been processed as a configuration class: “ + beanDef);}} else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) { &#x2F;&#x2F;判断是否添加了@Configuration注解configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));}}if (!configCandidates.isEmpty()) {&#x2F;&#x2F;…省略&#x2F;&#x2F;这里创建了一个ConfigurationClassParser用于解析配置类ConfigurationClassParser parser &#x3D; new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);&#x2F;&#x2F;所有配置类的BeanDefinitionHolder列表Set&lt;BeanDefinitionHolder&gt; candidates &#x3D; new LinkedHashSet(configCandidates);&#x2F;&#x2F;已经解析完成的类HashSet alreadyParsed &#x3D; new HashSet(configCandidates.size());do {&#x2F;&#x2F;这里省略，直到所有的配置类全部解析完成&#x2F;&#x2F;注意在循环过程中可能会由于@Import新增更多的待解析配置类，一律丢进candidates集合中} while(!candidates.isEmpty());…}} 我们接着来看，ConfigurationClassParser是如何进行解析的： protected void processConfigurationClass(ConfigurationClass configClass, Predicate&lt;String&gt; filter) throws IOException {&#x2F;&#x2F;@Conditional相关注解处理&#x2F;&#x2F;后面会讲if (!this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {…}ConfigurationClassParser.SourceClass sourceClass &#x3D; this.asSourceClass(configClass, filter);do {&#x2F;&#x2F;核心sourceClass &#x3D; this.doProcessConfigurationClass(configClass, sourceClass, filter);} while(sourceClass !&#x3D; null);this.configurationClasses.put(configClass, configClass);}} 最后我们再来看最核心的doProcessConfigurationClass方法： protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)…processImports(configClass, sourceClass, getImports(sourceClass), true); &#x2F;&#x2F; 处理Import注解…return null;} private void processImports(ConfigurationClass configClass, ConfigurationClassParser.SourceClass currentSourceClass, Collection&lt;ConfigurationClassParser.SourceClass&gt; importCandidates, Predicate&lt;String&gt; exclusionFilter, boolean checkForCircularImports) {if (!importCandidates.isEmpty()) {if (checkForCircularImports &amp;&amp; this.isChainedImportOnStack(configClass)) {this.problemReporter.error(new ConfigurationClassParser.CircularImportProblem(configClass, this.importStack));} else {this.importStack.push(configClass);try {Iterator var6 &#x3D; importCandidates.iterator();while(var6.hasNext()) {ConfigurationClassParser.SourceClass candidate &#x3D; (ConfigurationClassParser.SourceClass)var6.next();Class candidateClass;&#x2F;&#x2F;如果是ImportSelector类型，继续进行运行if (candidate.isAssignable(ImportSelector.class)) {candidateClass &#x3D; candidate.loadClass();ImportSelector selector &#x3D; (ImportSelector)ParserStrategyUtils.instantiateClass(candidateClass, ImportSelector.class, this.environment, this.resourceLoader, this.registry);Predicate&lt;String&gt; selectorFilter &#x3D; selector.getExclusionFilter();if (selectorFilter !&#x3D; null) {exclusionFilter &#x3D; exclusionFilter.or(selectorFilter);}&#x2F;&#x2F;如果是DeferredImportSelector的实现类，那么会走deferredImportSelectorHandler的handle方法if (selector instanceof DeferredImportSelector) {this.deferredImportSelectorHandler.handle(configClass, (DeferredImportSelector)selector);&#x2F;&#x2F;否则就按照正常的ImportSelector类型进行加载} else {&#x2F;&#x2F;调用selectImports方法获取所有需要加载的类String[] importClassNames &#x3D; selector.selectImports(currentSourceClass.getMetadata());Collection&lt;ConfigurationClassParser.SourceClass&gt; importSourceClasses &#x3D; this.asSourceClasses(importClassNames, exclusionFilter);&#x2F;&#x2F;递归处理，直到没有this.processImports(configClass, currentSourceClass, importSourceClasses, exclusionFilter, false);}&#x2F;&#x2F;判断是否为ImportBeanDefinitionRegistrar类型} else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) {candidateClass &#x3D; candidate.loadClass();ImportBeanDefinitionRegistrar registrar &#x3D; (ImportBeanDefinitionRegistrar)ParserStrategyUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class, this.environment, this.resourceLoader, this.registry);&#x2F;&#x2F;往configClass丢ImportBeanDefinitionRegistrar信息进去，之后再处理configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());&#x2F;&#x2F;否则按普通的配置类进行处理} else {this.importStack.registerImport(currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());this.processConfigurationClass(candidate.asConfigClass(configClass), exclusionFilter);}}} catch (BeanDefinitionStoreException var17) {throw var17;} catch (Throwable var18) {throw new BeanDefinitionStoreException(“Failed to process import candidates for configuration class [“ + configClass.getMetadata().getClassName() + “]”, var18);} finally {this.importStack.pop();}}}} 不难注意到，虽然这里额外处理了ImportSelector对象，但是还针对ImportSelector的子接口DeferredImportSelector进行了额外处理，Deferred是延迟的意思，它是一个延迟执行的ImportSelector，并不会立即进处理，而是丢进DeferredImportSelectorHandler，并且在parse方法的最后进行处理： public void parse(Set&lt;BeanDefinitionHolder&gt; configCandidates) {…this.deferredImportSelectorHandler.process();} 我们接着来看DeferredImportSelector正好就有一个process方法： public interface DeferredImportSelector extends ImportSelector {@Nullabledefault Class&lt;? extends DeferredImportSelector.Group&gt; getImportGroup() {return null;}public interface Group {void process(AnnotationMetadata metadata, DeferredImportSelector selector);Iterable&lt;DeferredImportSelector.Group.Entry&gt; selectImports();public static class Entry {… 最后经过ConfigurationClassParser处理完成后，通过parser.getConfigurationClasses()就能得到通过配置类导入了哪些额外的配置类。最后将这些配置类全部注册BeanDefinition，然后就可以交给接下来的Bean初始化过程去处理了。 this.reader.loadBeanDefinitions(configClasses); 最后我们再去看loadBeanDefinitions是如何运行的： public void loadBeanDefinitions(Set&lt;ConfigurationClass&gt; configurationModel) {ConfigurationClassBeanDefinitionReader.TrackedConditionEvaluator trackedConditionEvaluator &#x3D; new ConfigurationClassBeanDefinitionReader.TrackedConditionEvaluator();Iterator var3 &#x3D; configurationModel.iterator();while(var3.hasNext()) {ConfigurationClass configClass &#x3D; (ConfigurationClass)var3.next();this.loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator);}}private void loadBeanDefinitionsForConfigurationClass(ConfigurationClass configClass, ConfigurationClassBeanDefinitionReader.TrackedConditionEvaluator trackedConditionEvaluator) {if (trackedConditionEvaluator.shouldSkip(configClass)) {String beanName &#x3D; configClass.getBeanName();if (StringUtils.hasLength(beanName) &amp;&amp; this.registry.containsBeanDefinition(beanName)) {this.registry.removeBeanDefinition(beanName);}this.importRegistry.removeImportingClass(configClass.getMetadata().getClassName());} else {if (configClass.isImported()) {this.registerBeanDefinitionForImportedConfigurationClass(configClass); &#x2F;&#x2F;注册配置类自己}Iterator var3 &#x3D; configClass.getBeanMethods().iterator();while(var3.hasNext()) {BeanMethod beanMethod &#x3D; (BeanMethod)var3.next();this.loadBeanDefinitionsForBeanMethod(beanMethod); &#x2F;&#x2F;注册@Bean注解标识的方法}&#x2F;&#x2F;注册@ImportResource引入的XML配置文件中读取的bean定义this.loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());&#x2F;&#x2F;注册configClass中经过解析后保存的所有ImportBeanDefinitionRegistrar，注册对应的BeanDefinitionthis.loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());}} 这样，整个@Configuration配置类的底层配置流程我们就大致了解了。接着我们来看AutoConfigurationImportSelector是如何实现自动配置的，可以看到内部类AutoConfigurationGroup的process方法，它是父接口的实现，因为父接口是DeferredImportSelector，那么很容易得知，实际上最后会调用process方法获取所有的自动配置类： public void process(AnnotationMetadata annotationMetadata, DeferredImportSelector deferredImportSelector) {Assert.state(deferredImportSelector instanceof AutoConfigurationImportSelector, () -&gt; {return String.format(“Only %s implementations are supported, got %s”, AutoConfigurationImportSelector.class.getSimpleName(), deferredImportSelector.getClass().getName());});&#x2F;&#x2F;获取所有的Entry，其实就是，读取spring.factories来查看有哪些自动配置类AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry &#x3D; ((AutoConfigurationImportSelector)deferredImportSelector).getAutoConfigurationEntry(annotationMetadata);this.autoConfigurationEntries.add(autoConfigurationEntry);Iterator var4 &#x3D; autoConfigurationEntry.getConfigurations().iterator();while(var4.hasNext()) {String importClassName &#x3D; (String)var4.next();this.entries.putIfAbsent(importClassName, annotationMetadata);}} 我们接着来看getAutoConfigurationEntry方法： protected AutoConfigurationImportSelector.AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) {&#x2F;&#x2F;判断是否开启了自动配置，是的，自动配置可以关if (!this.isEnabled(annotationMetadata)) {return EMPTY_ENTRY;} else {&#x2F;&#x2F;根据注解定义获取一些属性AnnotationAttributes attributes &#x3D; this.getAttributes(annotationMetadata);&#x2F;&#x2F;得到spring.factories文件中所有需要自动配置的类List&lt;String&gt; configurations &#x3D; this.getCandidateConfigurations(annotationMetadata, attributes);… 这里先看前半部分}} 注意这里并不是spring.factories文件中所有的自动配置类都会被加载，它会根据@Condition注解的条件进行加载。这样就能实现我们需要什么模块添加对应依赖就可以实现自动配置了。 所有的源码看不懂，都源自于你的心中没有形成一个完整的闭环！一旦一条线推到头，闭环形成，所有疑惑迎刃而解。 自定义Starter我们仿照Mybatis来编写一个自己的starter，Mybatis的starter包含两个部分： &lt;project xmlns&#x3D;”http://maven.apache.org/POM/4.0.0“ xmlns:xsi&#x3D;”http://www.w3.org/2001/XMLSchema-instance“ xsi:schemaLocation&#x3D;”http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;&lt;parent&gt;&lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;&lt;artifactId&gt;mybatis-spring-boot&lt;&#x2F;artifactId&gt;&lt;version&gt;2.2.0&lt;&#x2F;version&gt;&lt;&#x2F;parent&gt;&lt;!– starter本身只做依赖集中管理，不编写任何代码 –&gt;&lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;&lt;name&gt;mybatis-spring-boot-starter&lt;&#x2F;name&gt;&lt;properties&gt;&lt;module.name&gt;org.mybatis.spring.boot.starter&lt;&#x2F;module.name&gt;&lt;&#x2F;properties&gt;&lt;dependencies&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-boot-starter&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-boot-starter-jdbc&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;!– 编写的专用配置模块 –&gt;&lt;dependency&gt;&lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;&lt;artifactId&gt;mybatis-spring-boot-autoconfigure&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;&lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;&lt;artifactId&gt;mybatis-spring&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;&lt;&#x2F;project&gt; 因此我们也将我们自己的starter这样设计： 我们设计三个模块： spring-boot-hello：基础业务功能模块 spring-boot-starter-hello：启动器 spring-boot-autoconifgurer-hello：自动配置依赖 首先是基础业务功能模块，这里我们随便创建一个类就可以了： public class HelloWorldService { } 启动器主要做依赖管理，这里就不写任何代码，只写pom文件： &lt;dependencies&gt;&lt;dependency&gt;&lt;groupId&gt;org.example&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-boot-autoconfigurer-hello&lt;&#x2F;artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt; 导入autoconfigurer模块作为依赖即可，接着我们去编写autoconfigurer模块，首先导入依赖： &lt;dependencies&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-boot-autoconfigure&lt;&#x2F;artifactId&gt;&lt;version&gt;2.6.2&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-boot-configuration-processor&lt;&#x2F;artifactId&gt;&lt;version&gt;2.6.2&lt;&#x2F;version&gt;&lt;optional&gt;true&lt;&#x2F;optional&gt;&lt;&#x2F;dependency&gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.example&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-hello&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &lt;&#x2F;dependencies&gt; 接着创建一个HelloWorldAutoConfiguration作为自动配置类： @Configuration(proxyBeanMethods &#x3D; false)@ConditionalOnWebApplication@ConditionalOnClass(HelloWorldService.class)@EnableConfigurationProperties(HelloWorldProperties.class)public class HelloWorldAutoConfiguration {Logger logger &#x3D; Logger.getLogger(this.getClass().getName());@ResourceHelloWorldProperties properties;@Beanpublic HelloWorldService helloWorldService(){logger.info(“自定义starter项目已启动！”);logger.info(“读取到自定义配置：”+properties.getValue());return new HelloWorldService();}} 对应的配置读取类： @ConfigurationProperties(“hello.world”)public class HelloWorldProperties {private String value;public void setValue(String value) {this.value &#x3D; value;}public String getValue() {return value;}} 最后再编写spring.factories文件，并将我们的自动配置类添加即可： org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;com.hello.autoconfigurer.HelloWorldAutoConfiguration 最后再Maven根项目执行install安装到本地仓库，完成。接着就可以在其他项目中使用我们编写的自定义starter了。 Runner接口在项目中，可能会遇到这样一个问题：我们需要在项目启动完成之后，紧接着执行一段代码。 我们可以编写自定义的ApplicationRunner来解决，它会在项目启动完成后执行： @Componentpublic class TestRunner implements ApplicationRunner {@Overridepublic void run(ApplicationArguments args) throws Exception {System.out.println(“我是自定义执行！”);}} 当然也可以使用CommandLineRunner，它也支持使用@Order或是实现Ordered接口来支持优先级执行。 实际上它就是run方法的最后： public ConfigurableApplicationContext run(String… args) {….listeners.started(context, timeTakenToStartup);&#x2F;&#x2F;这里已经完成整个SpringBoot项目启动，所以执行所有的Runnerthis.callRunners(context, applicationArguments);} catch (Throwable var12) {this.handleRunFailure(context, var12, listeners);throw new IllegalStateException(var12);}try {Duration timeTakenToReady &#x3D; Duration.ofNanos(System.nanoTime() - startTime);listeners.ready(context, timeTakenToReady);return context;} catch (Throwable var11) {this.handleRunFailure(context, var11, (SpringApplicationRunListeners)null);throw new IllegalStateException(var11);}} 下一章，我们将继续讲解几乎程序员必会的Git版本控制。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"Springboot笔记","slug":"Java/Springboot笔记","permalink":"http://example.com/categories/Java/Springboot%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"SQL事务（非常详细）","slug":"74716fee04044e3cb78e867d1d06d583","date":"2023-01-24T07:34:28.674Z","updated":"2023-01-24T07:34:52.122Z","comments":true,"path":"2023/01/24/74716fee04044e3cb78e867d1d06d583/","link":"","permalink":"http://example.com/2023/01/24/74716fee04044e3cb78e867d1d06d583/","excerpt":"","text":"在数据库中，我们将一条 SQL 语句称为一次基本的操作。将若干条 SQL 语句“打包”在一起，共同执行一个完整的任务，这就是事务。事务（ Transaction）由一次或者多次基本操作构成，或者说，事务由一条或者多条 SQL 语句构成。事务有一个最显著的特征，就是它包含的所有 SQL 语句作为一个整体向数据库提交，只有所有的 SQL 语句都执行完成，整个事务才算成功，一旦某个 SQL 语句执行失败，整个事务就失败了。事务失败后需要回滚所有的 SQL 语句。事务中的所有 SQL 语句是一个整体，共同进退，不可分割，要么全部执行成功，要么全部执行失败。事务有很多实用的场景。例如对于电商网站，通常将用户订单存储在一张表中，将商品库存情况存储在另一张表中，当有用户下单时，需要执行两条 SQL 语句，一条负责更新订单表，一条负责更新库存表，这两条 SQL 语句必须同时执行成功。如果只有一条语句执行成功，另一条语句执行失败，将导致数据库出错，这种后果是无法接受的。为了避免出现意外，可以将以上两条语句放到一个事务中，其中一条语句执行失败时，数据库将回滚到原来的状态。对于买家来说，数据库回滚会导致下单失败，但这很容易处理，让买家再次下单即可。数据库的正确性永远是最重要的。其实我们平时使用数据库时，就已经在使用事务了，只不过这种事务只包含一条 SQL 语句，并且由数据库引擎自动封装和提交。这意味着，对于任何一条 SQL 语句，要么执行成功，要么执行失败，不能成功一部分，失败一部分。 事务的属性一般来说，事务具有四个标准属性，分别是原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability），简称 ACID。具体说明如下： 1) 原子性一个事务中的所有 SQL 语句，要么全部执行成功，要么全部执行失败，不会结束在中间的某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 2) 一致性在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的数据必须完全符合所有的预设规则，其中包含数据的精确度、串联性以及后续数据库可以自发性地完成预定的工作。 3) 隔离性数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。 4) 持久性事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 事务执行流程各种数据库对事务的支持细节不尽相同，本教程以 MySQL 数据库为例进行讲解，MySQL 使用标准 SQL 来支持事务。与事务控制有关的 SQL 命令包括： BEGIN 或者 START TRANSACTION：开始事务； COMMIT：提交事务； ROLLBACK：回滚事务； SAVEPOINT：在事务内部设置回滚标记点； RELEASE SAVEPOINT：删除回滚标记点； ROLLBACK TO：将事务回滚到标记点（ROLLBACK 命令的一种变形写法）。 一个事务要么提交（Commit），要么回滚（Rollback），提交意味着成功，回滚意味着失败。编写事务代码时，以 BEGIN 命令开头，后跟一条或者多条 SQL 语句，最后书写 COMMIT 或者 ROLLBACK 命令；COMMIT 和 ROLLBACK 对应事务的两种状态，只能出现一个。事务控制命令仅能与 DML 类别的 SQL 命令一起使用，包括 INSERT、UPDATE、DELETE 和 SELECT，在创建或者删除表时不能使用事务，因为这些操作在数据库中是自动提交的。 1) 开始事务开始事务有以下两种命令，选择其一即可： BEGIN; 或者 START TRANSACTION; 该命令用来标记一个事务的起始点。 2) 提交事务提交事务使用如下命令： COMMIT; 提交事务意味着真正执行事务包含的 SQL 语句，并把对数据库的修改写入到磁盘上的物理数据库中。COMMIT 意味着事务结束，并且执行成功。例如，有包含如下记录的 CUSTOMERS 表： +----+----------+-----+-----------+----------+ | ID | NAME | AGE | ADDRESS | SALARY | +----+----------+-----+-----------+----------+ | 1 | Ramesh | 32 | Ahmedabad | 2000.00 | | 2 | Khilan | 25 | Delhi | 1500.00 | | 3 | kaushik | 23 | Kota | 2000.00 | +----+----------+-----+-----------+----------+ 打开一个 MySQL 命令行窗口（我们称它为 A 窗口），使用事务向表中插入两条数据： mysql&gt; BEGIN; mysql&gt; INSERT INTO CUSTOMERS (NAME, AGE, ADDRESS, SALARY) VALUES (&#39;Chaitali&#39;, 25, &#39;Mumbai&#39;, 6500.00 ); mysql&gt; INSERT INTO CUSTOMERS (NAME, AGE, ADDRESS, SALARY) VALUES (&#39;Hardik&#39;, 27, &#39;Bhopal&#39;, 8500.00 ); 再打开另外一个 MYSQL 命令行窗口（我们称它为 B 窗口），使用 SELECT 命令查看 CUSTOMERS 表的内容： mysql&gt; SELECT * FROM CUSTOMERS; +----+---------+-----+-----------+--------+ | id | name | age | address | salary | +----+---------+-----+-----------+--------+ | 1 | Ramesh | 32 | Ahmedabad | 2000 | | 2 | Khilan | 25 | Delhi | 1500 | | 3 | Kaushik | 23 | Kota | 2000 | +----+---------+-----+-----------+--------+ 您看，A 窗口对表的修改并没有影响到 B 窗口，B 窗口只能查看到修改之前的内容，这说明 A 窗口的修改动作并没有立即更新到物理数据库，所以在其它会话窗口中无法看到。在 A 窗口中提交事务： mysql&gt; COMMIT; 在 B 窗口中再次查看 CUSTOMERS 表的内容： mysql&gt; SELECT * FROM CUSTOMERS; +----+----------+-----+-----------+--------+ | id | name | age | address | salary | +----+----------+-----+-----------+--------+ | 1 | Ramesh | 32 | Ahmedabad | 2000 | | 2 | Khilan | 25 | Delhi | 1500 | | 3 | Kaushik | 23 | Kota | 2000 | | 4 | Chaitali | 25 | Mumbai | 6500 | | 5 | Hardik | 27 | Bhopal | 8500 | +----+----------+-----+-----------+--------+ 您看，在 A 窗口提交事务以后，对表所做的修改才真正更新到物理数据库中，所以才能在其它会话窗口中查看到 A 窗口中插入的数据。 3) 回滚事务回滚意味着撤销尚未保存到物理数据库中的操作，具体语法格式如下： ROLLBACK; 事务执行过程中如果发生了某种故障，事务不能继续执行，就可以撤销事务，此时对数据库的修改并不会保存到物理数据库中。撤销意味着事务结束，并且执行失败。例如，有包含如下记录的 CUSTOMERS 表： +----+----------+-----+-----------+--------+ | id | name | age | address | salary | +----+----------+-----+-----------+--------+ | 1 | Ramesh | 32 | Ahmedabad | 2000 | | 2 | Khilan | 25 | Delhi | 1500 | | 3 | Kaushik | 23 | Kota | 2000 | | 4 | Chaitali | 25 | Mumbai | 6500 | | 5 | Hardik | 27 | Bhopal | 8500 | +----+----------+-----+-----------+--------+ 使用事务删除最后两个用户，并回滚： mysql&gt; BEGIN; mysql&gt; DELETE FROM CUSTOMERS WHERE ID=4; mysql&gt; DELETE FROM CUSTOMERS WHERE ID=5; mysql&gt; ROLLBACK; mysql&gt; SELECT * FROM CUSTOMERS; +----+----------+-----+-----------+--------+ | id | name | age | address | salary | +----+----------+-----+-----------+--------+ | 1 | Ramesh | 32 | Ahmedabad | 2000 | | 2 | Khilan | 25 | Delhi | 1500 | | 3 | Kaushik | 23 | Kota | 2000 | | 4 | Chaitali | 25 | Mumbai | 6500 | | 5 | Hardik | 27 | Bhopal | 8500 | +----+----------+-----+-----------+--------+ 您看，回滚事务以后，物理数据库中的数据并没有发生改变，表中的内容和事务执行之前的内容一致。 4) 回滚标记点ROLLBACK 命令默认回滚整个事务，也即事务中的所有修改操作都无效。但是 SQL 允许回滚事务的一部分，此时需要在事务中设置一个标记点，在该标记点之后的 SQL 语句将被回滚，之前的 SQL 语句将被成功执行。设置标记点使用 SAVEPOINT 命令，具体语法如下： SAVEPOINT point_name; point_name 为标记点名字。回滚到标记点使用 ROLLBACK TO 命令，具体语法如下： ROLLBACK TO point_name; 例如，有包含如下记录的 CUSTOMERS 表： +----+----------+-----+-----------+--------+ | id | name | age | address | salary | +----+----------+-----+-----------+--------+ | 1 | Ramesh | 32 | Ahmedabad | 2000 | | 2 | Khilan | 25 | Delhi | 1500 | | 3 | Kaushik | 23 | Kota | 2000 | | 4 | Chaitali | 25 | Mumbai | 6500 | | 5 | Hardik | 27 | Bhopal | 8500 | +----+----------+-----+-----------+--------+ 使用事务删除最后两个用户，并回滚到标记点： mysql&gt; BEGIN; mysql&gt; DELETE FROM CUSTOMERS WHERE ID=4; mysql&gt; SAVEPOINT sp; mysql&gt; DELETE FROM CUSTOMERS WHERE ID=5; mysql&gt; ROLLBACK TO sp; mysql&gt; SELECT * FROM CUSTOMERS; +----+---------+-----+-----------+--------+ | id | name | age | address | salary | +----+---------+-----+-----------+--------+ | 1 | Ramesh | 32 | Ahmedabad | 2000 | | 2 | Khilan | 25 | Delhi | 1500 | | 3 | Kaushik | 23 | Kota | 2000 | | 5 | Hardik | 27 | Bhopal | 8500 | +----+---------+-----+-----------+--------+","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"JavaWeb笔记","slug":"Java/JavaWeb笔记","permalink":"http://example.com/categories/Java/JavaWeb%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"JavaWeb笔记（四）","slug":"1c60970a20864932bc3ef0807b9fda67","date":"2023-01-24T03:24:49.483Z","updated":"2023-01-24T03:25:54.473Z","comments":true,"path":"2023/01/24/1c60970a20864932bc3ef0807b9fda67/","link":"","permalink":"http://example.com/2023/01/24/1c60970a20864932bc3ef0807b9fda67/","excerpt":"","text":"**提醒：**还没有申请到IDEA专业版本授权的同学要抓紧了，很快就需要用到。 经过前面基础内容的学习，现在我们就可以正式地进入Web开发的学习当中啦~ 本章节会讲解前端基础内容（如果已经学习过，可以直接跳到下一个大章节了）那么什么是前端，什么又是后端呢？ 前端：我们网站的页面，包括网站的样式、图片、视频等一切用户可见的内容都是前端的内容。 后端：处理网站的所有数据来源，比如我们之前从数据库中查询数据，而我们查询的数据经过处理最终会被展示到前端，而用于处理前端数据的工作就是由后端来完成的。 相当于，前端仅仅是一层皮，它直接决定了整个网站的美观程度，我们可以自由地编排页面的布局，甚至可以编写好看的特效；而灵魂则是后端，如何处理用户的交互、如何处理数据查询是后端的职责所在，我们前面学习的都是后端内容，而Java也是一门专注于后端开发的语言。 对于前端开发我们需要学习一些新的内容，只有了解了它们，我们才能编写出美观的页面。 本教程并不会过多地去讲解前端知识，我们只会提及一些必要的内容，我们主要学习的是JavaWeb，更倾向于后端开发，学习前端的目的只是为了让同学们了解前后端的交互方式，在进行后端开发时思路能够更加清晰，有关前端的完整内容学习，可以浏览其他前端知识教程。 我们在最开始讲解网络编程时，提到了浏览器访问服务器，实际上浏览器访问服务器就是一种B&#x2F;S结构，而我们使用Java代码编写的客户端连接服务器就是一种C&#x2F;S结构。 Web开发还要从HTML开始讲起，这个语言非常简单，很好学习，看完视频如果你觉得前端简单自己更喜欢一些，建议马上转前端吧，还来得及，工资还比后端高，不像后端那么枯燥乏味。 HTML页面我们前面学习了XML语言，它是一种标记语言，我们需要以成对标签的格式进行填写，但是它是专用于保存数据，而不是展示数据，而HTML恰恰相反，它专用于展示数据，由于我们前面已经学习过XML语言了，HTML语言和XML很相似，所以我们学习起来会很快。 第一个HTML页面我们前面知道，通过浏览器可以直接浏览XML文件，而浏览器一般是用于浏览HTML文件的，以HTML语言编写的内容，会被浏览器识别为一个页面，并根据我们编写的内容，将对应的组件添加到浏览器窗口中。 我们一般使用Chrome、Safari、Microsoft Edge等浏览器进行测试，IE浏览器已经彻底淘汰了！ 比如我们可以创建一个Html文件来看看浏览器会如何识别，使用IDEA也能编写HTML页面，我们在IDEA中新建一个Web模块，进入之后我们发现，项目中没有任何内容，我们右键新建一个HTML文件，选择HTML5文件，并命名为index，创建后出现： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 我们发现，它和XML基本长得一样，并且还自带了一些标签，那么现在我们通过浏览器来浏览这个HTML文件（这里推荐使用内置预览，不然还得来回切换窗口） 我们发现现在什么东西都没有，但是在浏览器的标签位置显示了网页的名称为Title，并且显示了一个IDEA的图标作为网页图标。 现在我们稍微进行一些修改： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;lbw的直播间&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 现在全体起立&lt;/body&gt;&lt;/html&gt; 再次打开浏览器，我们发现页面中出现了我们输入的文本内容，并且标题也改为了我们自定义的标题。 我们可以在设置-&gt;工具-&gt;Web浏览器和预览中将重新加载页面规则改为变更时，这样我们使用内置浏览器或是外部浏览器，可以自动更新我们编写的内容。 我们还可以在页面中添加一个图片，随便将一张图片放到html文件的同级目录下，命名为image.xxx，其中xxx是后缀名称，不要修改，我们在body节点中添加以下内容： 12&lt;img width=&quot;300&quot; src=&quot;image.xxx&quot; alt=&quot;剑光如我，斩尽牛杂&quot;&gt;&lt;!-- 注意xxx替换成对应的后缀名称 --&gt; 我们发现，我们的页面中居然能够显示我们添加的图片内容。因此，我们只需要编写对应的标签，浏览器就能够自动识别为对应的组件，并将其展示到我们的浏览器窗口中。 我们再来看看插入一个B站的视频，很简单，只需要到对应的视频下方，找到分享，我们看到有一个嵌入代码： 1&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=333231998&amp;bvid=BV1rA411g7q8&amp;cid=346917516&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; width=&quot;800&quot; height=&quot;500&quot;&gt; &lt;/iframe&gt; 每一个页面都是通过这些标签来编写的，几乎所有的网站都是使用HTML编写页面。 HTML语法规范一个HTML文件中一般分为两个部分： 头部：一般包含页面的标题、页面的图标、还有页面的一些设置，也可以在这里导入css、js等内容。 主体：整个页面所有需要显示的内容全部在主体编写。 我们首先来看头部，我们之前使用的HTML文件中头部包含了这些内容： 12&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;lbw的直播间&lt;/title&gt; 首先meta标签用于定义页面的一些元信息，这里使用它来定义了一个字符集（编码格式），一般是UTF-8，下面的title标签就是页面的标题，会显示在浏览器的上方。我们现在来给页面设置一个图标，图标一般可以在字节跳动的IconPark网站找到：https://iconpark.oceanengine.com/home，选择一个自己喜欢的图标下载即可。 将图标放入到项目目录中，并命名为icon.png，在HTML头部添加以下内容： 1&lt;link rel=&quot;icon&quot; href=&quot;icon.png&quot; type=&quot;image/x-icon&quot; /&gt; link标签用于关联当前HTML页面与其他资源的关系，关系通过rel属性指定，这里使用的是icon表示这个文件是当前页面图标。 现在访问此页面，我们发现页面的图标已经变成我们指定的图标样式了。 现在我们再来看主体，我们可以在主体内部编写该页面要展示的所有内容，比如我们之前就用到了img标签来展示一个图片，其中每一个标签都称为一个元素： 1&lt;img width=&quot;300&quot; src=&quot;image.xxx&quot; alt=&quot;当图片加载失败时，显示的文本&quot;&gt; 我们发现，这个标签只存在一个，并没有成对出现，HTML中有些标签是单标签，也就是说只有这一个，还有一些标签是双标签，必须成对出现，HTML中，也不允许交叉嵌套，但是出现交叉嵌套时，浏览器并不会提示错误，而是仍旧尝试去解析这些内容，甚至会帮助我们进行一定程度的修复，比如： 123456&lt;body&gt; &lt;iframe src=&quot;//player.bilibili.com/player.html?aid=333231998&amp;bvid=BV1rA411g7q8&amp;cid=346917516&amp;page=1&quot; width=&quot;800&quot; height=&quot;500&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt;&lt;/body&gt;&lt;/iframe&gt; 很明显上面的代码已经出现交叉嵌套的情况了，但是依然能够在浏览器中正确地显示。 在主体中，我们一般使用div标签来分割页面： 1234&lt;body&gt; &lt;div&gt;我是第一块&lt;/div&gt; &lt;div&gt;我是第二块&lt;/div&gt;&lt;/body&gt; 通过使用div标签，我们将整个页面按行划分，而高度就是内部元素的高度，那么如果只希望按元素划分，也就是说元素占多大就划分多大的空间，那么我们就可以使用span标签来划分： 1234567&lt;body&gt; &lt;div&gt; &lt;span&gt;我是第一块第一个部分&lt;/span&gt; &lt;span&gt;我是第一块第二个部分&lt;/span&gt; &lt;/div&gt; &lt;div&gt;我是第二块&lt;/div&gt;&lt;/body&gt; 我们也可以使用p段落标签，它一般用于文章分段： 1234567891011121314151617&lt;body&gt; &lt;p&gt; 你看这个彬彬啊，才喝几罐就醉了，真的太逊了。 这个彬彬就是逊呀！ 听你这么说，你很勇哦？ 开玩笑，我超勇的，超会喝的啦。 超会喝，很勇嘛。身材不错哦，蛮结实的嘛。 &lt;/p&gt; &lt;p&gt; 哎，杰哥，你干嘛啊。都几岁了，还那么害羞！我看你，完全是不懂哦！ 懂，懂什么啊？ 你想懂？我房里有一些好康的。 好康，是新游戏哦！ 什么新游戏，比游戏还刺激！ &lt;/p&gt; &lt;p&gt; 杰哥，这是什么啊？ 哎呦，你脸红啦！来，让我看看。 不要啦！！ 让我看看嘛。 不要啦，杰哥，你干嘛啊！ 让我看看你法语正不正常啊！ &lt;/p&gt;&lt;/body&gt; 那么如果遇到特殊字符该怎么办呢？和XML一样，我们可以使用转义字符： **注意：**多个连续的空格字符只能被识别为一个，如果需要连续多个必须使用转义字符，同时也不会识别换行，换行只会变成一个空格，需要换行必须使用br标签。 通过了解了HTML的一些基础语法，我们现在就知道一个页面大致是如何编写了。 HTML常用标签前面我们已经了解了HTML的基本语法规范，那么现在我们就来看看，有哪些常用的标签吧，首先是换行和分割线： br 换行 hr 分割线 1234567&lt;body&gt; &lt;div&gt; 我是一段文字&lt;br&gt;我是第二段文字 &lt;/div&gt; &lt;hr&gt; &lt;div&gt;我是底部文字&lt;/div&gt;&lt;/body&gt; 标题一般用h1到h6表示，我们来看看效果： 123456789&lt;body&gt;&lt;h1&gt;一级标题&lt;/h1&gt;&lt;h2&gt;二级标题&lt;/h2&gt;&lt;h3&gt;三级标题&lt;/h3&gt;&lt;h4&gt;四级标题&lt;/h4&gt;&lt;h5&gt;五级标题&lt;/h5&gt;&lt;h6&gt;六级标题&lt;/h6&gt;&lt;p&gt;我是正文内容，真不错。&lt;/p&gt;&lt;/body&gt; 现在我们来看看超链接，我们可以添加一个链接用于指向其他网站： 1&lt;a href=&quot;https://www.bilibili.com&quot;&gt;点击访问小破站&lt;/a&gt; 我们也可以指定页面上的一个锚点进行滚动： 1234567891011&lt;body&gt;&lt;a href=&quot;#test&quot;&gt;跳转锚点&lt;/a&gt;&lt;img src=&quot;image.jpeg&quot; width=&quot;500&quot;&gt;&lt;img src=&quot;image.jpeg&quot; width=&quot;500&quot;&gt;&lt;img src=&quot;image.jpeg&quot; width=&quot;500&quot;&gt;&lt;img src=&quot;image.jpeg&quot; width=&quot;500&quot;&gt;&lt;div id=&quot;test&quot;&gt;我是锚点&lt;/div&gt;&lt;img src=&quot;image.jpeg&quot; width=&quot;500&quot;&gt;&lt;img src=&quot;image.jpeg&quot; width=&quot;500&quot;&gt;&lt;img src=&quot;image.jpeg&quot; width=&quot;500&quot;&gt;&lt;/body&gt; 每个元素都可以有一个id属性，我们只需要给元素添加一个id属性，就使用a标签可以跳转到一个指定锚点。 我们接着来看看列表元素，这是一个无需列表，其中每一个li表示一个列表项： 1234567&lt;ul&gt; &lt;li&gt;一号选项&lt;/li&gt; &lt;li&gt;二号选项&lt;/li&gt; &lt;li&gt;三号选项&lt;/li&gt; &lt;li&gt;四号选项&lt;/li&gt; &lt;li&gt;五号选项&lt;/li&gt;&lt;/ul&gt; 我们也可以使用ol来显示一个有序列表： 1234567&lt;ol&gt; &lt;li&gt;一号选项&lt;/li&gt; &lt;li&gt;二号选项&lt;/li&gt; &lt;li&gt;三号选项&lt;/li&gt; &lt;li&gt;四号选项&lt;/li&gt; &lt;li&gt;五号选项&lt;/li&gt;&lt;/ol&gt; 表格也是很重要的一种元素，但是它编写起来相对有一点麻烦： 123456789101112131415161718192021222324&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;学号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年级&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;0001&lt;/td&gt; &lt;td&gt;小明&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;2019&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;0002&lt;/td&gt; &lt;td&gt;小红&lt;/td&gt; &lt;td&gt;女&lt;/td&gt; &lt;td&gt;2020&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 虽然这样生成了一个表格，但是这个表格并没有分割线，并且格式也不符合我们想要的样式，那么如何才能修改这些基础属性的样式呢，我们就需要聊聊CSS了。 HTML表单表单就像其名字一样，用户在页面中填写了对应的内容，点击按钮就可以提交到后台，比如登陆界面，就可以使用表单来实现： 一个网页中最重要的当属输入框和按钮了，那么我们来看看如何创建一个输入框和按钮： 1234&lt;label&gt; 我是输入框 &lt;input type=&quot;text&quot;&gt;&lt;/label&gt; 对于一个输入框，我们一般会将其包括在一个lable标签中，它和span效果一样，但是我们点击前面文字也能快速获取输入框焦点。 12345678910111213141516&lt;body&gt;&lt;div&gt;登陆我们的网站&lt;/div&gt;&lt;hr&gt;&lt;div&gt; &lt;label&gt; 账号： &lt;input type=&quot;text&quot;&gt; &lt;/label&gt;&lt;/div&gt;&lt;div&gt; &lt;label&gt; 密码： &lt;input type=&quot;password&quot;&gt; &lt;/label&gt;&lt;/div&gt;&lt;/body&gt; 输入框可以有很多类型，我们来试试看password，现在输入内容就不会直接展示原文了。 创建一个按钮有以下几种方式，在学习JavaWeb时，我们更推荐第二种方式，我们后面进行登陆操作需要配合表单使用： 123&lt;button&gt;登陆&lt;/button&gt;&lt;input type=&quot;submit&quot; value=&quot;登陆&quot;&gt;&lt;input type=&quot;button&quot; value=&quot;登陆&quot;&gt; 现在我们就可以写一个大致的登陆页面了： 123456789101112131415161718192021222324&lt;body&gt; &lt;h1&gt;登陆我们的网站&lt;/h1&gt; &lt;form&gt; &lt;div&gt; &lt;label&gt; 账号： &lt;input type=&quot;text&quot; placeholder=&quot;Username...&quot;&gt; &lt;/label&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt; 密���： &lt;input type=&quot;password&quot; placeholder=&quot;Password...&quot;&gt; &lt;/label&gt; &lt;/div&gt; &lt;br&gt; &lt;a href=&quot;https://www.baidu.com&quot;&gt;忘记密码&lt;/a&gt; &lt;br&gt; &lt;br&gt; &lt;div&gt; &lt;input type=&quot;submit&quot; value=&quot;登陆&quot;&gt; &lt;/div&gt; &lt;/form&gt;&lt;/body&gt; 表单一般使用form标签将其囊括，但是现在我们还用不到表单提交，因此之后我们再来讲解表单的提交。 input只能实现单行文本，那么如何实现多行文本呢？ 1234&lt;label&gt; 这是我们的文本框&lt;br&gt; &lt;textarea placeholder=&quot;文本内容...&quot; cols=&quot;10&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt;&lt;/label&gt; 我们还可以指定默认的行数和列数，拖动左下角可以自定义文本框的大小。 我们还可以在页面中添加勾选框： 1234&lt;label&gt; &lt;input type=&quot;checkbox&quot;&gt; 我同意本网站的隐私政策&lt;/label&gt; 上面演示的是一个多选框，那么我们来看看单选框： 12345678&lt;label&gt; &lt;input type=&quot;radio&quot; name=&quot;role&quot;&gt; 学生&lt;/label&gt;&lt;label&gt; &lt;input type=&quot;radio&quot; name=&quot;role&quot;&gt; 教师&lt;/label&gt; 这里需要使用name属性进行分组，同一个组内的选项只能选择一个。 我们也可以添加列表让用户进行选择，创建一个下拉列表： 1234567&lt;label&gt; 登陆身份： &lt;select&gt; &lt;option&gt;学生&lt;/option&gt; &lt;option&gt;教师&lt;/option&gt; &lt;/select&gt;&lt;/label&gt; 默认选取的是第一个选项，我们可以通过selected属性来决定默认使用的是哪个选项。 当然，HTML的元素远不止我们所提到的这些，有关更多HTML元素的内容，可以自行了解。 CSS样式之前我们编写的页面非常基础，我们只能通过一些很基本的属性来排列我们的页面元素，那么如何实现更高度的自定义呢，我们就需要用到CSS来自定义样式，首先我们创建一个名为style.css的文件。 首先在我们HTML文件的头部添加： 1&lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt; 我们在CSS文件中添加以下内容： 123body &#123; text-align: center;&#125; 我们发现，网页的内容全部变为居中显示了，这正是css在生效，相当于我们现在给页面添加了自定义的样式规则。 当然，我们也可以选择不使用CSS，而是直接对某个元素添加样式： 12&lt;body style=&quot;text-align: center;&quot;&gt; ... 这样的效果其实是等同于上面的css文件的，相当于我们直接把样式定义在指定元素上。 也可以在头部直接定义样式，而不是使用外部文件： 12345&lt;style&gt; body &#123; text-align: center; &#125;&lt;/style&gt; 使用以上三种方式都可以自定义页面的样式，我们推荐使用还是第一种，不然我们的代码会很繁杂。 样式的属性是非常多的，我们不可能一个一个全部讲完，视频中用到什么再来讲解什么，如果同学们感兴趣，可以自行下去了解。 CSS选择器我们首先来了解一下选择器，那么什么是选择器呢？我们想要自定义一个元素的样式，那么我们肯定要去选择某个元素，只有先找到要自定义的元素，我们才能开始编写样式。 我们上面的例子中使用的就是标签名选择器，它可以快速选择页面中所有指定的的标签，比如我们之前使用的就是body标签，那么就相当于页面中所有的body元素全都使用此样式，那么我们现在来试试看选择页面中所有的input标签： 123input &#123; width: 200px;&#125; 我们发现，页面中所有的input元素宽度全部被设定为了200个像素（px是单位大小，代表像素，除了px还有em和rem，他们是根据当前元素字体大小决定的相对大小，一般用于适配各种大小的浏览器窗口，这里暂时不用） 样式编写完成后，如果只有一个属性，可以不带;若多个属性则每个属性后面都需要添加一个; 因此，一个标签选择器的格式为： 123标签名称 &#123; 属性名称: 属性值&#125; 我们还可以设定输入框的字体大小、行高等： 12345input &#123; width: 200px; font-size: 20px; line-height: 40px;&#125; 我们现在可以通过选择器快速地去设置某个元素样式了，那么如何实现只设置某个元素的样式呢，现在我们来看看，id选择器，我们之前已经讲解过了，每个元素都可以有一个id属性，我们可以将其当做一个跳转的锚点使用，而现在，我们可以使用css来进行定位： 我们先为元素添加id属性： 1&lt;h1 id=&quot;title&quot;&gt;登陆我们的网站&lt;/h1&gt; 现在使用CSS选择我们的元素，并设定一个属性，选择某个id需要在前面加上一个#： 123#title &#123; color: red;&#125; 虽然id选择器已经可以很方便的指定某个元素，但是如果我们希望n个但不是元素都被选择，id选择器就无法实现了，因为每个元素的id是唯一的，不允许出现重复id的元素，因此接着我们来讲解一下类选择器。 每个元素都可以有一个class属性，表示当前元素属于某个类（注意这里的类和我们Java中的类概念完全不同）一个元素可以属于很多个类，一个类也可以被很多个元素使用： 1234567891011121314&lt;form&gt; &lt;div &gt; &lt;label class=&quot;test&quot;&gt; 账号： &lt;input type=&quot;text&quot; placeholder=&quot;Username...&quot;&gt; &lt;/label&gt; &lt;/div&gt; &lt;div&gt; &lt;label class=&quot;test&quot;&gt; 密码： &lt;input type=&quot;password&quot; placeholder=&quot;Password...&quot;&gt; &lt;/label&gt; &lt;/div&gt;&lt;/form&gt; 上面的例子中，两个label元素都使用了test类（类名称是我们自定义的），现在我们在css文件中编写以下内容来以类进行选择： 123.test&#123; color: blue;&#125; 我们发现，两个标签的文本内容都变为了蓝色，因此使用类选择器，能够对所有为此类的元素添加样式。注意在进行类选择时，我们需要在类名前面加上.来表示。 组合选择器和优先级问题我们也可以让多个选择器，共用一个css样式： 123.test, #title &#123; color: red;&#125; 只需要并排写即可，注意中间需要添加一个英文的逗号用于分割，我们也可以使用*来一次性选择所有的元素： 123* &#123; color: red;&#125; 我们还可以选择位于某个元素内的某个元素： 123div label &#123; color: red;&#125; 这样的话，就会选择所有位于div元素中的label元素。 当然，我们这里只介绍了一些常用的选择器，有关详细的CSS选择器可以查阅：https://www.runoob.com/cssref/css-selectors.html 我们接着来看一下选择器的优先级： 我们根据上面的信息，来测试一下，首先编写一下HTML文件： 123&lt;body&gt; &lt;div class=&quot;test&quot; id=&quot;simple&quot; style=&quot;color: blue&quot;&gt;我是测试文本内容&lt;/div&gt;&lt;/body&gt; 现在我们来编写一下css文件： 1234567891011.test &#123; color: yellow;&#125;#simple &#123; color: red;&#125;* &#123; color: palegreen;&#125; 那么现在我们可以看到，实际上生效的是我们直接编写在标签内部的内联属性，那么现在我们依次进行移除，来看看它们的优先级。 那么如果我们希望某个属性无视任何的优先级，我们可以在属性后面添加!important标记，表示此属性是一个重要属性，它的优先级会被置为最高。 **思考：**那要是我每个选择器的这个属性后面都加一个!important会怎么样？ 自定义边距我们来看看，如何使用css控制一个div板块的样式，首先编写以下代码，相当于一个div嵌套了一个div元素： 12345&lt;div id=&quot;outer&quot;&gt; &lt;div id=&quot;inner&quot;&gt; &lt;/div&gt;&lt;/div&gt; 现在编写一下自定义的css样式，我们将div设定为固定大小，并且背景颜色添加为绿色： 12345#outer &#123; background: palegreen; width: 300px; height: 300px;&#125; 我们发现左侧快速预览页面存在空隙，这是因为浏览器给我们添加了一个边距属性，我们只需要覆盖此属性并将其设定为0即可： 123body &#123; margin: 0;&#125; 现在我们给内部嵌套的div也设定一个大小，并将颜色设定为橙色： 12345#inner &#123; background: darkorange; width: 100px; height: 100px;&#125; 现在我们发现内部的div元素位于右上角，我们还可以以百分比的形式来指定大小： 12345#inner &#123; background: darkorange; width: 100%; height: 100%;&#125; 百分比会依照当前可用大小来进行分配，比如当前位于一个div内部，并且外部div元素是固定大小300px，因此100%就相当于使用了外部的全部大小，也是300px，现在内部元素完全将外部元素覆盖了，整个元素现在呈现为橙色。 我们可以为一个元素设定边距，边距分为外边距和内边距，外部元素内边距决定了内部元素与外部元素之间的间隔，我们来修改一下css样式： 123456#outer &#123; background: palegreen; width: 300px; height: 300px; padding: 10px;&#125; 我们发现，内部的div元素小了一圈，这是因为外部div元素设定了内边距，上下左右都被设定为10px大小。 而我们发现，实际上我们在一开始也是将body的外边距设定为了0，整个页面跟浏览器窗口直接间隔0px的宽度。 编写一个漂亮的登陆界面现在我们就来尝试编写一个漂亮的登陆界面吧！ JavaScript语言也称为js，是我们整个前端基础的重点内容，只有了解了JavaScript语言，我们才能了解前端如何与后端交互。 JavaScript与Java没有毛关系，仅仅只是名字中包含了Java而已，跟Java比起来，它更像Python，它是一门解释型语言，不需要进行编译，它甚至可以直接在浏览器的命令窗口中运行。 它相当于是前端静态页面的一个补充，它可以让一个普通的页面在后台执行一些程序，比如我们点击一个按钮，我们可能希望执行某些操作，比如下载文件、页面跳转、页面弹窗、进行登陆等，都可以使用JavaScript来帮助我们实现。 我们来看看一个简单的JavaScript程序： 12345678910111213const arr = [0, 2, 1, 5, 9, 3, 4, 6, 7, 8]for (let i = 0; i &lt; arr.length; i++) &#123; for (let j = 0; j &lt; arr.length - 1; j++) &#123; if(arr[j] &gt; arr[j+1])&#123; const tmp = arr[j] arr[j] = arr[j+1] arr[j+1] = tmp &#125; &#125;&#125;window.alert(arr) 这段代码实际上就是实现了一个冒泡排序算法，我们可以直接在页面的头部中引用此js文件，浏览器会在加载时自动执行js文件中编写的内容： 1&lt;script src=&quot;test.js&quot;&gt;&lt;/script&gt; 我们发现JS的语法和Java非常相似，但是它还是和Java存在一些不同之处，而且存在很多阴间语法，那么我们来看看JS的语法。 JavaScript基本语法在js中，定义变量和Java中有一些不同，定义一个变量可以使用let关键字或是var关键字，IDEA推荐我们使用let关键字，因为var存在一定的设计缺陷（这里就不做讲解了，之后一律使用let关键字进行变量声明）： 123let a = 10;a++;window.alert(a) 上面的结果中，我们得到了a的结果是11，也就是说自增和自减运算在JS中也是支持的，并且JS每一句结尾可以不用加分号。 js并不是Java那样的强类型语言（任意变量的类型一定是明确的），它是一门弱类型语言，变量的类型并不会在一开始确定，因此我们在定义变量时无需指定变量的确切类型，而是在运行时动态解析类型： 123let a = 10;a = &quot;HelloWorld！&quot;console.info(a) 我们发现，变量a已经被赋值为数字类型，但是我们依然在后续能将其赋值一个字符串，它的类型是随时可变的。 很多人说，这种变态的类型机制是JS的一大缺陷。 世界上只有两种语言：一种是很多人骂的，一种是没人用的。 我们接着来看看，JS中存在的基本数据类型： Number：数字类型（包括小数和整数） String：字符串类型（可以使用单引号或是双引号） Boolean：布尔类型（与Java一致） 还包括一些特殊值： undefined：未定义 - 变量声明但不赋值默认为undefined null：空值 - 等同于Java中的null NaN：非数字 - 值不是合法数字，比如： 1window.alert(100/&#x27;xx&#x27;) 我们可以使用typeof关键字来查看当前变量值的类型： 1234let a = 10;console.info(typeof a)a = &#x27;Hello World&#x27;console.info(typeof a) JavaScript逻辑运算和流程控制我们接着来看看js中的关系运算符，包括如下8个关系运算符：大于（&gt;）,小于（&lt;）,小于等于（&lt;&#x3D;）,大于等于（&gt;&#x3D;）,相等（&#x3D;&#x3D;），不等（!&#x3D;），全等（&#x3D;&#x3D;&#x3D;），不全等（!&#x3D;&#x3D;） 其实关系运算符大致和Java中的使用方法一致，不过它还可以进行字符串比较，有点像C++的语法： 12console.info(666 &gt; 777)console.info(&#x27;aa&#x27; &gt; &#x27;ab&#x27;) 那么，相等和全等有什么区别呢？ 12console.info(&#x27;10&#x27; == 10)console.info(&#x27;10&#x27; === 10) 我们发现，在Java中，若运算符两边是不同的基本数据类型，会直接得到false，而JS中却不像这样，我们发现字符串的10居然等于数字10，而使用全等判断才是我们希望的结果。 ==的比较规则是：当操作数类型一样时，比较的规则和恒等运算符一样，都相等才相等，如果两个操作数是字符串，则进行字符串的比较，如果里面有一个操作数不是字符串，那两个操作数通过Number()方法进行转换，转成数字进行比较。 因此，我们上面进行的判断实际上是运算符两边都进行了数字转换的结果进行比较，自然也就得到了true，而全等判断才是我们在Java中认识的相等判断。 我们接着来看逻辑运算，JS中包括&amp;&amp;、||、&amp;、|、?:等，我们先来看看位运算符： 12console.info(4 &amp; 7)console.info(4 | 7) 实际上和Java中是一样的，那么我再来看看逻辑运算： 1console.info(true || false) 对于boolean变量的判断，是与Java一致的，但是JS也可以使用非Boolen类型变量进行判断： 12console.info(!0)console.info(!1) 和C&#x2F;C++语言一样，0代表false，非0代表true，那么字符串呢？ 12console.info(!&quot;a&quot;)console.info(!&quot;&quot;) 我们发现，空串为false，非空串为true，我们再来看看： 12console.info(true || 7)console.info(7 || true) 我们发现，前者得到的结果为true，而后者得到的结果却是是7，真是滑天下之大稽，什么鬼玩意，实际上是因为，默认非0都是true，而后者又是先判断的7，因此会直接得到7而不是被转换为true 那么我们再来看看几个特殊值默认代表什么： 123console.info(!undefined)console.info(!null)console.info(!NaN) 最后来使用一下三元运算符，实际上和Java中是一样的： 12let a = true ? &quot;xx&quot; : 20console.info(a) 得益于JS的动态类型，emmm，三元运算符不一定需要固定的返回值类型。 JS的分支结构，实际上和Java是一样的，也是使用if-else语句来进行： 12345if(&quot;lbwnb&quot;)&#123; //非空串为true console.info(&quot;!!!&quot;)&#125; else &#123; console.info(&quot;???&quot;)&#125; 同理，多分支语句也能实现： 1234567if(&quot;&quot;)&#123; console.info(&quot;!!!&quot;)&#125; else if(-666)&#123; console.info(&quot;???&quot;)&#125; else &#123; console.info(&quot;O.O&quot;)&#125; 当然，多分支语句也可以使用switch来完成： 1234567891011121314let a = &quot;a&quot;switch (a)&#123; case &quot;a&quot;: console.info(&quot;1&quot;) break case &quot;b&quot;: console.info(&quot;2&quot;) break case &quot;c&quot;: console.info(&quot;3&quot;) break default: console.info(&quot;4&quot;)&#125; 接着我们来看看循环结构，其实循环结构也和Java相差不大： 1234let i = 10while(i--)&#123; console.info(&quot;100&quot;)&#125; 123for (let i = 0; i &lt; 10; i++) &#123; console.info(&quot;??&quot;)&#125; JavaScript函数定义JS中的方法和Java中的方法定义不太一样，JS中一般称其为函数，我们来看看定义一个函数的格式是什么： 123function f() &#123; console.info(&quot;有一个人前来买瓜&quot;)&#125; 定义一个函数，需要在前面加上function关键字表示这是一个函数，后面跟上函数名称和()，其中可以包含参数，在&#123;&#125;中编写函数代码。我们只需要直接使用函数名+()就能调用函数： 1f(); 我们接着来看一下，如何给函数添加形式参数以及返回值： 123456function f(a) &#123; console.info(&quot;得到的实参为：&quot;+a) return 666&#125;f(&quot;aa&quot;); 由于JS是动态类型，因此我们不必指明参数a的类型，同时也不必指明返回值的类型，一个函数可能返回不同类型的结果，因此直接编写return语句即可。同理，我们可以在调用函数时，不传参，那么默认会使用undefined： 123456function f(a) &#123; console.info(&quot;得到的实参为：&quot;+a) return 666&#125;f(); 那么如果我们希望不传参的时候使用我们自定义的默认值呢？ 123456function f(a = &quot;6666&quot;) &#123; console.info(&quot;得到的实参为：&quot;+a) return 666&#125;f(); 我们可以直接在形参后面指定默认值。 函数本身也是一种类型，他可以被变量接收，所有函数类型的变量，也可以直接被调用： 1234567function f(a = &quot;6666&quot;) &#123; console.info(&quot;得到的实参为：&quot;+a) return 666&#125;let k = f;k(); 我们也可以直接将匿名函数赋值给变量： 123let f = function (str) &#123; console.info(&quot;实参为：&quot;+str)&#125; 既然函数是一种类型，那么函数也能作为一个参数进行传递： 1234567function f(test) &#123; test();&#125;f(function () &#123; console.info(&quot;这是一个匿名函数&quot;)&#125;) 对于所有的匿名函数，可以像Java的匿名接口实现一样编写lambda表达式： 1234567function f(test) &#123; test();&#125;f(() =&gt; &#123; console.info(&quot;可以，不跟你多bb&quot;)&#125;) 1234567function f(test) &#123; test(&quot;这个是回调参数&quot;);&#125;f(param =&gt; &#123; console.info(&quot;接受到回调参数：&quot;+param)&#125;) JavaScript数组和对象JS中的数组定义与Java不同，它更像是Python中的列表，数组中的每个元素并不需要时同样的类型： 1let arr = [1, &quot;lbwnb&quot;, false, undefined, NaN] 我们可以直接使用下标来访问： 12let arr = [1, &quot;lbwnb&quot;, false, undefined, NaN]console.info(arr[1]) 我们一开始编写的排序算法，也是使用了数组。 数组还可以动态扩容，如果我们尝试访问超出数组长度的元素，并不会出现错误，而是得到undefined，同样的，我们也可以直接往超出数组长度的地方设置元素： 123let arr = [1, &quot;lbwnb&quot;, false, undefined, NaN]arr[5] = &quot;???&quot;console.info(arr) 也可以使用push和pop来实现栈操作： 1234let arr = [1, &quot;lbwnb&quot;, false, undefined, NaN]arr.push(&quot;bbb&quot;)console.info(arr.pop())console.info(arr) 数组还包括一些其他的方法，这里就不一一列出了： 12345let arr = [1, &quot;lbwnb&quot;, false, undefined, NaN]arr.fill(1)console.info(arr.map(o =&gt; &#123; return &#x27;xxx&#x27;+o&#125;)) 我们接着来看对象，JS中也能定义对象，但是这里的对象有点颠覆我们的认知： 12let obj = new Object()let obj = &#123;&#125; 以上两种写法都能够创建一个对象，但是更推荐使用下面的一种。 JS中的对象也是非常随意的，我们可以动态为其添加属性： 123let obj = &#123;&#125;obj.name = &quot;伞兵一号&quot;console.info(obj) 同理，我们也可以给对象动态添加一个函数： 123456let obj = &#123;&#125;obj.f = function ()&#123; console.info(&quot;我是对象内部的函数&quot;)&#125;obj.f() 我们可以在函数内使用this关键字来指定对象内的属性： 12345678let name = &quot;我是外部变量&quot;let obj = &#123;&#125;obj.name = &quot;我是内部变量&quot;obj.f = function ()&#123; console.info(&quot;name属性为：&quot;+this.name)&#125;obj.f() **注意：**如果使用lambda表达式，那么this并不会指向对象。 除了动态添加属性，我们也可以在一开始的时候指定对象内部的成员： 12345678let obj = &#123; name: &quot;我是内部的变量&quot;, f: function ()&#123; console.info(&quot;name属性为：&quot;+this.name) &#125;&#125;obj.f() 注意如果有多行属性，需要在属性定义后添加一个,进行分割！ JavaScript事件当我们点击一个页面中的按钮之后，我们希望之后能够进行登陆操作，或是执行一些JS代码来实现某些功能，那么这个时候，就需要用到事件。 事件相当于一个通知，我们可以提前设定好事件发生时需要执行的内容，当事件发生时，就会执行我们预先设定好的JS代码。 事件有很多种类型，其中常用的有： onclick：点击事件 oninput：内容输入事件 onsubmit：内容提交事件 那么如何为事件添加一个动作呢？ 1&lt;input type=&quot;password&quot; oninput=&quot;console.info(&#x27;正在输入文本&#x27;)&quot;&gt; 我们可以直接为一个元素添加对应事件的属性，比如oninput事件，我们可以直接在事件的值中编写js代码，但是注意，只能使用单引号，因为双引号用于囊括整个值。 我们也可以单独编写一个函数，当事件发生时直接调用我们的函数： 123function f() &#123; window.alert(&quot;你输入了一个字符&quot;)&#125; 1&lt;input type=&quot;password&quot; oninput=&quot;oninput()&quot;&gt; 仅仅了解了事件，还不足以实现高度自定义，我们接着来看DOM。 Document对象当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model），它将整个页面的所有元素全部映射为JS对象，这样我们就可以在JS中操纵页面中的元素。 比如我现在想要读取页面中某个输入框中的内容，那么我们就需要从DOM中获取此输入框元素的对象： 1document.getElementById(&quot;pwd&quot;).value 通过document对象就能够快速获取当前页面中对应的元素，并且我们也可以快速获取元素中的一些属性。 比如现在我们可以结合事件，来进行密码长度的校验，密码长度小于6则不合法，不合法的密码，会让密码框边框变红，那么首先我们先来编写一个css样式： 1234.illegal-pwd&#123; border: red 1px solid !important; box-shadow: 0 0 5px red;&#125; 接着我们来编写一下js代码，定义一个函数，此函数接受一个参数（元素本身的对象）检测输入的长度是否大于6，否则就将当前元素的class属性设定为css指定的class： 1234567function checkIllegal(e) &#123; if(e.value.length &lt; 6) &#123; e.setAttribute(&quot;class&quot;, &quot;illegal-pwd&quot;) &#125;else &#123; e.removeAttribute(&quot;class&quot;) &#125;&#125; 最后我们将此函数绑定到oninput事件即可，注意传入了一个this，这里的this代表的是输入框元素本身： 1&lt;input id=&quot;pwd&quot; oninput=&quot;checkIllegal(this)&quot; type=&quot;password&quot;&gt; 现在我们在输入的时候，会自动检查密码是否合法。 既然oninput本身也是一个属性，那么实际上我们可以动态进行修改： 1document.getElementById(&quot;pwd&quot;).oninput = () =&gt; console.info(&quot;???&quot;) 那么，我们前面提及的window对象又是什么东西呢？ 实际上Window对象范围更加广阔，它甚至直接代表了整个窗口，当然也包含我们的Document对象，我们一般通过Window对象来弹出提示框之类的东西。 发送XHR请求JS的大致内容我们已经全部学习完成了，那么如何使用JS与后端进行交互呢？ 我们知道，如果我们需要提交表单，那么我们就需要将表单的信息全部发送给我们的服务器，那么，如何发送给服务器呢？ 通过使用XMLHttpRequest对象，来向服务器发送一个HTTP请求，下面是一个最简单的请求格式： 123let xhr = new XMLHttpRequest();xhr.open(&#x27;GET&#x27;, &#x27;https://www.baidu.com&#x27;);xhr.send(); 上面的例子中，我们向服务器发起了一次网络请求，但是我们请求的是百度的服务器，并且此请求的方法为GET请求。 我们现在将其绑定到一个按钮上作为事件触发： 12345function http() &#123; let xhr = new XMLHttpRequest(); xhr.open(&#x27;GET&#x27;, &#x27;https://www.baidu.com&#x27;); xhr.send(); &#125; 1&lt;input id=&quot;button&quot; type=&quot;button&quot; onclick=&quot;http()&quot;&gt; 我们可以在网络中查看我们发起的HTTP请求并且查看请求的响应结果，比如上面的请求，会返回百度这个页面的全部HTML代码。 实际上，我们的浏览器在我们输入网址后，也会向对应网站的服务器发起一次HTTP的GET请求。 在浏览器得到页面响应后，会加载当前页面，如果当前页面还引用了其他资源文件，那么会继续向服务器发起请求，直到页面中所有的资源文件全部加载完成后，才会停止。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"JavaWeb笔记","slug":"Java/JavaWeb笔记","permalink":"http://example.com/categories/Java/JavaWeb%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"使用Socket传输文件","slug":"65909752ee164b2c877f1f77097d6358","date":"2023-01-22T16:26:58.221Z","updated":"2023-01-22T16:27:48.988Z","comments":true,"path":"2023/01/23/65909752ee164b2c877f1f77097d6358/","link":"","permalink":"http://example.com/2023/01/23/65909752ee164b2c877f1f77097d6358/","excerpt":"","text":"server.java 123456789101112131415161718192021222324252627282930package org.example;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.net.ServerSocket;import java.net.Socket;//服务器public class Server &#123; public static void main(String[] args) &#123; try (ServerSocket server = new ServerSocket(8080)) &#123; Socket socket = server.accept(); InputStream stream = socket.getInputStream(); FileOutputStream fileOutputStream = new FileOutputStream(&quot;net/background.png&quot;); int i; byte[] bytes = new byte[1024]; while((i = stream.read(bytes))!=-1)&#123; fileOutputStream.write(bytes, 0, i); &#125; fileOutputStream.flush(); fileOutputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Cilent.java 12345678910111213141516171819202122232425262728package org.example;import java.io.*;import java.net.InetSocketAddress;import java.net.Socket;public class Cilent &#123; public static void main(String[] args) &#123; try (Socket socket = new Socket()) &#123; socket.setKeepAlive(true); socket.connect(new InetSocketAddress(&quot;localhost&quot;, 8080)); System.out.println(&quot;已经连接至服务器！&quot;); FileInputStream fileInputStream = new FileInputStream(&quot;src/main/resources/background.png&quot;); OutputStream stream = socket.getOutputStream(); byte[] bytes = new byte[1024]; int i; while ((i = fileInputStream.read(bytes)) != -1) &#123; stream.write(bytes,0,i); &#125; stream.flush(); &#125; catch (IOException e) &#123; System.out.println(&quot;服务端连接失败&quot;); e.printStackTrace(); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"JavaWeb笔记","slug":"Java/JavaWeb笔记","permalink":"http://example.com/categories/Java/JavaWeb%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"VSCode 是什么|极客教程","slug":"9f99a098f001487da297656e466dcb3b","date":"2023-01-22T08:41:25.293Z","updated":"2023-01-22T08:41:25.293Z","comments":true,"path":"2023/01/22/9f99a098f001487da297656e466dcb3b/","link":"","permalink":"http://example.com/2023/01/22/9f99a098f001487da297656e466dcb3b/","excerpt":"","text":"https://geek-docs.com/vscode/vscode-tutorials/what-is-vscode.html","categories":[{"name":"网站收藏","slug":"网站收藏","permalink":"http://example.com/categories/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/"},{"name":"编辑器","slug":"网站收藏/编辑器","permalink":"http://example.com/categories/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/%E7%BC%96%E8%BE%91%E5%99%A8/"}],"tags":[]},{"title":"被删的前端游乐场","slug":"e18feca3c0ce43cd96468b8ad72fbc36","date":"2023-01-22T08:40:16.505Z","updated":"2023-01-22T08:40:16.505Z","comments":true,"path":"2023/01/22/e18feca3c0ce43cd96468b8ad72fbc36/","link":"","permalink":"http://example.com/2023/01/22/e18feca3c0ce43cd96468b8ad72fbc36/","excerpt":"","text":"http://www.godbasin.com/","categories":[{"name":"网站收藏","slug":"网站收藏","permalink":"http://example.com/categories/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/"},{"name":"前端","slug":"网站收藏/前端","permalink":"http://example.com/categories/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/%E5%89%8D%E7%AB%AF/"}],"tags":[]},{"title":"小火柴的前端小站","slug":"c64a51c38c9542fe9a5c1d7e2dc93dba","date":"2023-01-22T08:39:47.686Z","updated":"2023-01-22T08:39:47.686Z","comments":true,"path":"2023/01/22/c64a51c38c9542fe9a5c1d7e2dc93dba/","link":"","permalink":"http://example.com/2023/01/22/c64a51c38c9542fe9a5c1d7e2dc93dba/","excerpt":"","text":"https://www.xiaohuochai.cc/","categories":[{"name":"网站收藏","slug":"网站收藏","permalink":"http://example.com/categories/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/"},{"name":"前端","slug":"网站收藏/前端","permalink":"http://example.com/categories/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/%E5%89%8D%E7%AB%AF/"}],"tags":[]},{"title":"阿里巴巴开源镜像站-OPSX镜像站-阿里云开发者社区","slug":"6be31fe5f1cd44e7a52b7602603705ac","date":"2023-01-22T08:38:52.400Z","updated":"2023-01-22T08:38:52.400Z","comments":true,"path":"2023/01/22/6be31fe5f1cd44e7a52b7602603705ac/","link":"","permalink":"http://example.com/2023/01/22/6be31fe5f1cd44e7a52b7602603705ac/","excerpt":"","text":"https://developer.aliyun.com/mirror/?spm=a2c6h.13651102.0.0.1a951b11JuwHNo&amp;serviceType=mirror&amp;tag=%E7%B3%BB%E7%BB%9F","categories":[{"name":"网站收藏","slug":"网站收藏","permalink":"http://example.com/categories/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/"},{"name":"镜像站","slug":"网站收藏/镜像站","permalink":"http://example.com/categories/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/%E9%95%9C%E5%83%8F%E7%AB%99/"}],"tags":[]},{"title":"腾讯软件源","slug":"ae79cc4392384967b905c952b720f392","date":"2023-01-22T08:38:15.979Z","updated":"2023-01-22T08:38:15.979Z","comments":true,"path":"2023/01/22/ae79cc4392384967b905c952b720f392/","link":"","permalink":"http://example.com/2023/01/22/ae79cc4392384967b905c952b720f392/","excerpt":"","text":"https://mirrors.cloud.tencent.com/","categories":[{"name":"网站收藏","slug":"网站收藏","permalink":"http://example.com/categories/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/"},{"name":"镜像站","slug":"网站收藏/镜像站","permalink":"http://example.com/categories/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/%E9%95%9C%E5%83%8F%E7%AB%99/"}],"tags":[]},{"title":"DFS算法","slug":"b74bc4b803df4e7b99cf906cd5177da6","date":"2023-01-21T08:33:04.281Z","updated":"2023-01-21T08:36:21.531Z","comments":true,"path":"2023/01/21/b74bc4b803df4e7b99cf906cd5177da6/","link":"","permalink":"http://example.com/2023/01/21/b74bc4b803df4e7b99cf906cd5177da6/","excerpt":"","text":"acwing-842排列数字 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package algorithm.dfs;/*给定一个整数 n，将数字 1∼n 排成一排，将会有很多种排列方法。现在，请你按照字典序将所有的排列方法输出。输入格式共一行，包含一个整数 n输出格式按字典序输出所有排列方案，每个方案占一行。数据范围1≤n≤7输入样例：3输出样例：1 2 31 3 22 1 32 3 13 1 23 2 1 */import java.util.Scanner;public class 排列数字_842 &#123; static final int N = 10; static int n; static int[] path = new int[N]; static boolean status[] = new boolean[N]; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); n = sc.nextInt(); //输入整数n dfs(1); &#125; public static void dfs(int u) &#123; if (u &gt; n) &#123; //数字填完输出 for (int i = 1; i &lt;= n; i++) &#123; System.out.printf(&quot;%d &quot;, path[i]); &#125; System.out.println(); return; &#125; else &#123; for (int i = 1; i &lt;= n; i++) &#123; if (!status[i]) &#123; path[u] = i; //把数字放入空位 status[i] = true; //标注这个空位已经被占用 dfs(u + 1); //填下一位 path[u] = 0; //回溯,恢复之前的状态, status[i] = false; &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"搜索与图论","slug":"算法/搜索与图论","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/"}],"tags":[]},{"title":"Linux SCP指令","slug":"85a4024620e141f4b16389b65a2ce85e","date":"2023-01-20T10:40:35.187Z","updated":"2023-01-25T06:21:25.818Z","comments":true,"path":"2023/01/20/85a4024620e141f4b16389b65a2ce85e/","link":"","permalink":"http://example.com/2023/01/20/85a4024620e141f4b16389b65a2ce85e/","excerpt":"","text":"1scp -P 2222 &quot;C:\\Users\\meowrain\\.config\\clash\\profiles\\1674129914990.yml&quot; root@meowrain.cn:/root 复制本地文件到远程服务器的root目录","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"}]},{"title":"Docker容器技术","slug":"b4a4813646324eab97b039cacf031705","date":"2023-01-19T16:04:23.499Z","updated":"2023-01-19T16:04:51.637Z","comments":true,"path":"2023/01/20/b4a4813646324eab97b039cacf031705/","link":"","permalink":"http://example.com/2023/01/20/b4a4813646324eab97b039cacf031705/","excerpt":"","text":"Docker容器技术Docker是一门平台级别的技术，涉及的范围很广，所以，在开始之前，请确保你完成：Java SpringBoot 篇（推荐完成SpringCloud篇再来）视频教程及之前全部路线，否则学习会非常吃力，另外推荐额外掌握：《计算机网络》、《操作系统》相关知识。学一样东西不能完全靠记忆来完成，而是需要结合自己所学的基础知识加以理解，一般来说，单凭记忆能够掌握的东西往往是最廉价的。 **Docker官网：**https://www.docker.com **课前准备：**配置2C2G以上Linux服务器一台，云服务器、虚拟机均可。 容器技术入门随着时代的发展，Docker也逐渐走上了历史舞台，曾经我们想要安装一套环境，需要花费一下午甚至一整天来配置和安装各个部分（比如运行我们自己的SpringBoot应用程序，可能需要安装数据库、安装Redis、安装MQ等，各种各样的环境光是安装就要花费很多时间，真的是搞得心态爆炸），而有了Docker之后，我们的程序和环境部署就变得非常简单了，我们只需要将这些环境一起打包成一个镜像。而到服务器上部署时，可以直接下载镜像实现一键部署，是不是很方便？ 包括我们在学习SpringCloud需要配置的各种组件，可能在自己电脑的环境中运行会遇到各种各样的问题（可能由于电脑上各种环境没配置，导致无法运行），而现在只需要下载镜像就能直接运行，所有的环境全部在镜像中配置完成，开箱即用。 真的有这么神奇吗？我们来试试看。 环境安装和部署首先我们还是先将Docker环境搭建好（建议和我同一个环境，不然出了问题只能自己想办法了），这里我们使用： Ubuntu 22.04 操作系统 Docker分为免费的CE（Community Edition）社区版本和EE（Enterprise Edition）企业级付费版本，所以我们这里选择docker-ce进行安装。官方安装文档：https://docs.docker.com/engine/install/ubuntu/ 首先安装一些工具： 1sudo apt-get install ca-certificates curl gnupg lsb-release 不过在Ubuntu22.04已经默认安装好了。接着安装官方的GPG key： 123sudo mkdir -p /etc/apt/keyringscurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg 最后将Docker的库添加到apt资源列表中： 1echo &quot;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null 接着我们更新一次apt： 1sudo apt update 最后安装Docker CE版本： 1sudo apt install docker-ce 等待安装完成就可以了： 可以看到安装成功后版本是20.10.17，当然可能你们安装的时候就是更新的版本了。最后我们将当前用户添加到docker用户组中，不然每次使用docker命令都需要sudo执行，很麻烦： 1sudo usermod -aG docker &lt;用户名&gt; 配置好后，我们先退出SSH终端，然后重新连接就可以生效了。 这样我们Docker 的学习环境就配置好了，现在我们就尝试通过Docker来部署一个Nginx服务器试试看，使用很简单，只需要一个命令就可以了（当然现在看不懂没关系，我们后面会细嗦）： 1sudo docker run -d -p 80:80 nginx 首选它会从镜像仓库中下载对应的镜像，国内访问速度还行，不需要单独配置镜像源。接着下载完成后，就会在后台运行了，我们可以使用浏览器访问试试看： 可以看到，Nginx服务器已经成功部署了，但是实际上我们并没有在Ubuntu中安装Nginx，而是通过Docker运行的镜像来进行服务器搭建的，是不是感觉玩法挺新奇的。除了Nginx这种简单的应用之外，我们还可以通过Docker来部署复杂应用，之后我们都会一一进行讲解的。 从虚拟机到容器前面我们成功安装了Docker学习环境，以及浅尝了一下Docker为我们带来的应用快速部署。在正式进入学习之前，我们就先从Docker的发展开始说起。 在Docker出现之前，虚拟化技术可以说是占据了主导地位。首先我们来谈谈为什么会出现虚拟化技术，我们知道在企业中服务器可以说是必不可少的一种硬件设施了，服务器也是电脑，但是不像我们的家用电脑，服务器的配置是非常高的，我们家用电脑的CPU可能最高配也就20核了，内存很少有超过128G的电脑，64G内存的家用电脑可以算奢侈了。而服务器不一样，服务器级别的CPU动辄12核，甚至服务器还能同时安装多块CPU，能直接堆到好几十核： 我们家用级CPU一般是AMD的锐龙系列和Intel的酷睿系列（比如i3 i5 i7 i9），而服务器CPU一般是Intel的志强（Xeno）系列，这种CPU的特点就是核心数非常多： 并且服务器CPU相比家用CPU的功耗也会更大，因此服务器CPU的发热量非常高，如果你有幸去过机房，你会听见散热风扇猛烈转动的声音（但是服务器CPU的频率没有家用级CPU高，一般大型游戏要求的是高频率而不是核心数，而且功耗也比较大，所以并不适合做家用电脑，所以以后在网上买台式机，看到什么“i9级”CPU千万别买，是这些黑心商家把国外服务器上淘汰下来的服务器CPU（洋垃圾）装成电脑卖给你，所以会很便宜，同时核心数又能媲美i9，所以还是一分钱一分货实在） 服务器无论是CPU资源还是内存资源都远超家用电脑，而我们编写的Java后端项目，最后都会运行在这些服务器上，不过有一个问题，服务器既然有这么丰富的硬件资源，就跑咱们这一个小Java后端，是不是有点核弹炸蚊子的感觉了？可能顶多就用了服务器5%的硬件资源，服务器这么牛就运行个这也太浪费了吧。 所以，为了解决这种资源利用率只有5%-15%的情况，咱们能不能想个办法，把这一台服务器分成多个小服务器使用，每个小服务器只分配一部分的资源，比如分一个小服务器出去，只给2个CPU核心和4G内存。但是由于设计上的问题，我们的电脑只能同时运行一个操作系统，那么怎么办呢？此时虚拟化技术就开始兴起了。 虚拟化使用软件来模拟硬件并创建虚拟计算机系统。这样一来，企业便可以在单台服务器上运行多个虚拟系统，也就是运行多个操作系统和应用，而这可以实现规模经济以及提高效益。比如我们电脑上经常使用的VMware就是一种民用级虚拟化软件： 我们可以使用VMware来创建虚拟机，这些虚拟机实际上都是基于我们当前系统上的VMware软件来运行的，当然VMware也有服务器专用的虚拟化软件，有了虚拟化之后，我们的服务器就像这样： 相当于通过虚拟机模拟了很多来电脑出来，这样我们就可以在划分出来的多台虚拟机上分别安装系统和部署我们的应用程序了，并且我们可以自由分配硬件资源，合理地使用。一般在企业中，不同的应用程序可能会被分别部署到各个服务器上，隔离开来，此时使用虚拟机就非常适合。 实际上我们在什么腾讯云、阿里云租的云服务器，都是经过虚拟化技术划分出来的虚拟机而已。 那么，既然虚拟机都这么方便了，容器又是怎么杀出一条血路的呢？我们先来看看什么是容器。 容器和虚拟机比较类似，都可以为应用提供封装和隔离，都是软件，但是容器中的应用运行是寄托于宿主操作系统的，实际上依然是在直接使用操作系统的资源，当然应用程序之间环境依然是隔离的，而虚拟机则是完全模拟一台真正的电脑出来，直接就是两台不同的电脑。 因此容器相比虚拟机就简单多了，并且启动速度也会快很多，开销小了不少。 不过容器火的根本原因还是它的集装箱思想，我们知道，如果我们要写一个比如论坛、电商这类的Java项目，那么数据库、消息队列、缓存这类中间件是必不可少的，因此我们如果想要将一个服务部署到服务器，那么实际上还要提前准备好各种各样的环境，先安装好MySQL、Redis、RabbitMQ等应用，配置好了环境，再将我们的Java应用程序启动，整个流程下来，光是配置环境就要浪费大量的时间，如果是大型的分布式项目，可能要部署很多台机器，那岂不是我们得一个一个来？项目上个线就要花几天时间，显然是很荒唐的。 而容器可以打包整个环境，比较MySQL、Redis等以及我们的Java应用程序，可以被一起打包为一个镜像，当我们需要部署服务时，只需要像我们之前那样，直接下载镜像运行即可，不需要再进行额外的配置了，整个镜像中环境是已经配置好的状态，开箱即用。 而我们要重点介绍的就是Docker了，可以看到它的图标就是一只鲸鱼，鲸鱼的上面是很多个集装箱，每个集装箱就是我们的整个环境+应用程序，Docker可以将任何应用及其依赖打包为一个轻量级，可移植，自包含的容器，容器可以运行在几乎所有的操作系统上。 容器工作机制简述我们先来看看Docker的整体架构： 实际上分为三个部分： Docker 客户端：也就是我们之前使用的docker命令，都是在客户端上执行的，操作会发送到服务端上处理。 Docker 服务端：服务端就是启动容器的主体了，一般是作为服务在后台运行，支持远程连接。 Registry：是存放Docker镜像的仓库，跟Maven一样，也可以分公有和私有仓库，镜像可以从仓库下载到本地存放。 当我们需要在服务器上部署一个已经打包好的应用和环境，我们只需要下载打包好的镜像就可以了，我们前面执行了： 1sudo docker run -d -p 80:80 nginx 实际上这个命令输入之后： Docker客户端将操作发送给服务端，告诉服务端我们要运行nginx这个镜像。 Docker服务端先看看本地有没有这个镜像，发现没有。 接着只能从公共仓库Docker Hub去查找下载镜像了。 下载完成，镜像成功保存到本地。 Docker服务端加载Nginx镜像，启动容器开始正常运行（注意容器和其他容器之间，和外部之间，都是隔离的，互不影响） 所以，整个流程中，Docker就像是一搜运输船，镜像就像是集装箱，通过运输船将世界各地的货物送往我们的港口，货物到达港口后，Docker并不关心集装箱里面的是什么，只需要创建容器开箱即用就可以了。相比我们传统的手动安装配置环境，不知道方便了几个层次。 不过容器依然是寄托于宿主主机的运行的，所以一般在生产环境下，都是通过虚拟化先创建多台主机，然后再到各个虚拟机中部署Docker，这样的话，运维效率就大大提升了。 从下一章开始，我们就正式地来学习一下Docker的各种操作。 容器与镜像要启动容器最关键的就是镜像，我们来看看镜像相关的介绍。 初识容器镜像首先我们来了解一下镜像的相关操作，比如现在我们希望把某个镜像从仓库下载到本地，这里使用官方的hello-world镜像： 1docker pull hello-world 只需要输入pull命令，就可以直接下载到指定的镜像了： 可以看到对上面一行有一句Using default tag，实际上一个镜像的名称是由两部分组成的，一个是repository，还有一个是tag，一般情况下约定repository就是镜像名称，tag作为版本，默认为latest，表示最新版本。所以指定版本运行的话： 1docker pull 名称:版本 之后为了教学方便，我们就直接使用默认的tag，不去指定版本了。 镜像下载之后会存放在本地，要启动这个镜像的容器，实际上就像我们之前那样，输入run命令就可以了： 1docker run hello-world 当然如果仅仅是只想创建而不想马上运行的话，可以使用create命令： 1docker create hello-world 可以看到成功启动了： 启动之后，会使用当前镜像自动创建一个容器，我们可以输入ps命令来查看当前容器的容器列表： docker ps -a 注意后面要加一个-a表示查看所有容器（其他选项可以使用-h查看），如果不加的话，只会显示当前正在运行的容器，而HelloWorld是一次性的不是Nginx那样的常驻程序，所以容器启动打印了上面的内容之后，容器就停止运行了： 可以看到容器列表中有我们刚刚创建的hello-world以及我们之前创建的nginx（注意同一个镜像可以创建多个容器），每个容器都有一个随机生成的容器ID写在最前面，后面是容器的创建时间以及当前的运行状态，最后一列是容器的名称，在创建容器时，名称可以由我们指定也可以自动生成，这里就是自动生成的。 我们可以手动指定名称启动，在使用run命令时，添加--name参数即可： 1docker run --name=lbwnb hello-world 我们可以手动开启处于停止状态的容器： 1docker start &lt;容器名称/容器ID&gt; 注意启动的对象我们要填写容器的ID或是容器的名称才可以，容器ID比较长，可以不写全只写一半，但是你要保证你输入的不完全容器ID是唯一的。 如果想要停止容器直接输入stop命令就可以了： 1docker stop &lt;容器名称/容器ID&gt; 或是重启： 1docker restart &lt;容器名称/容器ID&gt; 如果我们不需要使用容器了，那么可以将容器删除，但是注意只有容器处于非运行状态时才可以删除： 1docker rm &lt;容器名称/容器ID&gt; 当然如果我们希望容器在停止后自动删除，我们可以在运行时添加--rm参数： 1docker run --rm 镜像名称 删除后，容器将不复存在，当没有任何关于nginx的容器之后，我们可以删除nginx的本地镜像： 我们可以使用images命令来检查一下当前本地有那些镜像： 1docker images 至此，我们已经了解了Docker的简单使用，在后面的学习中，我们还会继续认识更多的玩法。 镜像结构介绍前面我们了解了Docker的相关基本操作，实际上容器的基石就是镜像，有了镜像才能创建对应的容器实例，那么我们就先从镜像的基本结构开始说起，我们来看看镜像到底是个什么样的存在。 我们在打包项目时，实际上往往需要一个基本的操作系统环境，这样我们才可以在这个操作系统上安装各种依赖软件，比如数据库、缓存等，像这种基本的系统镜像，我们称为base镜像，我们的项目之后都会基于base镜像进行打包，当然也可以不需要base镜像，仅仅是基于当前操作系统去执行简单的命令，比如我们之前使用的hello-world就是。 一般base镜像就是各个Linux操作系统的发行版，比如我们正在使用的Ubuntu，还有CentOS、Kali等等。这里我们就下载一下CentOS的base镜像： 1docker pull centos 可以看到，CentOS的base镜像就已经下载完成，不像我们使用完整系统一样，base镜像的CentOS省去了内核，所以大小只有272M，这里需要解释一下base镜像的机制： Linux操作体系由内核空间和用户空间组成，其中内核空间就是整个Linux系统的核心，Linux启动后首先会加bootfs文件系统，加载完成后会自动卸载掉，之后会加载用户空间的文件系统，这一层是我们自己可以进行操作的部分： bootfs包含了BootLoader和Linux内核，用户是不能对这层作任何修改的，在内核启动之后，bootfs会自动卸载。 rootfs则包含了系统上的常见的目录结构，包括/dev、 /proc、 /bin等等以及一些基本的文件和命令，也就是我们进入系统之后能够操作的整个文件系统，包括我们在Ubuntu下使用的apt和CentOS下使用的yum，都是用户空间上的。 base镜像底层会直接使用宿主主机的内核，也就是说你的Ubuntu内核版本是多少，那么base镜像中的CentOS内核版本就是多少，而rootfs则可以在不同的容器中运行多种不同的版本。所以，base镜像实际上只有CentOS的rootfs，因此只有300M大小左右，当然，CentOS里面包含多种基础的软件，还是比较臃肿的，而某些操作系统的base镜像甚至都不到10M。 使用uname命令可以查看当前内核版本： 因此，Docker能够同时模拟多种Linux操作系统环境，就不足为奇了，我们可以尝试启动一下刚刚下载的base镜像： 1docker run -it centos 注意这里需要添加-it参数进行启动，其中-i表示在容器上打开一个标准的输入接口，-t表示分配一个伪tty设备，可以支持终端登录，一般这两个是一起使用，否则base容器启动后就自动停止了。 可以看到使用ls命令能够查看所有根目录下的文件，不过很多命令都没有，连clear都没有，我们来看看内核版本： 可以看到内核版本是一样的（这也是缺点所在，如果软件对内核版本有要求的话，那么此时使用Docker就直接寄了），我们输入exit就可以退出容器终端了，可以看到退出后容器也停止了： 当然我们也可以再次启动，注意启动的时候要加上-i才能进入到容器进行交互，否则会在后台运行： 基于base镜像，我们就可以在这基础上安装各种各样的软件的了，几乎所有的镜像都是通过在base镜像的基础上安装和配置需要的软件构建出来的： 每安装一个软件，就在base镜像上一层层叠加上去，采用的是一种分层的结构，这样多个容器都可以将这些不同的层次自由拼装，比如现在好几个容器都需要使用CentOS的base镜像，而上面运行的软件不同，此时分层结构就很爽了，我们只需要在本地保存一份base镜像，就可以给多个不同的容器拼装使用，是不是感觉很灵活？ 我们看到除了这些软件之外，最上层还有一个可写容器层，这个是干嘛的呢，为什么要放在最上面？ 我们知道，所有的镜像会叠起来组成一个统一的文件系统，如果不同层中存在相同位置的文件，那么上层的会覆盖掉下层的文件，最终我们看到的是一个叠加之后的文件系统。当我们需要修改容器中的文件时，实际上并不会对镜像进行直接修改，而是在最顶上的容器层（最上面一般称为容器层，下面都是镜像层）进行修改，不会影响到下面的镜像，否则镜像就很难实现多个容器共享了。所以各个操作如下： 文件读取：要读取一个文件，Docker会最上层往下依次寻找，找到后则打开文件。 文件创建和修改：创建新文件会直接添加到容器层中，修改文件会从上往下依次寻找各个镜像中的文件，如果找到，则将其复制到容器层，再进行修改。 删除文件：删除文件也会从上往下依次寻找各个镜像中的文件，一旦找到，并不会直接删除镜像中的文件，而是在容器层标记这个删除操作。 也就是说，我们对整个容器内的文件进行的操作，几乎都是在最上面的容器层进行的，我们是无法干涉到下面所有的镜像层文件的，这样就很好地保护了镜像的完整性，才能实现多个容器共享使用。 构建镜像前面我们已经了解了Docker镜像的结构，实际上所有常用的应用程序都有对应的镜像，我们只需要下载这些镜像然后就可以使用了，而不需要自己去手动安装，顶多需要进行一些特别的配置。当然要是遇到某些冷门的应用，可能没有提供镜像，这时就要我们手动去安装，接着我们就来看看如何构建我们自己的Docker镜像。构建镜像有两种方式，一种是使用commit命令来完成，还有一种是使用Dockerfile来完成，我们先来看第一种。 这里我们就做一个简单的例子，比如我们现在想要在Ubuntu的base镜像中安装Java环境，并将其打包为新的镜像（这个新的镜像就是一个包含Java环境的Ubuntu系统镜像） 咱们先启动Ubuntu镜像，然后使用yum命令（跟apt比较类似）来安装Java环境，首先是run命令： 1docker pull ubuntu 接着启动： 直接使用apt命令来安装Java环境，在这之前先更新一下，因为是最小安装所以本地没有任何软件包： 接着输入： 1apt install openjdk-8-jdk 等待安装完成： 这样，我们就完成了对Java环境的安装了，接着我们就可以退出这个镜像然后将其构建为新的镜像： 使用commit命令可以将容器保存为新的镜像： 1docker commit 容器名称/ID 新的镜像名称 可以看到安装了软件之后的镜像大小比我们原有的大小大得多，这样我们就可以通过这个镜像来直接启动一个带Java环境的Ubuntu操作系统容器了。不过这种方式虽然自定义度很高，但是Docker官方并不推荐，这样的话使用者并不知道镜像是如何构建出来的，是否里面带了后门都不知道，并且这样去构建效率太低了，如果要同时构建多种操作系统的镜像岂不是要一个一个去敲？我们作为普通用户实际上采用Dokcerfile的方式会更好一些。 我们来看看如何使用Dockerfile的形式创建一个带Java环境的Ubuntu系统镜像。首先直接新建一个名为Dockerfile的文件： 1touch Dockerfile 接着我们来进行编辑，Dockerfile内部需要我们编写多种指令来告诉Docker我们的镜像的相关信息： 1FROM &lt;基础镜像&gt; 首先我们需要使用FROM指令来选择当前镜像的基础镜像（必须以这个指令开始），这里我们直接使用ubuntu作为基础镜像即可，当然如果不需要任何基础镜像的话，直接使用scratch表示从零开始构建，这里就不演示了。 基础镜像设定完成之后，我们就需要在容器中运行命令来安装Java环境了，这里需要使用RUN指令： 12RUN apt updateRUN apt install -y openjdk-8-jdk 每条指令执行之后，都会生成一个新的镜像层。 OK，现在我们的Dockerfile就编写完成了，只需要完成一次构建即可： 1docker build -t &lt;镜像名称&gt; &lt;构建目录&gt; 执行后，Docker会在构建目录中寻找Dockerfile文件，然后开始依次执行Dockerfile中的指令： 构建过程的每一步都非常清晰地列出来了，一共三条指令对应三步依次进行，我们稍微等待一段时间进行安装，安装过程中所以的日志信息会直接打印到控制台（注意Docker镜像构建有缓存机制，就算你现在中途退出了，然后重新进行构建，也会直接将之前已经构建好的每一层镜像，直接拿来用，除非修改了Dockerfile文件重新构建，只要某一层发生变化其上层的构建缓存都会失效，当然包括pull时也会有类似的机制） 最后成功安装，会出现在本地： 可以看到安装出来的大小跟我们之前的是一样的，因为做的事情是一模一样的。我们可以使用history命令来查看构建历史： 可以看到最上面两层是我们通过使用apt命令生成的内容，就直接作为当前镜像中的两层镜像，每层镜像都有一个自己的ID，不同的镜像大小也不一样。而我们手动通过commit命令来生成的镜像没有这个记录： 如果遇到镜像ID为missing的一般是从Docker Hub中下载的镜像会有这个问题，但是问题不大。用我们自己构建的镜像来创建容器就可以直接体验带Java环境的容器了： 有关Dockerfile的其他命令，我们还会在后续的学习中逐步认识。 发布镜像到远程仓库前面我们学习了如何构建一个Docker镜像，我们可以将自己的镜像发布到Docker Hub中，就像Git远程仓库一样，我们可以将自己的镜像上传到这里：https://hub.docker.com/repositories，没有账号的先去进行注册。 点击右上角的创建仓库，然后填写信息： 创建完成后，我们就有了一个公共的镜像仓库，我们可以将本地的镜像上传了，上传之前我们需要将镜像名称修改得规范一点，这里使用tag命令来重新打标签： 1docker tag ubuntu-java-file:latest 用户名/仓库名称:版本 这里我们将版本改成1.0版本吧，不用默认的latest了。 修改完成后，会创建一个新的本地镜像，名称就是我们自己定义的了。接着我们需在本地登录一下： 登录成功后我们就可以上传了： 1docker push nagocoler/ubuntu-java:1.0 哈哈，500M的东西传上去，还是有点压力的，如果实在太慢各位可以重新做一个简单点的镜像。上传完成后，打开仓库，可以看到已经有一个1.0版本了： 注意公共仓库是可以被搜索和下载的，所以我们这里把本地的镜像全部删掉，去下载我们刚刚上传好的镜像。这里我们先搜索一下，搜索使用search命令即可： 1docker search nagocoler/ubuntu-java 我们可以使用pull命令将其下载下来： 1docker pull nagocoler/ubuntu-java:1.0 上传之后的镜像是被压缩过的，所以下载的内容就比较少一些。运行试试看： 当然各位也可以让自己的同学或是在其他机器上尝试下载自己的镜像，看看是不是都可以正常运行。 Docker Hub也可以自行搭建私服，但是这里就不多做介绍了，至此，有关容器和镜像的一些基本操作就讲解得差不多了。 实战：使用IDEA构建SpringBoot程序镜像这里我们创建一个新的SpringBoot项目，现在我们希望能够使用Docker快速地将我们的SpringBoot项目部署到安装了Docker的服务器上，我们就可以将其打包为一个Docker镜像。 先创建好一个项目让它跑起来，可以正常运行就没问题了，接着我们需要将其打包为Docker镜像，这里创建一个新的Dockerfile： 12FROM ubuntuRUN apt update &amp;&amp; apt install -y openjdk-8-jdk 首先还是基于ubuntu构建一个带Java环境的系统镜像，接着我们先将其连接到我们的Docker服务器进行构建，由于IDEA自带了Docker插件，所以我们直接点击左上角的运行按钮，选择第二项 “为Dockerfile构建镜像”： 这里需要配置Docker的服务器，也就是我们在Ubuntu服务器安装的Docker，这里我们填写服务器相关信息，我们首选需要去修改一下Docker的一些配置，开启远程客户端访问： 1sudo vim /etc/systemd/system/multi-user.target.wants/docker.service 打开后，添加高亮部分： 修改完成后，重启Docker服务，如果是云服务器，记得开启2375 TCP连接端口： 12sudo systemctl daemon-reloadsudo systemctl restart docker.service 现在接着在IDEA中进行配置： 在引擎API URL处填写我们Docker服务器的IP地址： tcp://IP:2375 显示连接成功后，表示配置正确，点击保存即可，接着就开始在我们的Docker服务器上进行构建了： 最后成功构建： 可以看到，Docker服务器上已经有了我们刚刚构建好的镜像： 不过名称没有指定，这里我们重新配置一下： 重新进行构建，就是我们自定义的名称了： 我们来创建一个容器试试看： 好了，现在基本环境搭建好了，我们接着就需要将我们的SpringBoot项目打包然后再容器启动时运行了，打开Maven执行打包命令： 接着我们需要编辑Dockerfile，将我们构建好的jar包放进去： 1COPY target/DockerTest-0.0.1-SNAPSHOT.jar app.jar 这里需要使用COPY命令来将文件拷贝到镜像中，第一个参数是我们要拷贝的本地文件，第二个参数是存放在Docker镜像中的文件位置，由于还没有学习存储管理，这里我们直接输入app.jar直接保存在默认路径即可。 接着我们就需要指定在启动时运行我们的Java程序，这里使用CMD命令来完成： 12345FROM ubuntuRUN apt update &amp;&amp; apt install -y openjdk-8-jdkCOPY target/DockerTest-0.0.1-SNAPSHOT.jar app.jarCMD java -jar app.jar# EXPOSE 8080 CMD命令可以设定容器启动后执行的命令，EXPOSE可以指定容器需要暴露的端口，但是现在我们还没有学习网络相关的知识，所以暂时不使用，这里指定为我们启动Java项目的命令。配置完成后，重新构建： 可以看到历史中已经出现新的步骤了： 接着启动我们的镜像，我们可以直接在IDEA中进行操作，不用再去敲命令了，有点累： 启动后可以在右侧看到容器启动的日志信息： 但是我们发现启动之后并不能直接访问，这是为什么呢？这是因为容器内部的网络和外部网络是隔离的，我们如果想要访问容器内的服务器，需要将对应端口绑定到宿主机上，让宿主主机也开启这个端口，这样才能连接到容器内： 1docker run -p 8080:8080 -d springboot-test:1.0 这里-p表示端口绑定，将Docker容器内的端口绑定到宿主机的端口上，这样就可以通过宿主的8080端口访问到容器的8080端口了（有关容器网络管理我们还会在后面进行详细介绍），-d参数表示后台运行，当然直接在IDEA中配置也是可以的： 配置好后，点击重新创建容器： 重新运行后，我们就可以成功访问到容器中运行的SpringBoot项目了： 当然，为了以后方便使用，我们可以直接将其推送到Docker Hub中，这里我们还是创建一个新的公开仓库： 这次我们就使用IDEA来演示直接进行镜像的上传，直接点击： 接着我们需要配置一下我们的Docker Hub相关信息： OK，远程镜像仓库配置完成，直接推送即可，等待推送完成。 可以看到远程仓库中已经出现了我们的镜像，然后IDEA中也可以同步看到： 这样，我们就完成了使用IDEA将SpringBoot项目打包为Docker镜像。 容器网络管理**注意：**本小节学习需要掌握部分《计算机网络》课程中的知识。 前面我们学习了容器和镜像的一些基本操作，了解了如何通过镜像创建容器、然后自己构建容器，以及远程仓库推送等，这一部分我们接着来讨论容器的网络管理。 容器网络类型Docker在安装后，会在我们的主机上创建三个网络，使用network ls命令来查看： 1docker network ls 可以看到默认情况下有bridge、host、none这三种网络类型（其实有点像虚拟机的网络配置，也是分桥接、共享网络之类的），我们先来依次介绍一下，在开始之前我们先构建一个镜像，默认的ubuntu镜像由于啥软件都没有，所以我们把一会网络要用到的先提前装好： 1docker run -it ubuntu 12apt updateapt install net-tools iputils-ping curl 这样就安装好了，我们直接退出然后将其构建为新的镜像： 1docker commit lucid_sammet ubuntu-net OK，一会我们就可以使用了。 **none网络：**这个网络除了有一个本地环回网络之外，就没有其他的网络了，我们可以在创建容器时指定这个网络。 这里使用--network参数来指定网络： 1docker run -it --network=none ubuntu-net 进入之后，我们可以直接查看一下当前的网络： 1ifconfig 可以看到只有一个本地环回lo网络设备： 所以这个容器是无法连接到互联网的： “真”单机运行，可以说是绝对的安全，没人能访问进去，存点密码这些还是不错的。 **bridge网络：**容器默认使用的网络类型，这是桥接网络，也是应用最广泛的网络类型： 实际上我们在宿主主机上查看网络信息，会发现有一个名为docker0的网络设备： 这个网络设备是Docker安装时自动创建的虚拟设备，它有什么用呢？我们可以来看一下默认创建的容器内部的情况： 1docker run -it ubuntu-net 可以看到容器的网络接口地址为172.17.0.2，实际上这是Docker创建的虚拟网络，就像容器单独插了一根虚拟的网线，连接到Docker创建的虚拟网络上，而docker0网络实际上作为一个桥接的角色，一头是自己的虚拟子网，另一头是宿主主机的网络。 网络拓扑类似于下面这样： 通过添加这样的网桥，我们就可以对容器的网络进行管理和控制，我们可以使用network inspect命令来查看docker0网桥的配置信息： 1docker network inspect bridge 这里的配置的子网是172.17.0.0，子网掩码是255.255.0.0，网关是172.17.0.1，也就是docker0这个虚拟网络设备，所以我们上面创建的容器就是这个子网内分配的地址172.17.0.2了。 之后我们还会讲解如何管理和控制容器网络。 **host网络：**当容器连接到此网络后，会共享宿主主机的网络，网络配置也是完全一样的： 1docker run -it --network=host ubuntu-net 可以看到网络列表和宿主主机的列表是一样的，不知道各位有没有注意到，连hostname都是和外面一模一样的： 只要宿主主机能连接到互联网，容器内部也是可以直接使用的： 这样的话，直接使用宿主的网络，传输性能基本没有什么折损，而且我们可以直接开放端口等，不需要进行任何的桥接： 12apt install -y systemctl nginxsystemctl start nginx 安装Nginx之后直接就可以访问了，不需要开放什么端口： 相比桥接网络就方便得多了。 我们可以根据实际情况，来合理地选择这三种网络使用。 用户自定义网络除了前面我们介绍的三种网络之外，我们也可以自定义自己的网络，让容器连接到这个网络。 Docker默认提供三种网络驱动：bridge、overlay、macvlan，不同的驱动对应着不同的网络设备驱动，实现的功能也不一样，比如bridge类型的，其实就和我们前面介绍的桥接网络是一样的。 我们可以使用network create来试试看： 1docker network create --driver bridge test 这里我们创建了一个桥接网络，名称为test： 可以看到新增了一个网络设备，这个就是一会负责我们容器网络的网关了，和之前的docker0是一样的： 1docker network inspect test 这里我们创建一个新的容器，使用此网络： 1docker run -it --network=test ubuntu-net 成功得到分配的IP地址，是在这个网络内的，注意不同的网络之间是隔离的，我们可以再创建一个容器试试看： 可以看到不同的网络是相互隔离的，无法进行通信，当然我们也为此容器连接到另一个容器所属的网络下： 1docker network connect test 容器ID/名称 这样就连接了一个新的网络： 可以看到容器中新增了一个网络设备连接到我们自己定义的网络中，现在这两个容器在同一个网络下，就可以相互ping了： 这里就不介绍另外两种类型的网络了，他们是用于多主机通信的，目前我们只学习单机使用。 容器间网络我们首先来看看容器和容器之间的网络通信，实际上我们之前已经演示过ping的情况了，现在我们创建两个ubuntu容器： 1docker run -it ubuntu-net 先获取其中一个容器的网络信息： 我们可以直接在另一个容器中ping这个容器： ![image-20220702175444713](&#x2F;Users&#x2F;nagocoler&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220702175444713.png) 可以看到能够直接ping通，因为这两个容器都是使用的bridge网络，在同一个子网中，所以可以互相访问。 我们可以直接通过容器的IP地址在容器间进行通信，只要保证两个容器处于同一个网络下即可，虽然这样比较方便，但是大部分情况下，容器部署之后的IP地址是自动分配的（当然也可以使用--ip来手动指定，但是还是不方便），我们无法提前得知IP地址，那么有没有一直方法能够更灵活一些呢？ 我们可以借助Docker提供的DNS服务器，它就像是一个真的DNS服务器一样，能够对域名进行解析，使用很简单，我们只需要在容器启动时给个名字就行了，我们可以直接访问这个名称，最后会被解析为对应容器的IP地址，但是注意只会在我们用户自定义的网络下生效，默认的网络是不行的： 12docker run -it --name=test01 --network=test ubuntu-netdocker run -it --name=test02 --network=test ubuntu-net 接着直接ping对方的名字就可以了： 可以看到名称会自动解析为对应的IP地址，这样的话就不用担心IP不确定的问题了。 当然我们也可以让两个容器同时共享同一个网络，注意这里的共享是直接共享同一个网络设备，两个容器共同使用一个IP地址，只需要在创建时指定： 1docker run -it --name=test01 --network=container:test02 ubuntu-net 这里将网络指定为一个容器的网络，这样两个容器使用的就是同一个网络了： 可以看到两个容器的IP地址和网卡的Mac地址是完全一样的，它们的网络现在是共享状态，此时在容器中访问，localhost，既是自己也是别人。 我们可以在容器1中，安装Nginx，然后再容器2中访问： 12apt install -y systemctl nginxsystemctl start nginx 成功访问到另一个容器中的Nginx服务器。 容器外部网络前面我们介绍了容器之间的网络通信，我们接着来看容器与外部网络的通信。 首先我们来看容器是如何访问到互联网的，在默认的三种的网络下，只有共享模式和桥接模式可以连接到外网，共享模式实际上就是直接使用宿主主机的网络设备连接到互联网，这里我们主要来看一下桥接模式。 通过前面的学习，我们了解到桥接模式实际上就是创建一个单独的虚拟网络，让容器在这个虚拟网络中，然后通过桥接器来与外界相连，那么数据包是如何从容器内部的网络到达宿主主机再发送到互联网的呢？实际上整个过程中最关键的就是依靠NAT（Network Address Translation）将地址进行转换，再利用宿主主机的IP地址发送数据包出去。 这里我们就来补充一下《计算机网络》课程中学习的NAT： 实际上NAT在我们生活中也是经常见到的，比如我们要访问互联网上的某个资源，要和服务器进行通信，那么就需要将数据包发送出去，同时服务器也要将数据包发送回来，我们可以知道服务器的IP地址，也可以直接去连接，因为服务器的IP地址是暴露在互联网上的，但是我们的局域网就不一样了，它仅仅局限在我们的家里，比如我们连接了家里的路由器，可以得到一个IP地址，但是你会发现，这个IP公网是无法直接访问到我们的，因为这个IP地址仅仅是一个局域网的IP地址，俗称内网IP，既然公网无法访问到我们，那服务器是如何将数据包发送给我们的呢？ 实际上这里就借助了NAT在帮助我们与互联网上的服务器进行通信，通过NAT，可以实现将局域网的IP地址，映射为对应的公网IP地址，而NAT设备一端连接外网，另一端连接内网的所有设备，当我们想要与外网进行通信时，就可以将数据包发送给NAT设备，由它来将数据包的源地址映射为它在外网上的地址，这样服务器就能够发现它了，能够直接与它建立通信。当服务器发送数据回来时，也是直接交给NAT设备，然后再根据地址映射，转发给对应的内网设备（当然由于公网IP地址有限，所以一般采用IP+端口结合使用的形式ANPT） 所以你打开百度直接搜IP，会发现这个IP地址并不是你本地的，而是NAT设备的公网地址： 实际上我们家里的路由器一般都带有NAT功能，默认开启NAT模式，包括我们的小区也是有一个NAT设备在进行转换的，这样你的电脑才能在互联网的世界中遨游。当然NAT也可以保护内网的设备不会直接暴露在公网，这样也会更加的安全，只有当我们主动发起连接时，别人才能知道我们。 当然，我们的Docker也是这样的，实际上内网的数据包想要发送到互联网上去，那么就需要经过这样的一套流程： 这样，Docker容器使用的内网就可以和外网进行通信了。 但是这样有一个问题，单纯依靠NAT的话，只有我们主动与外界联系时，外界才能知道我们，但是现在我们的容器中可能会部署一些服务，需要外界来主动连接我们，此时该怎么办呢？ 我们可以直接在容器时配置端口映射，还记得我们在第一节课部署Nginx服务器吗？ 1docker run -d -p 80:80 nginx 这里的-p参数实际上是进行端口映射配置，端口映射可以将容器需要对外提供服务的端口映射到宿主主机的端口上，这样，当外部访问到宿主主机的对应端口时，就会直接转发给容器内映射的端口了。规则为宿主端口:容器端口，这里配置的是将容器的80端口映射到宿主主机的80端口上。 一旦监听到宿主主机的80端口收到了数据包，那么会直接转发给对应的容器。所以配置了端口映射之后，我们才可以从外部正常访问到容器内的服务： 我们也可以直接输入docker ps查看端口映射情况： 至此，有关容器的网络部分，就到此为止，当然这仅仅是单机下的容器网络操作，在以后的课程中，我们还会进一步学习多主机下的网络配置。 容器存储管理前面我们介绍了容器的网络管理，我们现在已经了解了如何配置容器的网络，以及相关的一些原理。还有一个比较重要的部分就是容器的存储，在这一小节我们将深入了解容器的存储管理。 容器持久化存储我们知道，容器在创建之后，实际上我们在容器中创建和修改的文件，实际上是被容器的分层机制保存在最顶层的容器层进行操作的，为了保护下面每一层的镜像不被修改，所以才有了这样的CopyOnWrite特性。但是这样也会导致容器在销毁时数据的丢失，当我们销毁容器重新创建一个新的容器时，所有的数据全部丢失，直接回到梦开始的地方。 在某些情况下，我们可能希望对容器内的某些文件进行持久化存储，而不是一次性的，这里就要用到数据卷（Data Volume）了。 在开始之前我们先准备一下实验要用到的镜像： 12docker run -it ubuntuapt update &amp;&amp; apt install -y vim 然后打包为我们一会要使用的镜像： docker commit 我们可以让容器将文件保存到宿主主机上，这样就算容器销毁，文件也会在宿主主机上保留，下次创建容器时，依然可以从宿主主机上读取到对应的文件。如何做到呢？只需要在容器启动时指定即可： 1mkdir test 我们现在用户目录下创建一个新的test目录，然后在里面随便创建一个文件，再写点内容： 1vim test/hello.txt 接着我们就可以将宿主主机上的目录或文件挂载到容器的某个目录上： 1docker run -it -v ~/test:/root/test ubuntu-volume 这里用到了一个新的参数-v，用于指定文件挂载，这里是将我们刚刚创建好的test目录挂在到容器的&#x2F;root&#x2F;test路径上。 这样我们就可以直接在容器中访问宿主主机上的文件了，当然如果我们对挂载目录中的文件进行编辑，那么相当于编辑的是宿主主机的数据： 1vim /root/test/test.txt 在宿主主机的对应目录下，可以直接访问到我们刚刚创建好的文件。 接着我们来将容器销毁，看看当容器不复存在时，挂载的数据时候还能保留： 可以看到，即使我们销毁了容器，在宿主主机上的文件依然存在，并不会受到影响，这样的话，当我们下次创建新的镜像时，依然可以使用这些保存在外面的文件。 比如我们现在想要部署一个Nginx服务器来代理我们的前端，就可以直接将前端页面保存到宿主主机上，然后通过挂载的形式让容器中的Nginx访问，这样就算之后Nginx镜像有升级，需要重新创建，也不会影响到我们的前端页面。这里我们来测试一下，我们先将前端模板上传到服务器： 1scp Downloads/moban5676.zip 192.168.10.10:~/ 然后在服务器上解压一下： 1unzip moban5676.zip 接着我们就可以启动容器了： 1docker run -it -v ~/moban5676:/usr/share/nginx/html/ -p 80:80 -d nginx 这里我们将解压出来的目录，挂载到容器中Nginx的默认站点目录/usr/share/nginx/html/（由于挂在后位于顶层，会替代镜像层原有的文件），这样Nginx就直接代理了我们存放在宿主主机上的前端页面，当然别忘了把端口映射到宿主主机上，这里我们使用的镜像是官方的nginx镜像。 现在我们进入容器将Nginx服务启动： 1systemctl start nginx 然后通过浏览器访问看看是否代理成功： 可以看到我们的前端页面直接被代理了，当然如果我们要编写自定义的配置，也是使用同样的方法操作即可。 注意如果我们在使用-v参数时不指定宿主主机上的目录进行挂载的话，那么就由Docker来自动创建一个目录，并且会将容器中对应路径下的内容拷贝到这个自动创建的目录中，最后挂在到容器中，这种就是由Docker管理的数据卷了（docker managed volume）我们来试试看： 1docker run -it -v /root/abc ubuntu-volume 注意这里我们仅仅指定了挂载路径，没有指定宿主主机的对应目录，继续创建： 创建后可以看到root目录下有一个新的abc目录，那么它具体是在宿主主机的哪个位置呢？这里我们依然可以使用inspect命令： 1docker inspect bold_banzai 可以看到Sorce指向的是/var/lib中的某个目录，我们可以进入这个目录来创建一个新的文件，进入之前记得提升一下权限，权限低了还进不去： 我们来创一个新的文本文档： 实际上和我们之前是一样的，也是可以在容器中看到的，当然删除容器之后，数据依然是保留的。当我们不需要使用数据卷时，可以进行删除： 当然有时候为了方便，可能并不需要直接挂载一个目录上去，仅仅是从宿主主机传递一些文件到容器中，这里我们可以使用cp命令来完成： 这个命令支持从宿主主机复制文件到容器，或是从容器复制文件到宿主主机，使用方式类似于Linux自带的cp命令。 容器数据共享前面我们通过挂载的形式，将宿主主机上的文件直接挂载到容器中，这样容器就可以直接访问到宿主主机上的文件了，并且在容器删除时也不会清理宿主主机上的文件。 我们接着来看看如何实现容器与容器之间的数据共享，实际上按照我们之前的思路，我们可以在宿主主机创建一个公共的目录，让这些需要实现共享的容器，都挂载这个公共目录： 1docker run -it -v ~/test:/root/test ubuntu-volume 由于挂载的是宿主主机上的同一块区域，所以内容可以直接在两个容器中都能访问。当然我们也可以将另一个容器挂载的目录，直接在启动容器时指定使用此容器挂载的目录： 12docker run -it -v ~/test:/root/test --name=data_test ubuntu-volumedocker run -it --volumes-from data_test ubuntu-volume 这里使用--volumes-from指定另一个容器（这种用于给其他容器提供数据卷的容器，我们一般称为数据卷容器） 可以看到，数据卷容器中挂载的内容，在当前容器中也是存在的，当然就算此时数据卷容器被删除，那么也不会影响到这边，因为这边相当于是继承了数据卷容器提供的数据卷，所以本质上还是让两个容器挂载了同样的目录实现数据共享。 虽然通过上面的方式，可以在容器之间实现数据传递，但是这样并不方便，可能某些时候我们仅仅是希望容器之间共享，而不希望有宿主主机这个角色直接参与到共享之中，此时我们就需要寻找一种更好的办法了。其实我们可以将数据完全放入到容器中，通过构建一个容器，来直接将容器中打包好的数据分享给其他容器，当然本质上依然是一个Docker管理的数据卷，虽然还是没有完全脱离主机，但是移植性就高得多了。 我们来编写一个Dockerfile： 123FROM ubuntuADD moban5676.tar.gz /usr/share/nginx/html/VOLUME /usr/share/nginx/html/ 这里我们使用了一个新的指令ADD，它跟COPY命令类似，也可以复制文件到容器中，但是它可以自动对压缩文件进行解压，这里只需要将压缩好的文件填入即可，后面的VOLUME指令就像我们使用-v参数一样，会创建一个挂载点在容器中： 1234cd testtar -zcvf moban5676.tar.gz *mv moban5676.tar.gz ..cd .. 接着我们直接构建： 1docker build -t data . 现在我们运行一个容器看看： 可以看到所有的文件都自动解压出来了（除了中文文件名称乱码了之外，不过无关紧要）我们退出容器，可以看到数据卷列表中新增了我们这个容器需要使用的： 这个位置实际上就是数据存放在当前主机上的位置了，不过是由Docker进行管理而不是我们自定义的。现在我们就可以创建一个新的容器直接继承了： 1docker run -p 80:80 --volumes-from=data_test -d nginx 访问一下Nginx服务器，可以看到成功代理： 这样我们就实现了将数据放在容器中进行共享，我们不需要刻意去指定宿主主机的挂载点，而是Docker自行管理，这样就算迁移主机依然可以快速部署。 容器资源管理前面我们已经完成Docker的几个主要模块的学习，最后我们来看看如何对容器的资源进行管理。 容器控制操作在开始之前，我们还是要先补充一些我们前面没有提到的其他容器命令。 首先我们的SpringBoot项目在运行是，怎么查看输出的日志信息呢？ 1docker logs test 这里使用log命令来打印容器中的日志信息： 当然也可以添加-f参数来持续打印日志信息。 现在我们的容器已经启动了，但是我们想要进入到容器监控容器的情况怎么办呢？我们可以是attach命令来附加到容器启动命令的终端上： 1docker attach 容器ID/名称 注意现在就切换为了容器内的终端，如果想要退出的话，需要先按Ctrl+P然后再按Ctrl+Q来退出终端，不能直接使用Ctrl+C来终止，这样会直接终止掉Docker中运行的Java程序的。 退出后，容器依然是处于运行状态的。 我们也可以使用exec命令在容器中启动一个新的终端或是在容器中执行命令： 1docker exec -it test bash -it和run命令的操作是一样的，这里执行后，会创建一个新的终端（当然原本的程序还是在正常运行）我们会在一个新的终端中进行交互： 当然也可以仅仅在容器中执行一条命令： 执行后会在容器中打开一个新的终端执行命令，并输出结果。 前面我们还学习了容器的停止操作，通过输入stop命令来停止容器，但是此操作并不会立即停止，而是会等待容器处理善后，那么怎么样才能强制终止容器呢？我们可以直接使用kill命令，相当于给进程发送SIGKILL信号，强制结束。 1docker kill test 相比stop命令，kill就没那么温柔了。 有时候可能只是希望容器暂时停止运行，而不是直接终止运行，我们希望在未来的某个时间点，恢复容器的运行，此时就可以使用pause命令来暂停容器： 1docker pause test 暂停容器后，程序暂时停止运行，无法响应浏览器发送的请求： 此时处于爱的魔力转圈圈状态，我们可以将其恢复运行，使用unpause命令： 1docker unpause test 恢复运行后，瞬间就响应成功了。 物理资源管理对于一个容器，在某些情况下我们可能并不希望它占据所有的系统资源来运行，我们只希望分配一部分资源给容器，比如只分配给容器2G内存，最大只允许使用2G，不允许再占用更多的内存，此时我们就需要对容器的资源进行限制。 1docker run -m 内存限制 --memory-swap=内存和交换分区总共的内存限制 镜像名称 其中-m参数是对容器的物理内存的使用限制，而--memory-swap是对内存和交换分区总和的限制，它们默认都是-1，也就是说没有任何的限制（如果在一开始仅指定-m参数，那么交换内存的限制与其保持一致，内存+交换等于-m的两倍大小）默认情况下跟宿主主机一样，都是2G内存，现在我们可以将容器的内存限制到100M试试看，其中物理内存50M，交换内存50M，尝试启动一下SpringBoot程序： 1docker run -it -m 50M --memory-swap=100M nagocoler/springboot-test:1.0 可以看到，上来就因为内存不足无法启动了： 当然除了对内存的限制之外，我们也可以对CPU资源进行限额，默认情况下所有的容器都可以平等地使用CPU资源，我们可以调整不同的容器的CPU权重（默认为1024），来按需分配资源，这里需要使用到-c选项，也可以输入全名--cpu-share： 12docker run -c 1024 ubuntudocker run -c 512 ubuntu 这里容器的CPU权重比例为16比8，也就是2比1（注意多个容器时才会生效），那么当CPU资源紧张时，会按照此权重来分配资源，当然如果CPU资源并不紧张的情况下，依然是有机会使用到全部的CPU资源的。 这里我们使用一个压力测试工具来进行验证： 12docker run -c 1024 --name=cpu1024 -it ubuntudocker run -c 512 --name=cpu512 -it ubuntu 接着我们分别进入容器安装stress压力测试工具： 1apt update &amp;&amp; apt install -y stress 接着我们分别在两个容器中都启动压力测试工具，产生4个进程不断计算随机数的平方根： 1stress -c 4 接着我们进入top来看看CPU状态（看完之后记得赶紧去kill掉容器，不然CPU拉满很卡的）： 可以看到权重高的容器中，分配到了更多的CPU资源，而权重低的容器中，只分配到一半的CPU资源。 当然我们也可以直接限制容器使用的CPU数量： 1docker run -it --cpuset-cpus=1 ubuntu --cpuset-cpus选项可以直接限制在指定的CPU上运行，比如现在我们的宿主机是2核的CPU，那么就可以分0和1这两个CPU给Docker使用，限制后，只会使用CPU 1的资源了： 可以看到，4个进程只各自使用了25%的CPU，加在一起就是100%，也就是只能占满一个CPU的使用率。如果要分配多个CPU，则使用逗号隔开： 1docker run -it --cpuset-cpus=0,1 ubuntu 这样就会使用这两个CPU了： 当然也可以直接使用--cpus来限制使用的CPU资源数： 1docker run -it --cpus=1 ubuntu 限制为1后，只能使用一个CPU提供的资源，所以这里加载一起只有一个CPU的资源了。当然还有更精细的--cpu-period 和--cpu-quota，这里就不做介绍了。 最后我们来看一下对磁盘IO读写性能的限制，我们首先使用dd命令来测试磁盘读写速度： 1dd if=/dev/zero of=/tmp/1G bs=4k count=256000 oflag=direct 可以不用等待跑完，中途Ctrl+C结束就行： 可以看到当前的读写速度为86.4 MB&#x2F;s，我们可以通过--device-read/write-bps和--device-read/write-iops参数对其进行限制。 这里要先说一下区别： bps：每秒读写的数据量。 iops：每秒IO的次数。 为了直观，这里我们直接使用BPS作为限制条件： 1docker run -it --device-write-bps=/dev/sda:10MB ubuntu 因为容器的文件系统是在/dev/sda上的，所以这我们就/dev/sda:10MB来限制对&#x2F;dev&#x2F;sda的写入速度只有10MB&#x2F;s，我们来测试一下看看： 可以看到现在的速度就只有10MB左右了。 容器监控最后我们来看看如何对容器的运行状态进行实时监控，我们现在希望能够对容器的资源占用情况进行监控，该怎么办呢？ 我们可以使用stats命令来进行监控： 1docker stats 可以实时对容器的各项状态进行监控，包括内存使用、CPU占用、网络I&#x2F;O、磁盘I&#x2F;O等信息，当然如果我们限制内存的使用的话： 1docker run -d -m 200M nagocoler/springboot-test:1.0 可以很清楚地看到限制情况： 除了使用stats命令来实时监控情况之外，还可以使用top命令来查看容器中的进程： 1docker top 容器ID/名称 当然也可以携带一些参数，具体的参数与Linux中ps命令参数一致，这里就不多做介绍了。 但是这样的监控是不是太原始了一点？有没有那种网页面板可以进行实时监控和管理的呢？有的。 我们需要单独部署一个Docker网页管理面板应用，一般比较常见的有：Portainer，我们这里可以直接通过Docker镜像的方式去部署这个应用程序，搜索一下，发现最新版维护的地址为：https://hub.docker.com/r/portainer/portainer-ce CE为免费的社区版本，当然也有BE商业版本，这里我们就直接安装社区版就行了，官方Linux安装教程：https://docs.portainer.io/start/install/server/docker/linux，包含一些安装前需要的准备。 首先我们需要创建一个数据卷供Portainer使用： 1docker volume create portainer_data 接着通过官方命令安装启动： 1docker run -d -p 8000:8000 -p 9443:9443 --name portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:latest 注意这里需要开放两个端口，一个是8000端口，还有一个是9443端口。 OK，开启成功，我们可以直接登录后台面板：https://IP:9443/，这里需要HTTPS访问，浏览器可能会提示不安全，无视就行： 进入后就需要我们进行注册了，这里我们只需输入两次密码即可，默认用户名就是admin，填写完成后，我们就可以开始使用了： 点击Get Started即可进入到管理页面，我们可以看到目前有一个本地的Docker服务器正在运行： 我们可以点击进入，进行详细地管理，不过唯一缺点就是没中文，挺难受的，也可以使用非官方的汉化版本：https://hub.docker.com/r/6053537/portainer-ce。 单机容器编排最后我们来讲解一下Docker-Compose，它能够对我们的容器进行编排。比如现在我们要在一台主机上部署很多种类型的服务，包括数据库、消息队列、SpringBoot应用程序若干，或是想要搭建一个MySQL集群，这时我们就需要创建多个容器来完成来，但是我们希望能够实现一键部署，这时该怎么办呢？我们就要用到容器编排了，让多个容器按照我们自己的编排进行部署。 **官方文档：**https://docs.docker.com/get-started/08_using_compose/，视频教程肯定不可能把所有的配置全部介绍完，所以如果各位小伙伴想要了解更多的配置，有更多需求的话，可以直接查阅官方文档。 快速开始在Linux环境下我们需要先安装一下插件： 1sudo apt install docker-compose-plugin 接着输入docker compose version来验证一下是否安装成功。 这里我们就以部署SpringBoot项目为例，我们继续使用之前打包好的SpringBoot项目，现在我们希望部署这个SpringBoot项目的同时，部署一个MySQL服务器，一个Redis服务器，这时我们SpringBoot项目要运行的整个完整环境，先获取到对应的镜像： 12docker pull mysql/mysql-serverdocker pull redis 接着，我们需要在自己的本地安装一下DockerCompose，下载地址：https://github.com/docker/compose/releases，下载自己电脑对应的版本，然后在IDEA中配置： 下载完成后，将Docker Compose可执行文件路径修改为你存放刚刚下载的可执行文件的路径，Windows直接设置路径就行，MacOS下载之后需要进行下面的操作： 123mv 下载的文件名称 docker-composesudo chmod 777 docker-composesudo mv docker-compose /usr/local/bin 配置完成后就可以正常使用了，否则会无法运行，接着我们就可以开始在IDEA中编写docker-compose.yml文件了。 这里点击右上角的“与服务工具窗口同步”按钮，这样一会就可以在下面查看情况了。 我们现在就从头开始配置这个文件，现在我们要创建三个服务，一个是MySQL服务器，一个是Redis服务器，还有一个是SpringBoot服务器，需要三个容器来分别运行，首先我们先写上这三个服务： 12345678version: &quot;3.9&quot; #首先是版本号，别乱写，这个是和Docker版本有对应的services: #services里面就是我们所有需要进行编排的服务了 spring: #服务名称，随便起 container_name: app_springboot #一会要创建的容器名称 mysql: container_name: app_mysql redis: container_name: app_redis 这样我们就配置好了一会要创建的三个服务和对应的容器名称，接着我们需要指定一下这些容器对应的镜像了，首先是我们的SpringBoot应用程序，可能我们后续还会对应用程序进行更新和修改，所以这里我们部署需要先由Dockerfile构建出镜像后，再进行部署： 123spring: container_name: app_springboot build: . #build表示使用构建的镜像，.表示使用当前目录下的Dockerfile进行构建 我们这里修改一下Dockerfile，将基础镜像修改为已经打包好JDK环境的镜像： 123FROM adoptopenjdk/openjdk8COPY target/DockerTest-0.0.1-SNAPSHOT.jar app.jarCMD java -jar app.jar 接着是另外两个服务，另外两个服务需要使用对应的镜像来启动容器： 123456mysql: container_name: app_mysql image: mysql/mysql-server:latest #image表示使用对应的镜像，这里会自动从仓库下载，然后启动容器redis: container_name: app_redis image: redis:latest 还没有结束，我们还需要将SpringBoot项目的端口进行映射，最后一个简单的docker-compose配置文件就编写完成了： 12345678910111213version: &quot;3.9&quot; #首先是版本号，别乱写，这个是和Docker版本有对应的services: #services里面就是我们所有需要进行编排的服务了 spring: #服务名称，随便起 container_name: app_springboot #一会要创建的容器名称 build: . ports: - &quot;8080:8080&quot; mysql: container_name: app_mysql image: mysql/mysql-server:latest redis: container_name: app_redis image: redis:latest 现在我们就可以直接一键部署了，我们点击下方部署按钮： 看到 Running 4&#x2F;4 就表示已经部署成功了，我们现在到服务器这边来看看情况： 可以看到，这里确实是按照我们的配置，创建了3个容器，并且都是处于运行中，可以正常访问： 如果想要结束的话，我们只需要点击停止就行了： 当然如果我们不再需要这套环境的话，可以直接点击下方的按钮，将整套编排给down掉，这样的话相对应的容器也会被清理的： 注意在使用docker-compose部署时，会自动创建一个新的自定义网络，并且所有的容器都是连接到这个自定义的网络里面： 这个网络默认也是使用bridge作为驱动： 这样，我们就完成了一个简单的配置，去部署我们的整套环境。 部署完整项目前面我们学习了使用docker-compose进行简单部署，但是仅仅只是简单启动了服务，我们现在来将这些服务给连起来。首先是SpringBoot项目，我们先引入依赖： 123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 接着配置一下数据源，等等，我们怎么知道数据库的默认密码是多少呢？所以我们先配置一下MySQL服务： 12345678910mysql: container_name: app_mysql image: mysql/mysql-server:latest environment: #这里我们通过环境变量配置MySQL的root账号和密码 MYSQL_ROOT_HOST: &#x27;%&#x27; #登陆的主机，这里直接配置为&#x27;%&#x27; MYSQL_ROOT_PASSWORD: &#x27;123456.root&#x27; #MySQL root账号的密码，别设定得太简单了 MYSQL_DATABASE: &#x27;study&#x27; #在启动时自动创建的数据库 TZ: &#x27;Asia/Shanghai&#x27; #时区 ports: - &quot;3306:3306&quot; #把端口暴露出来，当然也可以不暴露，因为默认所有容器使用的是同一个网络 有关MySQL的详细配置请查阅：https://registry.hub.docker.com/_/mysql 接着我们将数据源配置完成： 123456spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://app_mysql:3306/study #地址直接输入容器名称，会自动进行解析，前面已经讲过了 username: root password: 123456.root 然后我们来写点测试的代码吧，这里我们使用JPA进行交互： 123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt; 1234567891011121314151617@Data@AllArgsConstructor@NoArgsConstructor@Entity@Table(name = &quot;db_account&quot;)public class Account &#123; @Column(name = &quot;id&quot;) @Id long id; @Column(name = &quot;name&quot;) String name; @Column(name = &quot;password&quot;) String password;&#125; 1234@Repositorypublic interface AccountRepository extends JpaRepository&lt;Account, Long&gt; &#123;&#125; 1234567891011121314151617181920212223@RestControllerpublic class MainController &#123; @Resource AccountRepository repository; @RequestMapping(&quot;/&quot;) public String hello()&#123; return &quot;Hello World!&quot;; &#125; @GetMapping(&quot;/get&quot;) public Account get(@RequestParam(&quot;id&quot;) long id)&#123; return repository.findById(id).orElse(null); &#125; @PostMapping(&quot;/post&quot;) public Account get(@RequestParam(&quot;id&quot;) long id, @RequestParam(&quot;name&quot;) String name, @RequestParam(&quot;password&quot;) String password)&#123; return repository.save(new Account(id, name, password)); &#125;&#125; 接着我们来修改一下配置文件： 1234567891011spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://app_mysql:3306/study username: root password: 123456.root jpa: database: mysql show-sql: true hibernate: ddl-auto: update #这里自动执行DDL创建表，全程自动化，尽可能做到开箱即用 现在代码编写完成后，我们可以将项目打包了，注意执行我们下面的打包命令，不要进行测试，因为连不上数据库： 1mvn package -DskipTests 重新生成jar包后，我们修改一下docker-compose配置，因为MySQL的启动速度比较慢，我们要一点时间等待其启动完成，如果连接不上数据库导致SpringBoot项目启动失败，我们就重启： 12345678spring: #服务名称，随便起 container_name: app_springboot #一会要创建的容器名称 build: . ports: - &quot;8080:8080&quot; depends_on: #这里设置一下依赖，需要等待mysql启动后才运行，但是没啥用，这个并不是等到启动完成后，而是进程建立就停止等待 - mysql restart: always #这里配置容器停止后自动重启 然后我们将之前自动构建的镜像删除，等待重新构建： 现在我们重新部署docker-compos吧： 当三个服务全部为蓝色时，就表示已经正常运行了，现在我们来测试一下吧： 接着我们来试试看向数据库传入数据： 可以看到响应成功，接着我们来请求一下： 这样，我们的项目和MySQL基本就是自动部署了。 接着我们来配置一下Redis： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 接着配置连接信息： 12345678910111213spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://app_mysql:3306/study username: root password: 123456.root jpa: database: mysql show-sql: true hibernate: ddl-auto: update redis: host: app_redis 123456789101112131415//再加两个Redis操作进来@ResourceStringRedisTemplate template;@GetMapping(&quot;/take&quot;)public String take(@RequestParam(&quot;key&quot;) String key)&#123; return template.opsForValue().get(key);&#125;@PostMapping(&quot;/put&quot;)public String put(@RequestParam(&quot;key&quot;) String key, @RequestParam(&quot;value&quot;) String value)&#123; template.opsForValue().set(key, value); return &quot;操作成功！&quot;;&#125; 最后我们来配置一下docker-compose的配置文件： 12345redis: container_name: app_redis image: redis:latest ports: - &quot;6379:6379&quot; OK，按照之前的方式，我们重新再部署一下，然后测试： 这样我们就完成整套环境+应用程序的配置了，我们在部署整个项目时，只需要使用docker-compose配置文件进行启动即可，这样就大大方便了我们的操作，实现开箱即用。甚至我们还可以专门使用一个平台来同时对多个主机进行一次性配置，大规模快速部署，而这些就留到以后的课程中再说吧。","categories":[{"name":"Docker","slug":"Docker","permalink":"http://example.com/categories/Docker/"}],"tags":[]},{"title":"Java面向对象(高级)","slug":"9a52b66178b746debfe7111574e464a2","date":"2023-01-19T12:23:24.121Z","updated":"2023-01-19T12:23:31.853Z","comments":true,"path":"2023/01/19/9a52b66178b746debfe7111574e464a2/","link":"","permalink":"http://example.com/2023/01/19/9a52b66178b746debfe7111574e464a2/","excerpt":"","text":"Java面向对象(高级)类变量&#x2F;类方法类变量&#x2F;类方法-博客园 类变量快速入门介绍类变量（又叫静态变量）是该类的所有对象共享的变量，任何一个该类的对象去访问它时，取到的都是相同的值，同样任何一个该类的对象去修改它时，修改的也是同一个变量。 定义类变量：访问修饰符 static 数据类型 变量名; 静态变量是类加载的时候，就创建了,所以我们没有创建对象实例定义一个变量 count ,是一个类变量(静态变量) static 静态该变量最大的特点就是会被Child 类的所有的对象实例共享 123456789101112131415161718192021package cn.meowrain.classVariable;public class var01 &#123; public static void main(String[] args) &#123; Child child01 = new Child(&quot;mike&quot;); Child child02 = new Child(&quot;john&quot;); child01.count++; child02.count++; System.out.println(&quot;共有&quot; + Child.count + &quot;个小朋友参加了游戏&quot;); &#125;&#125;class Child &#123; private String name; public static int count = 0; public Child(String name)&#123; this.name = name; &#125; public void join() &#123; System.out.println(&quot;小朋友&quot; + name + &quot;加入了游戏....&quot;); &#125;&#125; 输出: 共有2个小朋友参加了游戏 访问类变量 可以通过 类名.类变量名 或者 对象名.类变量名 来访问，但Java设计者推荐我们使用 类名.类变量名 的方式来访问。 1234567891011121314151617181920212223package cn.meowrain.classVariable;public class var01 &#123; public static void main(String[] args) &#123; Child child01 = new Child(&quot;mike&quot;); Child child02 = new Child(&quot;john&quot;); child01.join(); child02.join(); System.out.println(&quot;共有&quot; + Child.count + &quot;个小朋友参加了游戏&quot;); //通过 对象名.类变量名 来访问 &#125;&#125;class Child &#123; private String name; public static int count = 0; public Child(String name)&#123; this.name = name; &#125; public void join() &#123; System.out.println(&quot;小朋友&quot; + name + &quot;加入了游戏....&quot;); count++; &#125;&#125; 类方法介绍类变量也叫静态变量。定义格式如下：访问修饰符 static 数据返回类型 方法名()&#123;&#125; 类方法经典使用场景（1）当方法中不涉及到任何和对象相关的成员，则可以将方法设计成静态方法，提高开发效率。（2）比如工具类中的方法 utilsMath类、Arrays类、Collections集合类（3）在实际开发中，往往将一些通用的方法，设计成静态方法，这样我们不需要创建对象就可以使用，比如打印一维数组，冒泡排序等等 类方法和普通方法的区别 类方法中不允许使用和对象有关的关键字， 比如this 和super。普通方法(成员方法)可以。 类方法中，只能访问 静态变量 或 静态方法；而普通方法既可以访问普通变量（方法），也可以访问静态的。 类方法可以重写吗？ 可以被继承，但是不能被重写，如果父子类静态方法名相同，则会隐藏derive类方法（调用base类的方法） 静态方法是编译时绑定的，方法重写是运行时绑定的。https://blog.csdn.net/m0_37974032/article/details/81157433 类方法的使用：使用：如下： 1234567891011121314151617181920package cn.meowrain.classVariable;public class var02 &#123;&#125;class Caculate &#123; public static void main(String[] args) &#123; int sum01 = sum(1, 2); int sum02 = sum(5, 10, 20); System.out.println(sum01 + &quot; &quot; + sum02);//3 35 &#125; public static int sum(int a, int b) &#123; return a + b; &#125; public static int sum(int a, int b, int c) &#123; return a + b + c; &#125;&#125; 理解main方法直接看下面这个文章就行了，写得很不错https://www.cnblogs.com/ffforward/p/15253293.html Java代码块基本介绍代码块又称为初始化块，属于类中的成员，类似于方法，把逻辑语句封装在方法体中，通过{}包围起来其在创建对象时隐式调用 基本语法 [修饰符]&#123; 代码 &#125; 说明：(1) 修饰符可选，要写的话，也只能写static (2) 代码块分为两类，使用static修饰的叫静态代码块，没有static修饰的，叫普通代码块 (3) 逻辑语句可以为任何逻辑语句（输入、输出、方法调用、循环、判断等 (4) 分号；可以写上，也可以省略 代码块的好处（1）相当于另外一种形式的构造器（对构造器的补充机制），可以做初始化的操作。 （2）如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的复用性 实际使用： 如下，我们的三个构造器中都含有System.out.println(&quot;Welcome to Code World!&quot;);，这使得代码很冗杂，使用代码块，就能让这个代码更好看一些，代码块会在每次类创建时调用 12345678910111213141516171819202122232425262728293031323334package cn.meowrain.codeBlock;public class code01 &#123; public static void main(String[] args) &#123; code01_child child01 = new code01_child(&quot;mike&quot;); code01_child child02 = new code01_child(&quot;meme&quot;, 15); code01_child child03 = new code01_child(&quot;meow&quot;, 18, &quot;bear&quot;); &#125;&#125;class code01_child &#123; String name; int age; String love; public code01_child(String name) &#123; this.name = name; System.out.println(&quot;Welcome to Code World!&quot;); System.out.println(&quot;hello &quot; + name); &#125; public code01_child(String name, int age) &#123; this.name = name; this.age = age; System.out.println(&quot;Welcome to Code World!&quot;); System.out.println(&quot;hello &quot; + name); &#125; public code01_child(String name,int age,String love) &#123; this.name = name; this.love = love; this.age = age; System.out.println(&quot;Welcome to Code World!&quot;); System.out.println(&quot;hello &quot; + name); &#125; &#125; ·············修改版··················· 12345678910111213141516171819202122232425262728293031323334353637package cn.meowrain.codeBlock;public class code01 &#123; public static void main(String[] args) &#123; code01_child child01 = new code01_child(&quot;mike&quot;); code01_child child02 = new code01_child(&quot;meme&quot;, 15); code01_child child03 = new code01_child(&quot;meow&quot;, 18, &quot;bear&quot;); &#125;&#125;class code01_child &#123; String name; int age; String love; &#123; System.out.println(&quot;Welcome to Code World!&quot;); &#125; public code01_child(String name) &#123; this.name = name; System.out.println(&quot;hello &quot; + name); &#125; public code01_child(String name, int age) &#123; this.name = name; this.age = age; System.out.println(&quot;hello &quot; + name); &#125; public code01_child(String name,int age,String love) &#123; this.name = name; this.love = love; this.age = age; System.out.println(&quot;hello &quot; + name); &#125; &#125; 输出结果： 123456Welcome to Code World!hello mikeWelcome to Code World!hello memeWelcome to Code World!hello meow static 代码块static代码块也叫静态代码块，作用就是对类进行初始化，而且它随着类的加载而执行，并且只会执行一次。 实际使用： 12345678910111213141516171819202122232425262728293031323334353637package cn.meowrain.codeBlock;public class code01 &#123; public static void main(String[] args) &#123; code01_child child01 = new code01_child(&quot;mike&quot;); code01_child child02 = new code01_child(&quot;meme&quot;, 15); code01_child child03 = new code01_child(&quot;meow&quot;, 18, &quot;bear&quot;); &#125;&#125;class code01_child &#123; String name; int age; String love; static&#123; System.out.println(&quot;Welcome to Code World!&quot;); &#125; public code01_child(String name) &#123; this.name = name; System.out.println(&quot;hello &quot; + name); &#125; public code01_child(String name, int age) &#123; this.name = name; this.age = age; System.out.println(&quot;hello &quot; + name); &#125; public code01_child(String name,int age,String love) &#123; this.name = name; this.love = love; this.age = age; System.out.println(&quot;hello &quot; + name); &#125; &#125; 输出结果： 因为静态代码块只执行一次，所以只输出一次 Welcome to Code World! 1234Welcome to Code World!hello mikehello memehello meow 代码块使用注意事项 static代码块也叫静态代码块，作用就是对类进行初始化，而且它随着类的加载而执行，只会执行一次。如果是普通代码块，每创建一个对象，就执行一次。可以看上面的代码和运行结果 类什么时候被加载？ 创建对象实例 new 的时候 创建子类对象实例，父类也会被加载 使用类的静态成员时（静态属性，静态方法）12345678910111213141516171819package cn.meowrain.codeBlock;public class code02 &#123; public static void main(String[] args) &#123; int c = A.sum(109, 10); &#125;&#125;class A &#123; static&#123; System.out.println(&quot;hello&quot;); &#125; public static int sum(int a,int b)&#123; return a+b; &#125;&#125;class B extends A&#123;&#125; 运行结果： hello由上可见,静态代码块会在类加载的时候执行 普通的代码块，在创建对象实例（new的时候），会被隐式调用，如果只是单纯使用类中的静态变量，普通代码块不会被执行1234567891011121314151617181920212223package cn.meowrain.codeBlock;public class code02 &#123; public static void main(String[] args) &#123; int c = A.sum(109, 10); &#125;&#125;class A &#123; &#123; System.out.println(&quot;hello&quot;); &#125; static int a = 10; public static int sum(int a, int b) &#123; return a + b; &#125;&#125;class B extends A &#123;&#125; 输出结果： 无 创建一个对象的时候，在一个类的调用顺序是: 调用静态代码块和静态属性初始化，按照顺序调用 调用普通代码块和普通属性的初始化，按照顺序调用 调用构造方法1234567891011121314151617181920212223242526package cn.meowrain.codeBlock;public class code03 &#123; public static void main(String[] args) &#123; AB ab = new AB(); &#125;&#125;class AB &#123; static &#123; System.out.println(&quot;静态代码块初始化&quot;); &#125; static int a = getN1(); public static int getN1()&#123; System.out.println(&quot;静态方法getN1初始化&quot;); return 100; &#125; int c = getN2(); public int getN2() &#123; System.out.println(&quot;普通方法getN2初始化&quot;); return 200; &#125; public AB()&#123; System.out.println(&quot;构造器被调用&quot;); &#125;&#125; 运行结果如下静态代码块初始化静态方法getN1初始化普通方法getN2初始化构造器被调用 单例设计模式参考https://www.cnblogs.com/ffforward/p/15259948.html 介绍：单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法 单例模式有两种： 饿汉式 懒汉式 实现方式 构造器私有化 类的内部创建对象 向外暴露一个静态的公共方法 饿汉式 类加载的时候实例化，并且创建单例对象 构造器私有化 在类的内部直接创建对象，该对象为static 提供一个公共的static方法，返回这个对象 12345678910111213141516171819package cn.meowrain.singlecasemode;class test &#123; public static void main(String[] args) &#123; Hungry hungry = Hungry.getInstance(); System.out.println(hungry.name); &#125;&#125;public class Hungry &#123; public String name; private Hungry(String name)&#123; this.name = name; &#125; //构造器私有化 private static Hungry hungry = new Hungry(&quot;hello&quot;); public static Hungry getInstance()&#123; return hungry; &#125;&#125; 懒汉式 懒汉式： 默认不会实例化，什么时候用什么时候new 构造器私有化 定义一个static静态属性对象 提供一个public的static方法，可以返回一个该类对象 懒汉式，只有当用户使用getInstance时，才返回对象，后面再次调用时，会返回上次创建的该类对象，从而保证单例 123456789101112131415161718192021package cn.meowrain.singlecasemode;class test02 &#123; public static void main(String[] args) &#123; Lazy lazy = Lazy.getInstanceOf(); System.out.println(lazy.name); &#125;&#125;public class Lazy &#123; public String name; private Lazy(String name)&#123; this.name = name; &#125; private static Lazy lazy = null; public static Lazy getInstanceOf()&#123; if(lazy==null)&#123; lazy = new Lazy(&quot;mmm&quot;); &#125; return lazy; &#125;&#125; 饿汉式和懒汉式的区别（1）二者最主要的区别在于创建对象的时机不同：饿汉式是在类加载时就创建了对象实例，而懒汉式是在使用时才创建。 （2）饿汉式不存在线程安全问题，懒汉式存在线程安全问题。 （3）饿汉式存在浪费资源的可能（没有使用到这个对象实例），而懒汉式不存在这个问题。 （4）在javaSE标准类中，java.lang.Runtime就是经典的单例模式。 final关键字基本介绍：final可以修饰类，属性，方法和局部变量使用环境： 1. 当不希望类被继承时，可以用final修饰 2. 当不希望父类的某个方法被子类覆盖/重写时，可以用final关键字修饰 3. 当不希望类的某个属性的值被修改，可用final修饰 4. 当不希望某个局部变量被修改，可以用final修饰 final使用注意事项 final修饰的属性又叫常量 final修饰的属性在定义的时候，必须赋初值，并且以后不能再修改 如果final修饰的属性是静态的，则初始化的位置只能是 1.定义时 2.在静态代码块中可以赋值，不能在构造器中赋值 final类不能继承，但是可以实例化对象 如果类不是final类，但是有final方法，则该方法虽然不能重写，但可以被继承6.final和static往往搭配使用，效率更高，不会导致类加载，底层编译器做了优化处理 包装类(Integer,Double,Float,Boolean等都是final)，String也是final类 抽象类","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"JAVASE","slug":"Java/JAVASE","permalink":"http://example.com/categories/Java/JAVASE/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"Java面向对象基础（中级）","slug":"274b1dfaf07945e7ab77710afad502a3","date":"2023-01-19T12:23:14.286Z","updated":"2023-01-19T12:23:21.333Z","comments":true,"path":"2023/01/19/274b1dfaf07945e7ab77710afad502a3/","link":"","permalink":"http://example.com/2023/01/19/274b1dfaf07945e7ab77710afad502a3/","excerpt":"","text":"Java面向对象基础（中级）Consolas, ‘Courier New’, monospace 包包的三大作用1.区分相同名字的类 2.当类很多的时候，可以很好地管理类 3.控制访问范围 包的基本语法121.package 关键字2. com.xxxx 表示包名 包的本质分析 包的本质就是创建不同的文件夹和目录来保存类文件 包的命名 只能包含数字，下划线，小圆点，但不能用数字开头，也不能是关键字和保留字 命名规范： com.xxxx.usr 用户模块 com.xxxx.utils 工具模块 域名反着写，最后加上模块名 常用的包 引入包语法：import 包名.类名 案例： 1234567891011package cn.meowrain.Object_.package_;import java.util.Scanner;public class package_01 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int a = sc.nextInt(); System.out.println(a); &#125;&#125; 访问修饰符 封装封装介绍封装就是把抽象出的数据[属性]和对数据的操作**[方法]封装在一起，数据被保护在内部，程序的其它部分只有通过被授权的操作[方法]**，才能对数据进行操作 封装的理解和好处 隐藏实现细节 可以对数据进行验证，保证安全合理 封装实现的步骤 将属性进行私有化（不能直接修改属性） 提供一个公共的(public)set方法，用于对属性判断并赋值 &#96;&#96;&#96;javapublic void setXXX(类型 参数名) {&#x2F;&#x2F; XXX表示某个属性&#x2F;&#x2F;加入数据验证的业务逻辑属性 &#x3D; 参数名;}1234567* 提供一个公共的(public)get方法，用于获取属性的值 * ```java public 数据类型 getXXX()&#123; //权限判断，xxx某个属性 return xxx; &#125; 快速入门案例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package cn.meowrain.Encap_;public class encap_01 &#123; public static void main(String[] args) &#123; Person person = new Person(); person.setName(&quot;meowrainyyds&quot;); person.setAge(-1); &#125;&#125;class Person&#123; public String name; private int age; private double salary; private String job; public void setName(String name) &#123; if(name.length()&gt;=6||name.length()&lt;=2)&#123; System.out.println(&quot;名字的长度错误，长度需要在2-6之间&quot;); &#125;else &#123; this.name = name; &#125; &#125; public void setAge(int age) &#123; if(age&lt;=1||age&gt;=120)&#123; System.out.println(&quot;输入年龄错误(1-120)&quot;); &#125;else &#123; this.age = age; &#125; &#125; public void setSalary(double salary) &#123; this.salary = salary; &#125; public void setJob(String job) &#123; this.job = job; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125; public double getSalary() &#123; return salary; &#125; public String getJob() &#123; return job; &#125; public void getInfo() &#123; System.out.println(name + &quot; &quot; + &quot;is&quot; + age + &quot;years old&quot;); &#125; &#125; 把构造器和封装结合在构造器中添加 12setName(name);setAge(age); 即可实现构造的时候调用这两个函数，从而判断输入的数据是否符合要求，然后使用这两个函数进行赋值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package cn.meowrain.Encap_;public class encap_01 &#123; public static void main(String[] args) &#123; Person person = new Person(&quot;meowrainyyds&quot;, -1); person.getInfo(); &#125;&#125;class Person &#123; public String name; private int age; private double salary; private String job; public Person(String name, int age) &#123; setName(name); setAge(age); &#125; public void setName(String name) &#123; if (name.length() &gt;= 6 || name.length() &lt;= 2) &#123; System.out.println(&quot;名字的长度错误，长度需要在2-6之间&quot;); &#125; else &#123; this.name = name; &#125; &#125; public void setAge(int age) &#123; if (age &lt;= 1 || age &gt;= 120) &#123; System.out.println(&quot;输入年龄错误(1-120)&quot;); &#125; else &#123; this.age = age; &#125; &#125; public void setSalary(double salary) &#123; this.salary = salary; &#125; public void setJob(String job) &#123; this.job = job; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125; public double getSalary() &#123; return salary; &#125; public String getJob() &#123; return job; &#125; public void getInfo() &#123; System.out.println(name + &quot; &quot; + &quot;is&quot; + age + &quot;years old&quot;); &#125;&#125; 课堂练习 1234567891011121314151617181920212223242526272829303132333435363738394041package cn.meowrain.Encap_;public class encap_02 &#123;&#125;class Account &#123; String name; int balance; public Account(String name, int balance) &#123; setName(name); setBalance(balance); &#125; public void setName(String name) &#123; if (name.length() &gt;= 2 &amp;&amp; name.length() &lt;= 4) &#123; this.name = name; &#125;else&#123; System.out.println(&quot;名字长度在2-4位之间，你输入的名字不合法&quot;); &#125; &#125; public void setBalance(int balance) &#123; if(balance&gt;20)&#123; this.balance = balance; &#125;else &#123; System.out.println(&quot;余额必须大于20&quot;); &#125; &#125;public void getInfo()&#123; System.out.println(name + &quot; &quot; + balance);&#125;&#125;class AccountTest &#123; public static void main(String[] args) &#123; Account account = new Account(&quot;meowrain&quot;, 24); account.getInfo(); &#125;&#125; 继承为什么需要继承 继承的基本介绍和示意图 继承的基本语法123class 子类 extends 父类&#123;&#125; 1.子类就会自动拥有父类定义的属性和方法2.父类又叫超类和基类3.子类又叫做派生类 快速入门案例12345678910111213141516171819202122232425262728package cn.meowrain.extends_;public class extends_01 &#123; public static void main(String[] args) &#123; Student student = new Student(&quot;mike&quot;, 17, 100); student.eat(); //mike is eating &#125;&#125;class Human &#123; String name; int age; public Human(String name, int age) &#123; this.name = name; this.age = age; &#125; //下面这个eat方法是共有的方法 public void eat()&#123; System.out.println(name + &quot; is &quot; + &quot;eating&quot;); &#125;&#125;class Student extends Human &#123; //Student继承了父类Human的所有属性 double grades; public Student(String name, int age, double grades) &#123; super(name, age);//构造器要使用super this.grades = grades; &#125;&#125; 继承给编程带来的便利 复用性增强 代码的扩展性和维护性提高 细节问题 子类继承了所有的属性和方法，非私有的属性和方法可以在子类直接访问，要通过父类提供公共的方法去访问 子类必须调用父类的构造器，完成父类的初始化 当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用super去指定使用父类的哪个构造器完成对父类的初始化工作，否则编译不会通过 如果希望指定去调用父类的某个构造器，则显式地调用一下：super(参数列表) super在使用时，必须放在构造器第一行（super只能在构造器中使用） super()和this()都只能放在构造器的第一行，因此这两个方法不能共存在一个构造器 super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。 java所有类都是 Object类的子类，Object类是所有类的基类 父类构造器的调用不限于直接父类，将一直往上追溯直到 Object类 子类最多只能继承一个父类 不能滥用继承，子类和父类之间必须满足is-a的逻辑关系 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package cn.meowrain.extends_;public class extends_02 &#123;&#125;class Base &#123; int n1; int n2; String name; public Base() &#123; &#125;// 无参构造器 public Base(int n1) &#123; this.n1 = n1; &#125; public Base(int n1, int n2) &#123; this.n1 = n1; this.n2 = n2; &#125; public Base(int n1, int n2, String name) &#123; this(n1, n2); /* * 这个this(n1,n2); * 相当于调用上面的 this.n1 = n1; this.n2 = n2; */ this.name = name; &#125;&#125;class kids extends Base &#123; int age; public kids(int n1,int n2,int age)&#123; super(n1,n2); /* super(n1,n2); * 相当于 * this.n1 = n1; this.n2 = n2; */ this.age = age; &#125;&#125;class adult extends Base &#123; public adult(int n1,int n2,String name)&#123; super(n1,n2,name); &#125;&#125;class little_kids extends kids &#123; String love; public little_kids(int n1,int n2,int age,String love)&#123; super(n1,n2,age); this.love = love; &#125;&#125; 继承的本质分析 看下面这些代码 12345678910111213141516171819202122232425262728293031323334353637package com.hspedu.extend_;/** * 讲解继承的本质 */public class ExtendsTheory &#123; public static void main(String[] args) &#123; Son son = new Son();// 内存的布局 // ?-&gt; 这时请大家注意，要按照查找关系来返回信息 // (1) 首先看子类是否有该属性 // (2) 如果子类有这个属性，并且可以访问，则返回信息 // (3) 如果子类没有这个属性，就看父类有没有这个属性(如果父类有该属性，并且可以访问，就返回信息..) // (4) 如果父类没有就按照(3)的规则，继续找上级父类，直到 Object... // System.out.println(son.name);//返回就是大头儿子 // System.out.println(son.age);//返回的就是 39 // System.out.println(son.getAge());//返回的就是 39 System.out.println(son.hobby);// 返回的就是旅游 &#125;&#125;class GrandPa &#123; // 爷类 String name = &quot;大头爷爷&quot;; String hobby = &quot;旅游&quot;;&#125;class Father extends GrandPa &#123;// 父类 String name = &quot;大头爸爸&quot;; private int age = 39; public int getAge() &#123; return age; &#125;&#125;class Son extends Father &#123; // 子类 String name = &quot;大头儿子&quot;;&#125; 子类创建的内存布局 练习 会输出ab nameb 分析：B类无参构造器中，其实第一句是隐藏的super()，所以会先执行A类的无参构造器，输出a，然后执行this(&quot;abc&quot;)，调用B类本类下的有参构造器，输出b name，接着执行System.out.println(&quot;b&quot;)，输出b 编写 Computer 类，包含 CPU、内存、硬盘等属性，getDetails 方法用于返回 Computer 的详细信息编写 PC 子类，继承 Computer 类，添加特有属性【品牌 brand】编写 NotePad 子类，继承 Computer 类，添加特有属性【color】编写 Test 类，在 main 方法中创建 PC 和 NotePad 对象，分别给对象中特有的属性赋值，以及从 Computer 类继承的属性赋值，并使用方法并打印输出信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package cn.meowrain.extends_;class Test &#123; public static void main(String[] args) &#123; PC pc = new PC(&quot;i5&quot;, 16, 512, &quot;Lenovo&quot;); Notepad notepad = new Notepad(&quot;j1900&quot;, 8, 64, &quot;white&quot;); pc.getDetails(); notepad.getDetails(); &#125;&#125;public class Computer &#123; String brand; String cpu; int memory; int disk_size; public Computer(String cpu, int memory, int disk_size) &#123; this.cpu = cpu; this.memory = memory; this.disk_size = disk_size; &#125; public void getDetails() &#123; System.out.println(&quot;the computer&#x27;s&quot; + &quot; &quot; + &quot;cpu is &quot; + cpu + &quot; &quot; + &quot;the memory size is &quot; + memory + &quot; &quot; + &quot;the disk size is&quot; + &quot; &quot; + disk_size); &#125;&#125;class PC extends Computer &#123; String brand; public PC(String cpu, int memory, int disk_size, String brand) &#123; super(cpu, memory, disk_size); this.brand = brand; &#125; public void getDetails() &#123; System.out.println(&quot;the computer&#x27;s brand is&quot; + brand + &quot; &quot; + &quot;cpu is &quot; + cpu + &quot; &quot; + &quot;the memory size is &quot; + memory + &quot; &quot; + &quot;the disk size is&quot; + &quot; &quot; + disk_size); &#125;&#125;class Notepad extends Computer &#123; String color; public Notepad(String cpu, int memory, int disk_size, String color) &#123; super(cpu, memory, disk_size); this.color = color; &#125; public void getDetails() &#123; System.out.println(&quot;the computer&#x27;s color is&quot; + color + &quot; &quot; + &quot;cpu is &quot; + cpu + &quot; &quot; + &quot;the memory size is &quot; + memory + &quot; &quot; + &quot;the disk size is&quot; + &quot; &quot; + disk_size); &#125;&#125; super关键字基本介绍 super代表父类的引用，用于访问父类的属性，方法和构造器 基本语法 访问父类的属性，但是不能访问父类的 private属性使用：super.属性名 访问父类的方法，不能访问父类的private方法使用：super.方法名(参数列表) 访问父类的构造器使用：super(参数列表)只能放在构造器的第一句，只能出现一句 案例： 12345678910111213141516171819202122package cn.meowrain.extends_;public class super_ &#123; public static void main(String[] args) &#123; Child_01 child = new Child_01(); child.getRes(); &#125;&#125;class Base_01 &#123; public String name = &quot;mike&quot;; private int age = 8; public int getSum(int a,int b) &#123; return a+b; &#125;&#125;class Child_01 extends Base_01 &#123; public String name = super.name;//把父类的name属性的值赋值给自雷的name属性 // public int age = super.age; 报错 public void getRes()&#123; System.out.println(super.getSum(19, 20));//调用并且输出父类中getSum方法的返回值 &#125;&#125; super给编程带来的便利 super和this的比较 方法重写（Override）基本介绍方法重写就是子类有一个方法，和父类的某个方法的名称，返回类型，参数一样，那么我们就说子类的这个方法覆盖了父类的方法 快速入门123456789101112131415161718192021package cn.meowrain.extends_;public class override_ &#123; public static void main(String[] args) &#123; Child_02 child_02 = new Child_02(); child_02.getInfo(); &#125;&#125;class Base_02 &#123; public void getInfo() &#123; System.out.println(&quot;hello my friends&quot;); &#125;&#125;class Child_02 extends Base_02 &#123; @Override public void getInfo() &#123; System.out.println(&quot;hello my good friends&quot;); &#125;&#125; 注意项 子类方法不能缩小父类方法的访问权限子类方法的形参列表，方法名称，要和父类方法的形参列表，方法名称完全一样子类方法的返回类型和父类方法的返回类型要一样，或者是父类返回类型的子类，比如：父类返回类型是Object，子类方法返回的类型是String 方法重写和重载的区别重载是 https://meowrain.cn/archives/java-mian-xiang-dui-xiang-ji-chu--chu-ji-中的内容，回顾清看上面链接的内容 多态基本介绍方法或对象具有多种形态，是面向对象的第三大特征，多态是建立在封装和继承基础上的 多态存在的三个必要条件 继承 重写 父类引用指向子类对象：Parent p = new Child(); 多态的具体体现方法的多态上图代码实现：Shap.java 12345678package cn.meowrain.Poly;public class Shape &#123; public void draw()&#123; System.out.println(&quot;画图形&quot;); &#125;&#125; Circle.java 12345678package cn.meowrain.Poly;public class Circle extends Shape&#123; public void draw()&#123; System.out.println(&quot;画圆形&quot;); &#125;&#125; Square.java 12345678package cn.meowrain.Poly;public class Square extends Shape&#123; public void draw()&#123; System.out.println(&quot;画方形&quot;); &#125;&#125; Triangle.java 12345678package cn.meowrain.Poly;public class Triangle extends Shape&#123; public void draw()&#123; System.out.println(&quot;画三角形&quot;); &#125;&#125; Runner.java 1234567891011121314package cn.meowrain.Poly;public class Runner &#123; public static void main(String[] args) &#123; Shape circle = new Circle(); circle.draw(); Shape triangle = new Triangle(); triangle.draw(); Shape square = new Square(); square.draw(); &#125;&#125; 注意：1.一个对象的编译类型和运行类型可以不一致2.编译类型在定义对象时就确定了，不能改变3.运行类型是可以变化的4.编译类型看定义时候&#x3D;号的左边，运行类型看&#x3D;号的右边 多态注意事项和细节讨论 多态的前提是： 两个对象（类）存在继承关系 多态的向上转型 本质：父类的引用指向了子类的对象 语法：&#x3D;&#x3D;父类类型 引用名 &#x3D; new 子类类型();&#x3D;&#x3D; 特点：编译类型看左边，运行类型看右边可以调用父类中的所有成员（需遵守访问权限）不能调用子类中的特有成员–&gt;只能调用子类和父类共有的成员最终运行效果看子类的具体实现 多态的向下转型 语法： &#x3D;&#x3D;子类类型 引用名 &#x3D; (子类类型)父类引用;&#x3D;&#x3D; 只能强制转父类的引用，不能强转父类的对象 要求父类的引用必须指向的是当前目标类型的对象 当向下转型后，可以调用子类类型中所有成员 案例演示:Animal.java 123456789101112131415161718package cn.meowrain.Poly.poly02;public class Animal &#123; String name = &quot;动物&quot;; int age = 10; public void sleeper() &#123; System.out.println(&quot;睡&quot;); &#125; public void run() &#123; System.out.println(&quot;跑&quot;); &#125; public void eat()&#123; System.out.println(&quot;吃&quot;); &#125; public void show() &#123; System.out.println(&quot;hello 你好&quot;); &#125;&#125; Cat.java 1234567891011package cn.meowrain.Poly.poly02;public class Cat extends Animal&#123; public void eat()&#123; //方法重写 System.out.println(&quot;猫吃鱼&quot;); &#125; public void catchMouse() &#123;//cat特有方法 System.out.println(&quot;猫抓老鼠&quot;); &#125; &#125; PolyDetail.java 1234567891011121314151617181920package cn.meowrain.Poly.poly02;public class PolyDetail &#123; public static void main(String[] args) &#123; //向上转型,父类的引用指向了子类的对象 Animal animal = new Cat(); //animal.catchMouse() 错误,只能调用共同的属性 //因为在编译阶段,能调用哪些成员,是由编译类型决定的 //最终运行效果看运行类型的具体实现 animal.eat(); animal.run(); animal.show(); animal.sleeper(); //如果想调用Cat的catchMouse方法 //多态的向下转型 //子类类型 引用名 = (子类类型)父类引用 Cat cat = (Cat)animal; cat.catchMouse(); &#125;&#125; 注意: 属性没有重写只说!属性的值看编译类型,也就是左侧看下面的代码: 12345678910111213141516package cn.meowrain.Poly.poly03;public class item &#123; public static void main(String[] args) &#123; Base base = new Sub(); //属性的值看编译类型 System.out.println(base.count);//120 &#125;&#125;class Base &#123;//父类 int count = 120;&#125;class Sub extends Base &#123; //子类 int count = 234;&#125; instanceOf比较操作符 介绍: instanceOf比较操作符,用于判断对象的运行类型是否为XX类型的子类型举个例子: 123456789101112131415161718192021222324252627package cn.meowrain.Poly.poly03;public class PolyDetail03 &#123; public static void main(String[] args) &#123; BB bb = new BB(); //运行类型是BB System.out.println(bb instanceof BB); //true System.out.println(bb instanceof AA); //true //向上转型 //AA是编译类型,BB是运行类型 AA aa = new BB();//运行类型是BB System.out.println(aa instanceof AA); //true System.out.println(aa instanceof BB);// true //向下转型 BB ab = (BB)aa;//运行类型是BB System.out.println(ab instanceof AA); //true System.out.println(ab instanceof BB); //true AA am = new AA(); //运行类型是AA System.out.println(am instanceof AA);// true System.out.println(am instanceof BB); //false &#125;&#125;class AA &#123;&#125;class BB extends AA &#123;&#125; java的动态绑定 当调用对象方法的的时候，该方法回和该都西昂的内存地址&#x2F;运行类型绑定 当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用 在向上转型情况下的动态绑定示例父类方法，对象类型：class cn.meowrain.bind.Son 1234567891011121314151617package cn.meowrain.bind;public class bind01 &#123; public static void main(String[] args) &#123; Father sample = new Son();//向上转型 sample.method(); &#125;&#125;class Father &#123; public void method()&#123; System.out.println(&quot;父类方法，对象类型：&quot; + this.getClass()); &#125;&#125;class Son extends Father &#123;&#125; 声明的是父类的引用，但是调用了子类对象，调用method，子类中没有这个方法，就去父类中去找，然后进行调用 接下来我们修改子类，在子类中重写method方法 1234567891011121314151617181920package cn.meowrain.bind;public class bind01 &#123; public static void main(String[] args) &#123; Father sample = new Son();//向上转型 sample.method(); &#125;&#125;class Father &#123; public void method()&#123; System.out.println(&quot;父类方法，对象类型：&quot; + this.getClass()); &#125;&#125;class Son extends Father &#123; @Override public void method() &#123; System.out.println(&quot;子类方法，对象类型： &quot; +this.getClass()); &#125;&#125; 子类方法，对象类型： class cn.meowrain.bind.Son掉用子类对象，子类中含有method方法，所以调用子类中的这个method方法 注意： 下面说到的不属于动态绑定运行时（动态）绑定针对的范畴只是对象的方法。接下来我们来看一看属性绑定 12345678910111213141516package cn.meowrain.bind;public class bind01 &#123; public static void main(String[] args) &#123; Father sample = new Son();//向上转型 System.out.println(sample.name); &#125;&#125;class Father &#123; String name = &quot;父类属性&quot;;&#125;class Son extends Father &#123; String name = &quot;子类属性&quot;;&#125; 运行结果： 父类属性从上面我们可以看出，输出是由编译类型决定的 多态的应用多态数组 数组的定义类型是父类类型，里面保存的实际元素类型为子类类型应用实例：： 现有一个结构如下，要求创建1个Person对象，2个Student对象和2个Teacher对象，统一放在数组中，并调用每个对象的say方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113package cn.meowrain.bind;public class bind02 &#123; public static void main(String[] args) &#123; Person[] persons = new Person[5]; persons[0] = new Person(&quot;jack&quot;, 20); persons[1] = new Student(&quot;mike&quot;, 18, 100); persons[2] = new Student(&quot;meowrain&quot;, 19, 150); persons[3] = new Teacher(&quot;gac&quot;, 24, 110); persons[4] = new Teacher(&quot;jjj&quot;, 25, 123); // persons[i]编译类型是Person，运行类型是根据实际情况通过JVM判断的 for (int i = 0; i &lt; persons.length; i++) &#123; System.out.println(persons[i].say());// 动态绑定机制 if (persons[i] instanceof Student) &#123; Student student = (Student) persons[i];//向下转型 student.study(); //可以用下面这个替代 // ((Student)persons[i]).study(); &#125; else if (persons[i] instanceof Teacher) &#123; Teacher teacher = (Teacher) persons[i];//向下转型 teacher.teach(); //可以用下面这个替代 // ((Teacher)persons[i]).teach(); &#125; &#125; &#125;&#125;class Person &#123; private String name; private int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String say() &#123; return &quot;Perosn &quot; + getName() + &quot; is &quot; + getAge() + &quot;years old&quot;; &#125;&#125;class Student extends Person &#123; private int score; public Student(String name, int age, int score) &#123; super(name, age); this.score = score; &#125; public int getScore() &#123; return score; &#125; public void setScore(int score) &#123; this.score = score; &#125; @Override public String say() &#123; return &quot;Student &quot; + getName() + &quot; &quot; + &quot;is&quot; + &quot; &quot; + &quot;learning&quot; + &quot; &quot; + &quot;his score is &quot; + getScore(); &#125; public void study() &#123; System.out.println(&quot;student &quot; + getName() + &quot;is learning&quot;); &#125;&#125;class Teacher extends Person &#123; private double salary; public Teacher(String name, int age, double salary) &#123; super(name, age); this.salary = salary; &#125; public double getSalary() &#123; return salary; &#125; public void setSalary(double salary) &#123; this.salary = salary; &#125; @Override public String say() &#123; return &quot;Teacher &quot; + getName() + &quot;is teaching&quot; + &quot; &quot; + &quot;his salary is &quot; + getSalary(); &#125; public void teach() &#123; System.out.println(&quot;Teacher &quot; + getName() + &quot;is teaching&quot;); &#125;&#125; 多态参数 方法定义的形参类型为父类类型，实参类型允许为子类类型 定义员工类Employee,包含姓名和月工资（private)，以及计算年工资getAnnual的方法，普通员工和经理继承了员工，经理类多了奖金bonus和管理manage方法，普通员工多了work方法，普通员工和经理类要求分别重写getAnnual方法测试类中添加一个方法showEmpAnnual(Employee e),实现获取任何员工对象的年工资，并在main方法中调用该方法[e.getAnnual] 测试类中添加一个方法，testWork,如果是普通员工，就调用那个work方法。如果是经理，就调用manage方法 Test.java 12345678910111213141516171819202122232425package cn.meowrain.Poly.poly04;public class Test &#123; public double showEmpAnnual(Employee e) &#123; return e.getAnnual(); &#125; public void testWork(Employee e)&#123; if(e instanceof NormalEmployee)&#123; ((NormalEmployee)e).work(); &#125;else if (e instanceof Manager)&#123; ((Manager)e).manage(); &#125; &#125; public static void main(String[] args) &#123; NormalEmployee worker = new NormalEmployee(&quot;mike&quot;, 4000); Manager manager = new Manager(&quot;john&quot;, 4300, 5000); Test test = new Test(); System.out.println(&quot;管理者工资： &quot; + test.showEmpAnnual(manager)); System.out.println(&quot;工人工资： &quot; + test.showEmpAnnual(worker)); test.testWork(manager); test.testWork(worker); &#125;&#125; Employee.java 123456789101112131415161718192021222324252627282930313233package cn.meowrain.Poly.poly04;public class Employee &#123; private String name; private double salary; public Employee(String name, double salary) &#123; this.name = name; this.salary = salary; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public double getSalary() &#123; return salary; &#125; public void setSalary(double salary) &#123; this.salary = salary; &#125; public double getAnnual () &#123; return salary*12; &#125;&#125; Manager.java 12345678910111213141516171819202122232425262728package cn.meowrain.Poly.poly04;public class Manager extends Employee&#123; private double bonus; public Manager(String name, double salary, double bonus) &#123; super(name, salary); this.bonus = bonus; &#125; public double getBonus() &#123; return bonus; &#125; public void setBonus(double bonus) &#123; this.bonus = bonus; &#125; public void manage()&#123; System.out.println(&quot;Manager &quot; + getName() + &quot; &quot; + &quot;is managing&quot;); &#125; @Override public double getAnnual() &#123; return (getSalary()*12 + bonus); &#125; &#125; NormalEmployee.java 1234567891011121314151617package cn.meowrain.Poly.poly04;public class NormalEmployee extends Employee&#123; public NormalEmployee(String name, double salary) &#123; super(name, salary); &#125; public void work()&#123; System.out.println(&quot;普通工人&quot; + &quot; &quot; + getName() + &quot; &quot; + &quot;is working&quot;); &#125; @Override public double getAnnual() &#123; // TODO Auto-generated method stub return super.getAnnual(); &#125;&#125; Object类详解equals方法=&#x3D; 是一个比较运算符 在看下面这个东西之前，我们先抛出一个问题String属于什么数据类型？https://zhuanlan.zhihu.com/p/136468277引用类型基本数据类型和引用数据类型详见Java数据类型：基本数据类型和引用数据类型 (biancheng.net) 区分 123456789101112131415161718192021222324252627282930313233343536373839404142package com.hsp.object;public class Equals_exercise02 &#123; public static void main(String[] args) &#123; String name_1 = &quot;hello&quot;; String name_2 = &quot;hello&quot;; System.out.println(name_2 == name_1);//true /* * String str1 = &quot;abcd&quot;的实现过程：首先栈区创建str引用， * 然后在String池（独立于栈和堆而存在，存储不可变量） * 中寻找其指向的内容为&quot;abcd&quot;的对象，如果String池中没有， * 则创建一个，然后str指向String池中的对象， * 如果有，则直接将str1指向&quot;abcd&quot;&quot;； * 如果后来又定义了字符串变量 str2 = &quot;abcd&quot;, * 则直接将str2引用指向String池中已经存在的“abcd”， * 不再重新创建对象；当str1进行了赋值（str1=“abc”）， * 则str1将不再指向&quot;abcd&quot;，而是重新指String池中的&quot;abc&quot;， * 此时如果定义String str3 = &quot;abc&quot;,进行str1 == str3操作， * 返回值为true，因为他们的值一样，地址一样， * 但是如果内容为&quot;abc&quot;的str1进行了字符串的+连接str1 = str1+&quot;d&quot; * ；此时str1指向的是在堆中新建的内容为&quot;abcd&quot;的对象， * 即此时进行str1==str2，返回值false，因为地址不一样。 String str3 = new String(&quot;abcd&quot;)的实现过程：* 直接在堆中创建对象。* 如果后来又有* String str4 = new String(&quot;abcd&quot;)，str4不会指向之前的对象，* 而是重新创建一个对象并指向它，* 所以如果此时进行str3==str4返回值是false，* 因为两个对象的地址不一样，如果是str3.equals(str4)，* 返回true,因为内容相同。 * */ String name_3 = new String(&quot;hello&quot;); String name_4 = new String(&quot;hello&quot;); System.out.println(name_3 == name_4);//false System.out.println(name_3.equals(name_4)); System.out.println(name_1.equals(name_2)); &#125;&#125; hashCode方法 提高具有哈希结构的容器效率 两个引用，如果指向的是同一个对象，则哈希值肯定是一样的 两个引用，如果指向的是不同的对象，则哈希值是不一样的 哈希值主要根据地址号来的，不能将哈希值等价于地址 1234567891011121314package com.hsp.object;public class HashCode &#123; public static void main(String[] args) &#123; AA aa = new AA(); AA aa2 = new AA(); System.out.println(aa.hashCode()); System.out.println(aa2.hashCode()); /*460141958 1163157884*/ &#125;&#125;class AA &#123;&#125; toString方法基本介绍： 默认返回： 全类名 + @ + 哈希值的十六进制 子类往往重写toString方法，用于返回对象的属性信息 12345678910111213141516171819package com.hsp.object;public class toString &#123; public static void main(String[] args) &#123; Monster monster = new Monster(&quot;妖怪&quot;,&quot;保安&quot;,1000); System.out.println(monster.toString());//com.hsp.object.Monster@1b6d3586 &#125;&#125;class Monster &#123; private String name; private String job; private double sal; public Monster(String name, String job, double sal) &#123; this.name = name; this.job = job; this.sal = sal; &#125;&#125; 重写toString方法，打印对象或拼接对象时，都会自动调用该对象的toString形式 123456789101112131415161718192021222324252627282930package com.hsp.object;public class toString &#123; public static void main(String[] args) &#123; Monster monster = new Monster(&quot;妖怪&quot;,&quot;保安&quot;,1000); System.out.println(monster.toString());//Monster&#123;name=&#x27;妖怪&#x27;, job=&#x27;保安&#x27;, sal=1000.0&#125; &#125;&#125;class Monster &#123; private String name; private String job; private double sal;// 重写toString方法 @Override public String toString() &#123; return &quot;Monster&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, job=&#x27;&quot; + job + &#x27;\\&#x27;&#x27; + &quot;, sal=&quot; + sal + &#x27;&#125;&#x27;; &#125; public Monster(String name, String job, double sal) &#123; this.name = name; this.job = job; this.sal = sal; &#125;&#125; 当直接输出一个对象时候，toString方法会被默认的调用 123456789101112131415161718192021222324252627282930package com.hsp.object;public class toString &#123; public static void main(String[] args) &#123; Monster monster = new Monster(&quot;妖怪&quot;, &quot;保安&quot;, 1000); System.out.println(monster); &#125;&#125;class Monster &#123; private String name; private String job; private double sal;// 重写toString方法 @Override public String toString() &#123; return &quot;Monster&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, job=&#x27;&quot; + job + &#x27;\\&#x27;&#x27; + &quot;, sal=&quot; + sal + &#x27;&#125;&#x27;; &#125; public Monster(String name, String job, double sal) &#123; this.name = name; this.job = job; this.sal = sal; &#125;&#125; finalize()当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法 1.当对象被回收时，系统自动调用该对象的finalize方法。子类可以重写该方法，做一些释放资源的操作 2.什么时候被回收：当某个对象没有任何引用的时候，则jvm就认为这个对象是一个垃圾对象，就会用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用finalize方法 3.垃圾回收机制的调用，是由系统来决定，也可以由System.gc()主动触发垃圾回收机制 实际开发中基本不会运用，应付面试","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"JAVASE","slug":"Java/JAVASE","permalink":"http://example.com/categories/Java/JAVASE/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"Java面向对象基础(初级)","slug":"929bd134ed01499c92d8e177925950ef","date":"2023-01-19T12:23:00.311Z","updated":"2023-01-19T12:23:09.876Z","comments":true,"path":"2023/01/19/929bd134ed01499c92d8e177925950ef/","link":"","permalink":"http://example.com/2023/01/19/929bd134ed01499c92d8e177925950ef/","excerpt":"","text":"Java面向对象基础(初级) 对面向对象和面向过程的理解 谈谈你对面向过程和面向对象的理解_智十七°的博客-CSDN博客_面向对象和面向过程的理解 面向对象的三大特征封装 (Encapsulation)继承 (Inheritance)多态 (Polymorphism) 初识对象和类 初次使用对象和类 如下，在下面这个代码中，我创建了一个猫类，然后利用猫类创建了两个猫对象，一个赋值给cat01，一个赋值给cat02 1234567891011121314151617181920212223242526272829303132package cn.meowrain.Object_;public class relean_01 &#123; public static void main(String[] args) &#123; //创建两猫对象 Cat cat01 = new Cat(); cat01.name = &quot;小花&quot;; cat01.age = 1; cat01.color = &quot;花色&quot;; Cat cat02 = new Cat(); cat02.name = &quot;小白&quot;; cat02.age = 2; cat02.color = &quot;白色&quot;; //访问对象属性 System.out.println(cat01.name); System.out.println(cat02.name); cat01.eat(); cat02.eat(); &#125;&#125;class Cat &#123; public String name; public int age; public String color; public void eat()&#123; System.out.println(name + &quot;吃饭&quot;); &#125; public void drink()&#123; System.out.println(name + &quot;喝水&quot;); &#125;&#125; new Cat() &#x2F;&#x2F;创建一只猫对象 Cat cat01 &#x3D; new Cat();&#x2F;&#x2F;把创建的猫对象赋值给cat01 cat01是对象名(对象引用) 如何创建一个对象123451) 先声明再创建Cat cat ; //声明对象 catcat = new Cat(); //创建2) 直接创建Cat cat = new Cat(); 补充：Java中实例化对象是什么意思 在Java语言中使用new关键字创建&#x2F;构造对象的过程叫做类的实例化，该过程的本质，会在内存空间的堆区申请一块存储区域，用于记录该对象独有的成员变量信息。 通俗点就是，实例化：使用关键字new来创建对象。 例如：Person person &#x3D; new Person(); 这样的语句称为创建对象。 对象是根据类创建的。在Java中使用关键字new创建对象。 new Person(); 是 声明一个Person类型的对象，在堆区区域。 new Person(); ()是指创建Person类型的对象后，自动调用Person类中的构造方法，来进行成员变量的初始化。 Person person ，Person为类名，person 为引用变量名。————————————————版权声明：本文为CSDN博主「智十七°」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/weixin_45812336/article/details/113954823 对象在内存中的存在形式 属性，成员变量1234567891011package cn.meowrain.Object_;public class relearn_02 &#123;&#125;class Hunman &#123; //下面都属于Human类的属性 String name; double salary; int age; String country;&#125; 属性是类的一个组成部分，一般是基本数据类型,也可是引用类型(对象，数组)。上面这个代码中的name,salary等都是这个Human类的属性 属性的定义语法同变量， 示例：访问修饰符 属性类型 属性名 访问修饰符详情见Java 访问修饰符 - 喵雨の小屋|木更老婆！！！ (meowrain.cn) 属性的定义类型可以为任意类型，包含基本类型或引用类型 基本数据类型和引用数据类型详见Java数据类型：基本数据类型和引用数据类型 (biancheng.net) Java数据类型（八种基本数据类型 + 四种引用数据类型）_火火笔记的博客-CSDN博客_引用数据类型有哪几种 属性如果不赋值，有默认值，规则和数组一致。 具体: &#x3D;&#x3D;int 0，short 0, byte 0, long 0, float 0.0,double 0.0，char \\u0000， boolean false，String null&#x3D;&#x3D; 如何访问属性 基本语法 对象名.属性名; 示范： 123456789101112131415package cn.meowrain.Object_;public class relearn_02 &#123; Human human01 = new Human(); human01.name = &quot;mike&quot;; human01.age = 20; System.out.println(human.name + &quot;is&quot; + human01.age + &quot;years old&quot;)&#125;class Hunman &#123; //下面都属于Human类的属性 String name; double salary; int age; String country;&#125; 类和对象的内存分配机制我们定义一个人类(Person)(包括 名字,年龄) 1234567891011121314151617package cn.meowrain.Object_;public class relearn_03 &#123; public static void main(String[] args) &#123; Person p1 = new Person(); p1.age = 10; p1.name = &quot;小明&quot;; Person p2 = p1; System.out.println(p2.age); &#125;&#125;class Person &#123; public int age; public String name; &#125; 问题：p2.age 究竟是多少，画出内存图 Java 内存的结构分析 栈： 一般存放基本数据类型(局部变量) 堆： 存放对象(Cat cat , 数组等) 方法区：常量池(常量，比如字符串)， 类加载信息 Java 创建对象的流程简单分析 方法重载 java中允许同一个类中，多个同名方法的存在，但是要求形参列表不一致 通过重载，我们减轻了起名的麻烦 案例： 12345678910111213141516171819package cn.meowrain.Object_;public class relearn_06 &#123; public static void main(String[] args) &#123; rel rel = new rel(); int m = rel.getSum(1,2,3); System.out.println(m); int n = rel.getSum(1,2); &#125;&#125;class rel &#123; public int getSum(int n1,int n2)&#123; return n1+n2; &#125; public int getSum(int n1,int n2,int n3)&#123; return n1+n2+n3; &#125;&#125; 可变参数 java允许把同一个类中多个同名同功能但是参数个数不同的方法，封装成一个方法 基本语法： //int... 表示接受的是可变参数，类型是int，即可以接收多个int //使用可变参数时候，可以当数组来使用，nums可以当做数组 12345678910111213141516171819202122232425package cn.meowrain.Object_;public class relearn_07 &#123; public static void main(String[] args) &#123; rel_07 rel = new rel_07(); int m = rel.getSum(1,2,3,4);//10 int n = rel.getSum(5,6,7);//18 int b = rel.getSum(0,1);//1 System.out.println(m); System.out.println(n); System.out.println(b); &#125;&#125;class rel_07 &#123; //int... 表示接受的是可变参数，类型是int，即可以接收多个int //使用可变参数时候，可以当数组来使用，nums可以当做数组 public int getSum(int... nums)&#123; int res = 0; for(int i = 0;i&lt;nums.length;i++)&#123; res+=nums[i]; &#125; return res; &#125;&#125; 作用域 12345678910111213141516171819202122232425262728293031323334353637package cn.meowrain.Object_;public class relearn_08 &#123; public static void main(String[] args) &#123; &#125;&#125;class Dog &#123; //全局变量：也就是属性，作用域为整个类体Cat类，cry eat等方法使用属性 //属性在定义时，可以直接赋值 int age = 10; double weight;//默认是0.0 public void hi() &#123; //局部变量必须赋值后才能使用，因为没有默认值 //局部变量一般是指在成员方法中定义的变量 int num = 1; String address = &quot;Beijing&#x27;s Dog&quot;; System.out.println(&quot;num=&quot; + num); System.out.println(&quot;address&quot; + address); System.out.println(&quot;weight=&quot; + weight); &#125; public void cry() &#123; int n = 10; String name = &quot;jack&quot;; System.out.println(name + &quot;cry for&quot; + n + &quot;times&quot;); &#125; public void eat() &#123; String name = &quot;meow&quot;; System.out.println(name + &quot;eat&quot;); &#125;&#125; 注意事项和使用细节 属性可以加修饰符，但是局部变量不能加修饰符 构造器构造方法又叫构造器(constructor)，是类的一种特殊的方法， 它的主要作用是完成对新对象的初始化。它有几个特点： 方法名和类名相同 没有返回值 在创建对象时，系统会自动的调用该类的构造器完成对象的初始化。 基本语法： 123[修饰符] 方法名(形参列表) &#123; 方法体&#125; 案例： 12345678910111213141516171819202122232425262728293031323334353637package cn.meowrain.Object_;public class relearn_09 &#123; public static void main(String[] args) &#123; rel_09 rel = new rel_09(&quot;meowrain&quot;, 18); rel_09 rel_1 = new rel_09(&quot;meow&quot;, 20, &quot;mouse&quot;); rel.getInfo(); rel_1.getItem(); &#125;&#125;class rel_09 &#123; String name; int age; String item; public rel_09(String name, int age) &#123; this.name = name; this.age = age; &#125; // 构造器重载 public rel_09(String name, int age, String item) &#123; this.name = name; this.age = age; this.item = item; &#125; public void getInfo() &#123; System.out.println(this.name + &quot; &quot; + this.age); &#125; public void getItem() &#123; System.out.println(this.item); &#125;&#125; 练习题： 1234567891011121314151617181920212223242526package cn.meowrain.Object_;public class relearn_10 &#123; public static void main(String[] args) &#123; Person_n person01 = new Person_n(&quot;meow&quot;, 12); Person_n person02 = new Person_n(); System.out.println(person01.name + &quot; is &quot; + person01.age + &quot;years old&quot;); System.out.println(person02.name + &quot; is &quot; + person02.age + &quot;years old&quot;); &#125;&#125;class Person_n &#123; String name; int age; public Person_n() &#123; this.age = 18; &#125; public Person_n(String name, int age) &#123; this.name = name; this.age = age; &#125;&#125; 对象创建的流程分析 this关键字 什么是this? =&#x3D;简单说：哪个对象调用，this就代表哪个对象&#x3D;&#x3D; 1234567891011121314151617181920212223package cn.meowrain.Object_;public class relearn12 &#123; &#125;class This01 &#123; public static void main(String[] args) &#123; Dog_new dog_new = new Dog_new(&quot;大黄&quot;, 1); dog_new.info(); &#125;&#125;class Dog_new &#123; String name; int age; public Dog_new(String name,int age) &#123; this.name = name; this.age = age; &#125; public void info()&#123; System.out.println(&quot;this.hashCode=&quot; + this.hashCode()); System.out.println(name + &quot;\\t&quot; + age + &quot;\\t&quot;); &#125;&#125; 练习题： 1234567891011121314151617181920212223242526package cn.meowrain.Object_;public class relearn13 &#123; public static void main(String[] args) &#123; person_01 p1 = new person_01(&quot;mary&quot;, 18); person_01 p2 = new person_01(&quot;mary&quot;,18); System.out.println(p1.compareTo(p2)); //true &#125; &#125;class person_01 &#123; String name; int age; public person_01(String name, int age) &#123; this.name = name; this.age = age; &#125; public boolean compareTo(person_01 p)&#123; if(this.name.equals(p.name)&amp;&amp;this.age == p.age) &#123; return true; &#125; return false; &#125;&#125; 作业作业1 12345678910111213141516171819202122package cn.meowrain.Object_.homework;public class h1 &#123; public static void main(String[] args) &#123; double[] arr = &#123; 1.0, -2.0, 4.5 &#125;; A01 a01 = new A01(); double max = a01.max(arr); System.out.println(max); &#125;&#125;class A01 &#123; public double max(double[] a) &#123; double m = a[0]; for (int i = 0; i &lt; a.length; i++) &#123; if (a[i] &gt; m) m = a[i]; &#125; return m; &#125;&#125; 作业2 12345678910111213141516171819202122232425package cn.meowrain.Object_.homework;public class h2 &#123; public static void main(String[] args) &#123; String[] strArr = &#123;&quot;helloworld&quot;,&quot;meowrain&quot;&#125;; A02 a02 = new A02(); int a = a02.find(strArr); if(a == 0)&#123; System.out.println(true); &#125;else &#123; System.out.println(false); &#125; &#125; &#125;class A02 &#123; public int find(String []arr)&#123; for (int i = 0; i &lt; arr.length; i++)&#123; if(arr[i].equals(&quot;helloworld&quot;))&#123; return i; &#125; &#125; return -1; &#125;&#125; 作业3 123456789101112131415161718192021222324252627282930313233343536package cn.meowrain.Object_.homework;public class h3 &#123; public static void main(String[] args) &#123; Book book = new Book(&quot;猫的故事&quot;, 200); Book book2 = new Book(&quot;狗的故事&quot;, 120); Book book3 = new Book(&quot;驴的故事&quot;, 20); book.updatePrice(book.price); book2.updatePrice(book2.price); book3.updatePrice(book3.price); System.out.println(book.name + &quot; : &quot; + book.price); System.out.println(book2.name + &quot; : &quot; + book2.price); System.out.println(book3.name + &quot; : &quot; + book3.price); /* * 猫的故事 : 150.0 狗的故事 : 100.0 驴的故事 : 20.0 * */ &#125;&#125;class Book &#123; String name; double price; public Book(String name,double price) &#123; this.name = name; this.price = price; &#125; public void updatePrice(double price)&#123; if(price &gt; 150)&#123; this.price = 150; &#125;else if(price &gt; 100) &#123; this.price = 100; &#125; &#125;&#125; 作业4 12345678910111213141516171819202122package cn.meowrain.Object_.homework;public class h4 &#123; public static void main(String[] args) &#123; A03 a03 = new A03(); int[] arr = &#123;1,2,3,4,5&#125;; int[] a1 = a03.copyArr(arr); for(int i=0;i&lt;a1.length; i++)&#123; System.out.println(a1[i]); &#125; &#125;&#125;class A03 &#123; public int[] copyArr(int[] arr) &#123; int[] a = new int[arr.length]; for (int i = 0; i &lt; arr.length; i++)&#123; a[i] = arr[i]; &#125; return a; &#125;&#125; 作业5 123456789101112131415161718192021222324252627282930package cn.meowrain.Object_.homework;public class h5 &#123;public static void main(String[] args) &#123; Circle circle = new Circle(2); double perimeter = circle.perimeter(); double area = circle.area(); System.out.printf(&quot;%.2f\\n&quot;,perimeter); System.out.printf(&quot;%.2f\\n&quot;,area); /* * 12.57 12.57 */&#125;&#125;class Circle &#123; double r; public Circle(double r) &#123; this.r = r; &#125; public double perimeter() &#123; return Math.PI*r*2; &#125; public double area() &#123; return Math.PI * r * r; &#125;&#125; 作业6 12345678910111213141516171819202122232425262728293031323334353637package cn.meowrain.Object_.homework;public class h6 &#123; public static void main(String[] args) &#123; Cale cale01 = new Cale(5, 2); Cale cale02 = new Cale(1, 0); cale01.divide(); cale02.divide(); &#125;&#125;class Cale &#123; int a, b; public Cale(int a, int b) &#123; this.a = a; this.b = b; &#125; public int sum() &#123; return a + b; &#125; public int multiply() &#123; return a * b; &#125; public void divide() &#123; if (b == 0) &#123; System.out.println(&quot;输入的除数不能为0！&quot;); &#125; else &#123; System.out.println(a * 1.0 / b); &#125; &#125;&#125; 作业7 123456789101112131415161718192021package cn.meowrain.Object_.homework;public class h7 &#123;public static void main(String[] args) &#123; Dog dog = new Dog(&quot;mike&quot;,&quot;white&quot;,2); dog.show();&#125;&#125;class Dog &#123; String name; String color; int age; public Dog(String name,String color,int age)&#123; this.name = name; this.color = color; this.age = age; &#125; public void show()&#123; System.out.println(&quot;the dog &quot; + name + &quot; is &quot; + age + &quot; &quot; + &quot;years old and its color is &quot; + color); &#125;&#125; 作业8 作业9 123456789101112131415161718192021222324252627package cn.meowrain.Object_.homework;public class h9 &#123; public static void main(String[] args) &#123; Music music01 = new Music(&quot;青花瓷&quot;, &quot;4:00&quot;); Music music02 = new Music(&quot;鸡你太美&quot;, &quot;3:00&quot;); music01.getInfo(); music01.play(); &#125;&#125;class Music&#123; String name; String times; public Music(String name,String times)&#123; this.name = name; this.times = times; &#125; public void play()&#123; System.out.println(name + &quot;is palying for &quot; + times); &#125; public void getInfo()&#123; System.out.println(&quot;the music name is &quot; + name + &quot;times is : &quot; + times); &#125;&#125; 作业10 123456789101112131415161718192021package cn.meowrain.Object_.homework;public class h8 &#123; int i = 100; public void m()&#123; int j = i++; System.out.println(&quot;i=&quot; + i); System.out.println(&quot;j=&quot; + j); &#125;&#125;class Test &#123; public static void main(String[] args) &#123; h8 demo = new h8(); h8 demo2 = new h8(); demo.m(); System.out.println(demo.i); System.out.println(demo2.i); &#125;&#125; 1234i=101j=100101 100 作业11 1不做了 作业12 123456789101112131415161718192021222324252627282930313233package cn.meowrain.Object_.homework;public class h12 &#123; Employee_ emp1 = new Employee_(&quot;经理&quot;, &quot;10000&quot;); &#125;class Employee_ &#123; String name; String sex; int age; String position; String salary; public Employee_(String name, String sex, int age, String position, String salary) &#123; this.name = name; this.sex = sex; this.age = age; this.position = position; this.salary = salary; &#125; public Employee_(String name, String sex, int age) &#123; this.name = name; this.sex = sex; this.age = age; &#125; public Employee_(String position, String salary) &#123; this.position = position; this.salary = salary; &#125; &#125; 作业13 123456789101112131415161718192021222324package cn.meowrain.Object_.homework;public class h13 &#123; public static void main(String[] args) &#123; Circle01 circle = new Circle01(); PassObject pass = new PassObject(); pass.printAreas(circle, 5); &#125;&#125; class Circle01 &#123; public double radius; public double findArea()&#123; return radius*radius*Math.PI; &#125; &#125; class PassObject &#123; public void printAreas(Circle01 c,int times) &#123; for(int i = times;i&gt;0;i--)&#123; c.radius = i; System.out.println(&quot;r:&quot; + i + &quot; &quot; + &quot;S=&quot; + c.findArea()); &#125; &#125; &#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"JAVASE","slug":"Java/JAVASE","permalink":"http://example.com/categories/Java/JAVASE/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"Linux下JAVA环境配置","slug":"06a5ebd1d51442d58ba9f7b02612a94b","date":"2023-01-19T12:20:57.958Z","updated":"2023-01-25T11:54:54.285Z","comments":true,"path":"2023/01/19/06a5ebd1d51442d58ba9f7b02612a94b/","link":"","permalink":"http://example.com/2023/01/19/06a5ebd1d51442d58ba9f7b02612a94b/","excerpt":"","text":"在 /etc/profile文件下编辑 123456789export JAVA_HOME=/usr/local/jdk1.8.0_181 #jdk安装目录 export JRE_HOME=$&#123;JAVA_HOME&#125;/jre export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib:$CLASSPATH export JAVA_PATH=$&#123;JAVA_HOME&#125;/bin:$&#123;JRE_HOME&#125;/bin export PATH=$PATH:$&#123;JAVA_PATH&#125; 然后命令输入java -version","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"环境配置","slug":"Java/环境配置","permalink":"http://example.com/categories/Java/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[]},{"title":"Java-GUI 布局","slug":"a8eb012039114ca6a601a1c34622ba93","date":"2023-01-19T12:19:27.414Z","updated":"2023-01-19T12:19:41.348Z","comments":true,"path":"2023/01/19/a8eb012039114ca6a601a1c34622ba93/","link":"","permalink":"http://example.com/2023/01/19/a8eb012039114ca6a601a1c34622ba93/","excerpt":"","text":"BorderLayout 123456789101112131415161718192021222324252627282930313233343536package cn.javagui.awt;import java.awt.*;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;public class BorderLayout_ &#123; public static void main(String[] args) &#123; Frame frame = new Frame(); frame.setBounds(500,500,500,300); frame.setAlwaysOnTop(true);; frame.setVisible(true); Dimension screen_size = Toolkit.getDefaultToolkit().getScreenSize();// 获取屏幕粉白嫩绿 int middle_x = (int) (screen_size.getWidth() / 2 - frame.getWidth() / 2); // 中间横坐标 int middle_y = (int) (screen_size.getHeight() / 2 - frame.getHeight() / 2);// 中间纵坐标 frame.setLocation(middle_x, middle_y); // 设置窗口显示位置，显示再屏幕正中间 frame.setFont(new Font(&quot;SimSong&quot;, Font.BOLD, 20)); frame.addWindowListener(new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; System.out.println(&quot;程序退出成功!&quot;); System.exit(0); &#125; &#125;); BorderLayout layout = new BorderLayout(); frame.setLayout(layout);; layout.setHgap(50); //横向边距 layout.setVgap(50); //纵向边距 frame.add(new Button(&quot;number1&quot;),BorderLayout.WEST); frame.add(new Button(&quot;number2&quot;),BorderLayout.EAST); frame.add(new Button(&quot;number3&quot;),BorderLayout.NORTH); frame.add(new Button(&quot;number4&quot;),BorderLayout.SOUTH); frame.add(new Button(&quot;number5&quot;),BorderLayout.CENTER); &#125;&#125; FlowLayout 1234567891011121314151617181920212223242526272829303132333435package cn.javagui.awt;import java.awt.*;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;public class FlowLayout_ &#123; public static void main(String[] args) &#123; Frame frame = new Frame(); frame.setSize(500,500); frame.setAlwaysOnTop(true);; frame.setVisible(true); Dimension screen_size = Toolkit.getDefaultToolkit().getScreenSize();// 获取屏幕粉白嫩绿 int middle_x = (int) (screen_size.getWidth() / 2 - frame.getWidth() / 2); // 中间横坐标 int middle_y = (int) (screen_size.getHeight() / 2 - frame.getHeight() / 2);// 中间纵坐标 frame.setLocation(middle_x, middle_y); // 设置窗口显示位置，显示再屏幕正中间 frame.setFont(new Font(&quot;SimSong&quot;, Font.BOLD, 20)); frame.addWindowListener(new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; System.out.println(&quot;程序退出成功!&quot;); System.exit(0); &#125; &#125;); FlowLayout flowLayout = new FlowLayout(); flowLayout.setAlignment(FlowLayout.LEFT); flowLayout.setHgap(50); frame.setLayout(flowLayout); frame.add(new Button(&quot;number1&quot;)); frame.add(new Button(&quot;number2&quot;)); frame.add(new Button(&quot;number3&quot;)); frame.add(new Button(&quot;number4&quot;)); frame.add(new Button(&quot;number5&quot;)); &#125;&#125; GridLayout 12345678910111213141516171819202122232425262728293031323334package cn.javagui.awt;import java.awt.*;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;public class GridLayout_ &#123; public static void main(String[] args) &#123; Frame frame = new Frame(); frame.setVisible(true); frame.setAlwaysOnTop(true); frame.setSize(900, 600); Dimension screen_size = Toolkit.getDefaultToolkit().getScreenSize(); int middle_x = (int) (screen_size.getWidth() / 2); int middle_y = (int) (screen_size.getHeight() / 2); frame.setLocation(middle_x, middle_y); frame.setFont(new Font(&quot;SimSong&quot;, Font.BOLD, 20)); frame.addWindowListener(new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; System.exit(0); System.out.println(&quot;程序退出成功&quot;); &#125; &#125;); GridLayout layout = new GridLayout(); layout.setRows(3); layout.setColumns(3); frame.setLayout(layout); for (int i = 1; i &lt;= 6; i++) &#123; frame.add(new Button(i + &quot;button&quot;)); &#125; &#125;&#125; CardLayout 12345678910111213141516171819202122232425262728293031323334353637383940package cn.javagui.awt;import java.awt.*;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;public class CardLayout_ &#123; public static void main(String[] args) throws InterruptedException &#123; Frame frame = new Frame(); frame.setSize(500,500); frame.setAlwaysOnTop(true);; frame.setVisible(true); Dimension screen_size = Toolkit.getDefaultToolkit().getScreenSize();// 获取屏幕粉白嫩绿 int middle_x = (int) (screen_size.getWidth() / 2 - frame.getWidth() / 2); // 中间横坐标 int middle_y = (int) (screen_size.getHeight() / 2 - frame.getHeight() / 2);// 中间纵坐标 frame.setLocation(middle_x, middle_y); // 设置窗口显示位置，显示再屏幕正中间 frame.setFont(new Font(&quot;SimSong&quot;, Font.BOLD, 20)); frame.addWindowListener(new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; System.out.println(&quot;程序退出成功!&quot;); System.exit(0); &#125; &#125;); CardLayout layout = new CardLayout(); frame.setLayout(layout); frame.add(new Label(&quot;num 1&quot;)); frame.add(new Label(&quot;num 2&quot;)); frame.add(new Label(&quot;num 3&quot;)); while(true)&#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; layout.next(frame); //我们需要使用CardLayout对象来进行切换 &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"Java-GUi","slug":"Java/Java-GUi","permalink":"http://example.com/categories/Java/Java-GUi/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"Java-GUI-常用组件","slug":"2c969cb92c56489ab91482067305ab42","date":"2023-01-19T12:19:24.548Z","updated":"2023-01-19T12:19:25.785Z","comments":true,"path":"2023/01/19/2c969cb92c56489ab91482067305ab42/","link":"","permalink":"http://example.com/2023/01/19/2c969cb92c56489ab91482067305ab42/","excerpt":"","text":"Java-GUI-常用组件 组件实际上是AWT为我们预设好的一些可以直接使用的界面元素，比如按钮，文字框，标签等等，我们可以使用这些已经帮我们写好的组件来快速拼凑出一个好看且功能强大的程序 在学习组件之前，我们先将布局设定为null,因为默认情况下会采用BorderLayout作为布局,有关布局会在下一部分中进行介绍 标签 12345678910111213141516171819202122232425262728293031323334package cn.javagui.awt;import java.awt.*;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;public class Component &#123; public static void main(String[] args) &#123; Frame frame = new Frame(); frame.setTitle(&quot;组件&quot;); frame.setLayout(null); frame.setSize(700, 500); frame.setVisible(true); frame.setBackground(Color.ORANGE); Dimension screen_size = Toolkit.getDefaultToolkit().getScreenSize();// 获取屏幕粉白嫩绿 int middle_x = (int) (screen_size.getWidth() / 2 - frame.getWidth() / 2); // 中间横坐标 int middle_y = (int) (screen_size.getHeight() / 2 - frame.getHeight() / 2);// 中间纵坐标 frame.setLocation(middle_x, middle_y); // 设置窗口显示位置，显示再屏幕正中间 frame.addWindowListener(new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; System.out.println(&quot;程序退出成功!&quot;); System.exit(0); &#125; &#125;); Label label = new Label();// 添加标签只需要创建要个Label对象即可 label.setLocation(20, 50); label.setSize(350, 20); label.setFont(new Font(&quot;SimSong&quot;, Font.BOLD, 20)); // 设置标签字体 label.setText(&quot;I am a label&quot;); frame.add(label);// 使用add方法添加组件到窗口中 &#125;&#125; 按钮 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package cn.javagui.awt;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;public class Component &#123; public static void main(String[] args) &#123; Frame frame = new Frame(); frame.setTitle(&quot;组件&quot;); frame.setLayout(null); frame.setSize(700, 500); frame.setVisible(true); frame.setBackground(Color.ORANGE); Dimension screen_size = Toolkit.getDefaultToolkit().getScreenSize();// 获取屏幕粉白嫩绿 int middle_x = (int) (screen_size.getWidth() / 2 - frame.getWidth() / 2); // 中间横坐标 int middle_y = (int) (screen_size.getHeight() / 2 - frame.getHeight() / 2);// 中间纵坐标 frame.setLocation(middle_x, middle_y); // 设置窗口显示位置，显示再屏幕正中间 frame.addWindowListener(new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; System.out.println(&quot;程序退出成功!&quot;); System.exit(0); &#125; &#125;); Label label = new Label(&quot;标签添加成功!&quot;); label.setFont(new Font(&quot;SimSong&quot;, Font.BOLD, 20)); label.setBounds(20, 100, 200, 50); label.setBackground(Color.YELLOW); /* 按钮 */ Button button = new Button(&quot;我是按钮&quot;); button.setBounds(20, 50, 100, 50); button.setFont(new Font(&quot;SimSong&quot;, Font.BOLD, 20)); button.setBackground(Color.yellow); button.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; frame.add(label); System.out.println(&quot;标签添加成功&quot;); &#125; &#125;); frame.add(button); &#125;&#125; 文本域 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package cn.javagui.awt;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;public class Component &#123; public static void main(String[] args) &#123; Frame frame = new Frame(); frame.setTitle(&quot;组件&quot;); frame.setLayout(null); frame.setSize(700, 500); frame.setVisible(true); frame.setBackground(Color.ORANGE); Dimension screen_size = Toolkit.getDefaultToolkit().getScreenSize();// 获取屏幕粉白嫩绿 int middle_x = (int) (screen_size.getWidth() / 2 - frame.getWidth() / 2); // 中间横坐标 int middle_y = (int) (screen_size.getHeight() / 2 - frame.getHeight() / 2);// 中间纵坐标 frame.setLocation(middle_x, middle_y); // 设置窗口显示位置，显示再屏幕正中间 frame.addWindowListener(new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; System.out.println(&quot;程序退出成功!&quot;); System.exit(0); &#125; &#125;); Label label = new Label(); label.setFont(new Font(&quot;SimSong&quot;, Font.BOLD, 20)); label.setBounds(20, 100, 200, 50); label.setBackground(Color.YELLOW); // 文本框 TextField field = new TextField(); field.setBounds(20, 150, 200, 50); field.setFont(new Font(&quot;SimSong&quot;, Font.BOLD, 20)); frame.add(field); /* 按钮 */ Button button = new Button(&quot;Click&quot;); button.setBounds(20, 50, 100, 50); button.setFont(new Font(&quot;SimSong&quot;, Font.BOLD, 20)); button.setBackground(Color.yellow); button.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; String text = field.getText(); // 获取文本框中的内容 label.setText(text);// 把文本框中的内容放在label标签中 frame.add(label);// 把label标签加入到整个页面中 System.out.println(&quot;Info: Label and text add successfully&quot;); &#125; &#125;); frame.add(button); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"Java-GUi","slug":"Java/Java-GUi","permalink":"http://example.com/categories/Java/Java-GUi/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"Java-GUI-监听器","slug":"f172572c7d114592aaa804efa121761e","date":"2023-01-19T12:18:58.211Z","updated":"2023-01-19T12:19:13.715Z","comments":true,"path":"2023/01/19/f172572c7d114592aaa804efa121761e/","link":"","permalink":"http://example.com/2023/01/19/f172572c7d114592aaa804efa121761e/","excerpt":"","text":"监听器我们可以为窗口添加一系列的监听器，监听器会监听窗口中发生的一些事件，比如我们点击关闭窗口，移动鼠标，鼠标点击等，当发生对应的事件时候，就会通知到对应的监听器进行处理，从而我们就能够再发生对应事件时候进行处理 比如我们现在希望点击关闭按钮关闭当前的窗口,但是我们发现默认情况下实际上是关不掉的,因为我们没有对关闭事件进行处理,默认情况下对于这种点击时没有设定任何动作的,万一我们点了之后并不是要关闭窗口呢,要实现关闭窗口,我们可以使用addXXXListener来添加对应的事件监听器,比如窗口相关的操作那么就是WindowListener 监听器实现点击X号关闭窗口 12345678910111213141516171819202122232425262728293031323334package cn.javagui.awt;import java.awt.*;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;public class Main &#123; public static void main(String[] args) &#123; Frame frame = new Frame(); frame.setTitle(&quot;第一个窗口程序&quot;); frame.setVisible(true); //窗口设置为可见 frame.setBackground(Color.ORANGE); //设置窗口背景颜色 frame.setSize(700,500); //使用setSize方法设定窗体大小 frame.setResizable(true);//设置窗口大小是否可以调整 frame.setAlwaysOnTop(true); //设置窗口是否始终展示在最前面 Dimension screen_size = Toolkit.getDefaultToolkit().getScreenSize();//获取屏幕粉白嫩绿 int middle_x = (int) (screen_size.getWidth()/2 - frame.getWidth()/2); //中间横坐标 int middle_y = (int)(screen_size.getHeight() / 2-frame.getHeight() / 2);//中间纵坐标 frame.setLocation(middle_x,middle_y); //设置窗口显示位置，显示再屏幕正中间 /*监听器*/ //添加监听器 frame.addWindowListener(new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; frame.dispose(); //关闭当前窗口 //或者使用System.exit(0); System.out.println(&quot;窗口已经关闭!&quot;); &#125; &#125;); &#125;&#125; 窗口常用事件 键盘事件 12345678910111213141516171819202122232425262728293031323334353637383940package cn.javagui.awt;import java.awt.*;import java.awt.event.KeyAdapter;import java.awt.event.KeyEvent;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;public class Main &#123; public static void main(String[] args) &#123; Frame frame = new Frame(); frame.setTitle(&quot;第一个窗口程序&quot;); frame.setVisible(true); //窗口设置为可见 frame.setBackground(Color.ORANGE); //设置窗口背景颜色 frame.setSize(700,500); //使用setSize方法设定窗体大小 frame.setResizable(true);//设置窗口大小是否可以调整 frame.setAlwaysOnTop(true); //设置窗口是否始终展示在最前面 Dimension screen_size = Toolkit.getDefaultToolkit().getScreenSize();//获取屏幕粉白嫩绿 int middle_x = (int) (screen_size.getWidth()/2 - frame.getWidth()/2); //中间横坐标 int middle_y = (int)(screen_size.getHeight() / 2-frame.getHeight() / 2);//中间纵坐标 frame.setLocation(middle_x,middle_y); //设置窗口显示位置，显示再屏幕正中间 /*监听器*/ //添加监听器 frame.addWindowListener(new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; System.exit(0); System.out.println(&quot;窗口已经关闭!&quot;); &#125; &#125;); frame.addKeyListener(new KeyAdapter() &#123; @Override public void keyPressed(KeyEvent e) &#123; System.out.print(e.getKeyChar()); &#125; &#125;); &#125;&#125; 常用事件 鼠标事件 1234567891011121314151617181920212223242526272829303132333435363738394041424344package cn.javagui.awt;import java.awt.*;import java.awt.event.*;public class Main &#123; public static void main(String[] args) &#123; Frame frame = new Frame(); frame.setTitle(&quot;第一个窗口程序&quot;); frame.setVisible(true); //窗口设置为可见 frame.setBackground(Color.ORANGE); //设置窗口背景颜色 frame.setSize(700, 500); //使用setSize方法设定窗体大小 frame.setResizable(true);//设置窗口大小是否可以调整 frame.setAlwaysOnTop(true); //设置窗口是否始终展示在最前面 Dimension screen_size = Toolkit.getDefaultToolkit().getScreenSize();//获取屏幕粉白嫩绿 int middle_x = (int) (screen_size.getWidth() / 2 - frame.getWidth() / 2); //中间横坐标 int middle_y = (int) (screen_size.getHeight() / 2 - frame.getHeight() / 2);//中间纵坐标 frame.setLocation(middle_x, middle_y); //设置窗口显示位置，显示再屏幕正中间 /*监听器*/ //添加监听器 frame.addWindowListener(new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; System.exit(0); System.out.println(&quot;窗口已经关闭!&quot;); &#125; &#125;); frame.addKeyListener(new KeyAdapter() &#123; @Override public void keyPressed(KeyEvent e) &#123; System.out.print(e.getKeyChar()); &#125; &#125;); frame.addMouseListener(new MouseAdapter() &#123; @Override public void mouseClicked(MouseEvent e) &#123; System.out.println(&quot;鼠标位置\\nx:&quot; + e.getX() + &quot;\\t&quot; + &quot;y:&quot; + e.getY()); &#125; &#125;); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"Java-GUi","slug":"Java/Java-GUi","permalink":"http://example.com/categories/Java/Java-GUi/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"Java-GUI-窗口配置","slug":"f7310f53495a4e258159180b2ce529db","date":"2023-01-19T12:18:41.357Z","updated":"2023-01-19T12:56:34.605Z","comments":true,"path":"2023/01/19/f7310f53495a4e258159180b2ce529db/","link":"","permalink":"http://example.com/2023/01/19/f7310f53495a4e258159180b2ce529db/","excerpt":"","text":"第一个窗口想使用java创建窗口，我们要导入import java.awt.*;然后创建第一个窗口 1234567891011121314151617181920package cn.javagui.awt;import java.awt.*;public class Main &#123; public static void main(String[] args) &#123; Frame frame = new Frame(); frame.setTitle(&quot;第一个窗口程序&quot;); frame.setVisible(true); //窗口设置为可见 frame.setBackground(Color.ORANGE); //设置窗口背景颜色 frame.setSize(700,500); //使用setSize方法设定窗体大小 frame.setResizable(true);//设置窗口大小是否可以调整 frame.setAlwaysOnTop(true); //设置窗口是否始终展示在最前面 Dimension screen_size = Toolkit.getDefaultToolkit().getScreenSize();//获取屏幕粉白嫩绿 int middle_x = (int) (screen_size.getWidth()/2 - frame.getWidth()/2); //中间横坐标 int middle_y = (int)(screen_size.getHeight() / 2-frame.getHeight() / 2);//中间纵坐标 frame.setLocation(middle_x,middle_y); //设置窗口显示位置，显示再屏幕正中间 frame.setCursor(new Cursor(Cursor.CROSSHAIR_CURSOR)); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"Java-GUi","slug":"Java/Java-GUi","permalink":"http://example.com/categories/Java/Java-GUi/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"Java 集合","slug":"338f5f76a1914f72822772ea3026f220","date":"2023-01-19T11:59:08.418Z","updated":"2023-01-19T11:59:24.454Z","comments":true,"path":"2023/01/19/338f5f76a1914f72822772ea3026f220/","link":"","permalink":"http://example.com/2023/01/19/338f5f76a1914f72822772ea3026f220/","excerpt":"","text":"Java-集合集合框架图 Collection接口和常用方法 Collection接口常用方法,以实现子类ArrayList来演示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package cn.meowrain.collection_;import java.util.ArrayList;import java.util.List;public class CollectionMethod &#123; @SuppressWarnings(&#123;&quot;all&quot;&#125;) public static void main(String[] args) &#123; List list = new ArrayList(); list.add(&quot;jack&quot;); list.add(&quot;meowrain&quot;); list.add(&quot;hello&quot;); System.out.println(&quot;初始元素: &quot; + list); System.out.println(&quot;--------------------&quot;); //用索引删除,返回的是删除的对象 //用对象名删除,返回的是一个布尔值,删除成功返回true,删除失败返回false System.out.println(&quot;删除的元素是:&quot; + list.remove(0) + &quot; &quot; + &quot;\\n 当前的元素为:&quot; + list); System.out.println(&quot;----------------------&quot;); System.out.println(&quot;删除状态:&quot; + list.remove(&quot;hello&quot;) + &quot; &quot; + &quot;\\n 当前的元素为:&quot; + list); System.out.println(&quot;----------------------&quot;); //size返回元素个数 System.out.println(&quot;当前List中的元素个数:&quot; + list.size()); //返回list中是否含有某元素 System.out.println(&quot;list中是否含有 meowrain 这个元素&quot; + list.contains(&quot;meowrain&quot;)); System.out.println(&quot;---------------------&quot;); //clean 清空整个表 System.out.println(&quot;接下来使用clear操作清空list&quot;); list.clear(); System.out.println(&quot;当前List中的元素个数:&quot; + list.size()); //isEmpty System.out.println(&quot;判断当前表是否为空:&quot; + list.isEmpty()); //addAll添加多个元素 List list2 = new ArrayList(); list2.add(&quot;红楼梦&quot;); list2.add(&quot;三国&quot;); list2.add(&quot;nice&quot;); list.addAll(list2); System.out.println(&quot;addAll后的list: &quot; + list); System.out.println(&quot; --------------&quot;); //containsAll System.out.println(&quot;containsAll&quot;); List list3 = new ArrayList(); list3.add(&quot;nice&quot;); list3.add(&quot;三国&quot;); list.containsAll(list3); // true //removeAll System.out.println(&quot;-------------&quot;); List list4 = new ArrayList(); list4.add(&quot;nice&quot;); list4.add(&quot;三国&quot;); list.removeAll(list4); System.out.println(&quot;removeAll后的list: &quot; + list); &#125;&#125; Collection接口遍历元素的方式Iterator迭代器 在调用iterator.next()方法之前必须调用iterator.hasNext()进行检测,若不调用,且下一条记录无效,直接调用it.next()会抛出NoSuchElementException异常 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package cn.meowrain.collection_;import java.util.ArrayList;import java.util.Collection;import java.util.Iterator;public class CollectionIterator &#123; @SuppressWarnings(&#123;&quot;all&quot;&#125;) public static void main(String[] args) &#123; Collection col = new ArrayList(); col.add(new Book(&quot;三国演义&quot;,&quot;罗贯中&quot;,10.1)); col.add(new Book(&quot;小李飞刀&quot;,&quot;古龙&quot;,5.1)); col.add(new Book(&quot;红楼梦&quot;,&quot;曹雪芹&quot;,34.6));// System.out.println(&quot;col = &quot;+ col); //现在希望能够遍历col集合 //先得到col对应的迭代器 Iterator iterator = col.iterator(); //使用while循环遍历即可 while(iterator.hasNext())&#123; //判断是否还有数据 //返回下一个元素,类型是Object Object obj = iterator.next(); System.out.println(obj); &#125; /* * * Book&#123;name=&#x27;三国演义&#x27;, author=&#x27;罗贯中&#x27;, price=10.1&#125; Book&#123;name=&#x27;小李飞刀&#x27;, author=&#x27;古龙&#x27;, price=5.1&#125; Book&#123;name=&#x27;红楼梦&#x27;, author=&#x27;曹雪芹&#x27;, price=34.6&#125; * */ &#125;&#125;class Book &#123; private String name; private String author; private double price; public Book(String name, String author, double price) &#123; this.name = name; this.author = author; this.price = price; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAuthor() &#123; return author; &#125; public void setAuthor(String author) &#123; this.author = author; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125; @Override public String toString() &#123; return &quot;Book&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, author=&#x27;&quot; + author + &#x27;\\&#x27;&#x27; + &quot;, price=&quot; + price + &#x27;&#125;&#x27;; &#125;&#125; 增强for循环12345//增强for也能用在数组上int[] nums = new int[]&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;;for (int num : nums) &#123; System.out.print(num + &quot; &quot;);//1 2 3 4 5 6 7 8 9 10 &#125; 在Collection集合上的应用 123456789101112131415161718192021222324252627282930package cn.meowrain.collection_;import java.util.ArrayList;import java.util.Collection;public class CollectionFor &#123; @SuppressWarnings(&#123;&quot;all&quot;&#125;) public static void main(String[] args) &#123; Collection col = new ArrayList(); col.add(new Book(&quot;三国演义&quot;, &quot;罗贯中&quot;, 10.1)); col.add(new Book(&quot;小李飞刀&quot;, &quot;古龙&quot;, 5.1)); col.add(new Book(&quot;红楼梦&quot;, &quot;曹雪芹&quot;, 34.6)); //使用增强for循环,for循环底层,仍然是迭代器,可以理解成简化版本的迭代器 for (Object book : col) &#123; System.out.println(book); &#125; /* * Book&#123;name=&#x27;三国演义&#x27;, author=&#x27;罗贯中&#x27;, price=10.1&#125; Book&#123;name=&#x27;小李飞刀&#x27;, author=&#x27;古龙&#x27;, price=5.1&#125; Book&#123;name=&#x27;红楼梦&#x27;, author=&#x27;曹雪芹&#x27;, price=34.6&#125; * * */ &#125;&#125; ​ 快捷方式;输入I 课堂练习 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package cn.meowrain.collection_;import java.util.ArrayList;import java.util.Iterator;import java.util.List;public class CollectionExercise &#123; public static void main(String[] args) &#123; Dog dog1 = new Dog(&quot;mike&quot;, 1); Dog dog2 = new Dog(&quot;john&quot;, 4); Dog dog3 = new Dog(&quot;cookie&quot;, 5); List&lt;Dog&gt; list = new ArrayList&lt;&gt;(); list.add(dog1); list.add(dog2); list.add(dog3); //迭代器方法 System.out.println(&quot;----------普通迭代器方法----------&quot;); Iterator iterator = list.iterator(); while (iterator.hasNext()) &#123; Object next = iterator.next(); System.out.println(next); &#125; //增强for循环方法 System.out.println(&quot;----------增强for循环方法----------&quot;); for (Dog dog : list) &#123; System.out.println(dog); &#125; &#125;&#125;class Dog &#123; String name; int age; public Dog(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Dog&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; List接口 List接口是Collection接口的子接口 123456789101112131415161718192021package cn.meowrain.collection_;import java.util.ArrayList;import java.util.List;public class List_ &#123; public static void main(String[] args) &#123; List list = new ArrayList(); list.add(&quot;jack&quot;); list.add(&quot;tom&quot;); list.add(&quot;mary&quot;); list.add(&quot;hsp&quot;); list.add(&quot;meowrain&quot;); list.add(&quot;meowrain&quot;); //可以重复 System.out.println(list);//顺序表 //索引从0开始 System.out.println(list.get(1)); &#125;&#125; List接口的常用方法: List接口常用方法 123456789101112131415161718192021222324252627package cn.meowrain.collection_;import java.util.ArrayList;import java.util.Iterator;import java.util.List;public class ListExercise &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); for (int i = 0; i &lt; 12; i++) &#123; list.add(&quot;hello&quot; + i); &#125; list.add(1, &quot;韩顺平教育&quot;); String num5_string = list.get(4); list.remove(5); list.set(6, &quot;meowrainyyds&quot;); Iterator&lt;String&gt; iterator = list.iterator(); System.out.println(&quot;第5个元素:&quot; + num5_string); while (iterator.hasNext()) &#123; Object next = iterator.next(); System.out.println(next); &#125; &#125;&#125; List的三种遍历方式 12345678910111213141516171819202122232425262728293031323334package cn.meowrain.collection_;import java.util.List;import java.util.ArrayList;import java.util.Iterator;public class ListFor &#123; public static void main(String[] args) &#123; //iterator List&lt;String&gt; list = new ArrayList&lt;String&gt;(); for (int i = 0; i &lt; 10; i++) &#123; list.add(&quot;nice&quot; + i); &#125; //遍历 System.out.println(&quot;==========Iterator============&quot;); Iterator&lt;String&gt; iterator = list.iterator(); while (iterator.hasNext()) &#123; String next = iterator.next(); System.out.println(next); &#125; //增强for循环 System.out.println(&quot;==========增强for============&quot;); for (String s : list) &#123; System.out.println(s); &#125; //普通for循环 System.out.println(&quot;==========普通for循环============&quot;); for (int i = 0; i &lt; list.size(); i++) &#123; System.out.println(list.get(i)); &#125; &#125;&#125; 练习题 ArrayList方法ListExercise2.java 12345678910111213141516171819202122232425262728293031323334353637383940414243package cn.meowrain.collection_;import java.util.Iterator;import java.util.List;import java.util.ArrayList;public class ListExercise2 &#123; @SuppressWarnings(&#123;&quot;all&quot;&#125;) public static void main(String[] args) &#123; List&lt;Book&gt; list = new ArrayList&lt;&gt;(); list.add(new Book(&quot;西游记&quot;, &quot;吴承恩&quot;, 100)); list.add(new Book(&quot;三国演义&quot;, &quot;罗贯中&quot;, 10.1)); list.add(new Book(&quot;小李飞刀&quot;, &quot;古龙&quot;, 5.1)); list.add(new Book(&quot;红楼梦&quot;, &quot;曹雪芹&quot;, 34.6)); list.add(new Book(&quot;三体&quot;, &quot;刘慈欣&quot;, 51)); //排序 Bubble_sort(list); //遍历输出 Iterator&lt;Book&gt; iterator = list.iterator(); while (iterator.hasNext()) &#123; Book next = iterator.next(); System.out.println(next); &#125; &#125; public static void Bubble_sort(List&lt;Book&gt; list) &#123; //遍历list int size = list.size(); for (int i = 0; i &lt; size - 1; i++) &#123; for (int j = 0; j &lt; size - 1 - i; j++) &#123; //取出对象 Book book1 = list.get(j); Book book2 = list.get(j + 1); if (book1.getPrice() &gt; book2.getPrice()) &#123; list.set(j, book2); list.set(j + 1, book1); &#125; &#125; &#125; &#125;&#125; Book.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package cn.meowrain.collection_;public class Book &#123; private String name; private String author; private double price; public Book(String name, String author, double price) &#123; this.name = name; this.author = author; this.price = price; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAuthor() &#123; return author; &#125; public void setAuthor(String author) &#123; this.author = author; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125; @Override public String toString() &#123; return &quot;Book&#123;&quot; + &quot;书名=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, 作者=&#x27;&quot; + author + &#x27;\\&#x27;&#x27; + &quot;, 价格=&quot; + price + &#x27;&#125;&#x27;; &#125;&#125; 输出结果 ArrayList注意事项 ArrayList是线程不安全的,可以看源码,没有synchronized ArrayList底层结构和源码分析 Vector源码剖析 Vector和ArrayList的区别 Vector底层 1234567891011121314package cn.meowrain.collection_;import java.util.Vector;public class Vector_ &#123; public static void main(String[] args) &#123; Vector&lt;Number&gt; vector = new Vector&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; vector.add(i); &#125; System.out.println(vector); &#125;&#125; ArrayList和LinkedList的区别 Set接口和常用方法Set接口基本介绍 无序 不允许重复元素,最多包含一个null Set接口常用方法和 List 接口一样, Set 接口也是 Collection 的子接口，因此，常用方法和 Collection 接口一样 Set接口的遍历方式 Set 接口的常用方法举例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package cn.meowrain.collection_;import java.util.HashSet;import java.util.Iterator;import java.util.Set;public class SetMethod &#123; public static void main(String[] args) &#123; /* * //1. 以 Set 接口的实现类 HashSet 来讲解 Set 接口的方法 //2. set 接口的实现类的对象(Set 接口对象), 不能存放重复的元素, 可以添加一个 null //3. set 接口对象存放数据是无序(即添加的顺序和取出的顺序不一致) //4. 注意：取出的顺序的顺序虽然不是添加的顺序，但是他的固定*/ Set&lt;String&gt; set = new HashSet&lt;&gt;(); set.add(&quot;meow&quot;); set.add(&quot;neko&quot;); set.add(&quot;meow&quot;); set.add(null); set.add(null); System.out.println(set); System.out.println(&quot;==========Iterator==========&quot;); //遍历: //方式一: Iterator Iterator&lt;String&gt; iterator = set.iterator(); while (iterator.hasNext())&#123; String next = iterator.next(); System.out.println(next); &#125; System.out.println(&quot;==========增强for循环==========&quot;); ////方式 2: 增强for循环 for (String s : set) &#123; System.out.println(s); &#125;/**** [null, meow, neko]==========Iterator==========nullmeowneko==========增强for循环==========nullmeowneko*/ &#125;&#125; Set 接口实现类-HashSet HashSet 案例说明12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package cn.meowrain.collection_;import java.util.Set;import java.util.HashSet;public class HashSet_ &#123; public static void main(String[] args) &#123; HashSet set = new HashSet(); //说明 //1. 在执行 add 方法后，会返回一个 boolean 值 //2. 如果添加成功，返回 true, 否则返回 false //3. 可以通过 remove 指定删除哪个对象 System.out.println(set.add(&quot;meow&quot;)); // True System.out.println(set.add(&quot;neko&quot;));// True System.out.println(set.add(&quot;jack&quot;));// True System.out.println(set.add(&quot;mmm&quot;));// True System.out.println(set.add(&quot;rose&quot;));// True //当我们重复添加元素的时候 System.out.println(set.add(&quot;meow&quot;));//false //当我们添加对象的时候 System.out.println(set.add(new Dog(&quot;大黄&quot;,3)));// True System.out.println(set.add(new Dog(&quot;大黄&quot;,3)));// True System.out.println(&quot;set = &quot; + set); //set = [meow, neko, Dog&#123;name=&#x27;大黄&#x27;, age=3&#125;, rose, Dog&#123;name=&#x27;大黄&#x27;, age=3&#125;, mmm, jack] &#125;&#125;class Dog_Set &#123; String name; int age; public Dog_Set(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Dog_Set&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; HashSet 练习 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package cn.meowrain.collection_;import java.util.HashSet;import java.util.Objects;public class HashSetExercise &#123; public static void main(String[] args) &#123; HashSet hashSet = new HashSet(); hashSet.add(new Employee(&quot;milan&quot;,10)); hashSet.add(new Employee(&quot;smith&quot;,29)); hashSet.add(new Employee(&quot;milan&quot;,10)); System.out.println(&quot;Hashset = &quot; + hashSet); &#125;&#125;class Employee &#123; String name; int age; public Employee(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Employee&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Employee employee = (Employee) o; return age == employee.age &amp;&amp; Objects.equals(name, employee.name); &#125; @Override public int hashCode() &#123; return Objects.hash(name, age); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package cn.meowrain.collection_;import java.util.HashSet;import java.util.Iterator;import java.util.Objects;public class HashSetExercise2 &#123; public static void main(String[] args) &#123; HashSet hashset = new HashSet(); hashset.add(new Employee2(&quot;milan&quot;,1230.9, new MyDate(2001,12,3))); hashset.add(new Employee2(&quot;meowrain&quot;,10000,new MyDate(2003,12,20))); hashset.add(new Employee2(&quot;milan&quot;,2300.9, new MyDate(2001,12,3))); Iterator&lt;Employee2&gt; iter = hashset.iterator(); while (iter.hasNext()) &#123; Employee2 next = iter.next(); System.out.println(next); &#125; &#125;&#125;class Employee2 &#123; private String name; private double sal; private MyDate birthday; public Employee2(String name, double sal, MyDate birthday) &#123; this.name = name; this.sal = sal; this.birthday = birthday; &#125; @Override public String toString() &#123; return &quot;Employee2&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, sal=&quot; + sal + &quot;, birthday=&quot; + birthday + &#x27;&#125;&#x27;; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Employee2 employee2 = (Employee2) o; return Objects.equals(name, employee2.name); &#125; @Override public int hashCode() &#123; return Objects.hash(name); &#125;&#125;class MyDate &#123; public int year; public int month; public int day; public MyDate(int year, int month, int day) &#123; this.year = year; this.month = month; this.day = day; &#125; @Override public String toString() &#123; return &quot;MyDate&#123;&quot; + &quot;year=&quot; + year + &quot;, month=&quot; + month + &quot;, day=&quot; + day + &#x27;&#125;&#x27;; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; MyDate myDate = (MyDate) o; return year == myDate.year &amp;&amp; month == myDate.month &amp;&amp; day == myDate.day; &#125; @Override public int hashCode() &#123; return Objects.hash(year, month, day); &#125;&#125; LinkedHashSet 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package cn.meowrain.collection_;import java.util.LinkedHashSet;import java.util.Objects;public class LinkedHashSet_ &#123; public static void main(String[] args) &#123; LinkedHashSet linkedHashSet = new LinkedHashSet(); linkedHashSet.add(new Car(&quot;奥拓&quot;, 1000));//OK linkedHashSet.add(new Car(&quot;奥迪&quot;, 300000));//OK linkedHashSet.add(new Car(&quot;法拉利&quot;, 10000000));//OK linkedHashSet.add(new Car(&quot;奥迪&quot;, 300000));//加入不了 linkedHashSet.add(new Car(&quot;保时捷&quot;, 70000000));//OK linkedHashSet.add(new Car(&quot;奥迪&quot;, 300000));//加入不了 for (Object o : linkedHashSet) &#123; System.out.println(o); &#125; &#125;&#125;class Car &#123; private String name; private double price; public Car(String name, double price) &#123; this.name = name; this.price = price; &#125; @Override public String toString() &#123; return &quot;Car&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, price=&quot; + price + &#x27;&#125;&#x27;; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Car car = (Car) o; return Double.compare(car.price, price) == 0 &amp;&amp; Objects.equals(name, car.name); &#125; @Override public int hashCode() &#123; return Objects.hash(name, price); &#125;&#125; Map接口和常用方法Map接口实现类的特点 在Map中，这些映射关系被存储为键值对，我们先来看看Map接口中定义了哪些操作： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//Map并不是Collection体系下的接口，而是单独的一个体系，因为操作特殊//这里需要填写两个泛型参数，其中K就是键的类型，V就是值的类型，比如上面的学生信息，ID一般是int，那么键就是Integer类型的，而值就是学生信息，所以说值是学生对象类型的public interface Map&lt;K,V&gt; &#123; //-------- 查询相关操作 -------- //获取当前存储的键值对数量 int size(); //是否为空 boolean isEmpty(); //查看Map中是否包含指定的键 boolean containsKey(Object key); //查看Map中是否包含指定的值 boolean containsValue(Object value); //通过给定的键，返回其映射的值 V get(Object key); //-------- 修改相关操作 -------- //向Map中添加新的映射关系，也就是新的键值对 V put(K key, V value); //根据给定的键，移除其映射关系，也就是移除对应的键值对 V remove(Object key); //-------- 批量操作 -------- //将另一个Map中的所有键值对添加到当前Map中 void putAll(Map&lt;? extends K, ? extends V&gt; m); //清空整个Map void clear(); //-------- 其他视图操作 -------- //返回Map中存放的所有键，以Set形式返回 Set&lt;K&gt; keySet(); //返回Map中存放的所有值 Collection&lt;V&gt; values(); //返回所有的键值对，这里用的是内部类Entry在表示 Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet(); //这个是内部接口Entry，表示一个键值对 interface Entry&lt;K,V&gt; &#123; //获取键值对的键 K getKey(); //获取键值对的值 V getValue(); //修改键值对的值 V setValue(V value); //判断两个键值对是否相等 boolean equals(Object o); //返回当前键值对的哈希值 int hashCode(); ... &#125; ...&#125; 测试： 1234567891011121314151617package cn.meowrain.collection_;import java.util.HashMap;import java.util.Map;public class Map_ &#123; public static void main(String[] args) &#123; Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); map.put(1, &quot;meowrian&quot;); map.put(2, &quot;mike&quot;); System.out.println(map.get(1)); //meowrian map.remove(2); map.remove(1); System.out.println(map.isEmpty());// true &#125;&#125; 注意，Map中无法添加相同的键，同样的键只能存在一个，即使值不同。如果出现键相同的情况，那么会覆盖掉之前的 123456789101112131415package cn.meowrain.collection_;import java.util.HashMap;import java.util.Map;public class Map_ &#123; public static void main(String[] args) &#123; Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); map.put(1, &quot;meowrian&quot;); map.put(1,&quot;meowrain&quot;); map.remove(1); System.out.println(map.isEmpty()); // true &#125;&#125; 为了防止意外将之前的键值对覆盖掉，我们可以使用：putIfAbsent 1234567891011121314package cn.meowrain.collection_;import java.util.HashMap;import java.util.Map;public class Map_ &#123; public static void main(String[] args) &#123; Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); map.put(1, &quot;小明&quot;); map.putIfAbsent(1, &quot;小红&quot;); //Java8新增操作，只有在不存在相同键的键值对时才会存放 System.out.println(map.get(1)); //小明 &#125;&#125; 还有，我们在获取一个不存在的映射时，默认会返回null作为结果： 12345678910111213package cn.meowrain.collection_;import java.util.HashMap;import java.util.Map;public class Map_ &#123; public static void main(String[] args) &#123; Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); map.put(1, &quot;小明&quot;); System.out.println(map.get(2)); //null &#125;&#125; 我们也可以为这种情况添加一个预备方案，当Map中不存在时，可以返回一个备选的返回值： 12345public static void main(String[] args) &#123; Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); map.put(1, &quot;小明&quot;); System.out.println(map.getOrDefault(3, &quot;备胎&quot;)); //Java8新增操作，当不存在对应的键值对时，返回备选方案&#125; 同样的，因为HashMap底层采用哈希表实现，所以不维护顺序，我们在获取所有键和所有值时，可能会是乱序的： 1234567891011121314151617package cn.meowrain.collection_;import java.util.HashMap;import java.util.Map;public class Map_ &#123; public static void main(String[] args) &#123; Map&lt;String , String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;0&quot;, &quot;十七张&quot;); map.put(&quot;+&quot;, &quot;牌&quot;); map.put(&quot;P&quot;, &quot;你能秒我&quot;); System.out.println(map); System.out.println(map.keySet()); System.out.println(map.values()); &#125;&#125; 如果需要维护顺序，我们同样可以使用LinkedHashMap，它的内部对插入顺序进行了维护： 123456789public static void main(String[] args) &#123; Map&lt;String , String&gt; map = new LinkedHashMap&lt;&gt;(); map.put(&quot;0&quot;, &quot;十七张&quot;); map.put(&quot;+&quot;, &quot;牌&quot;); map.put(&quot;P&quot;, &quot;你能秒我&quot;); System.out.println(map); System.out.println(map.keySet()); System.out.println(map.values());&#125; 实际上Map的使用还是挺简单的，我们接着来看看Map的底层是如何实现的，首先是最简单的HashMap，我们前面已经说过了，它的底层采用的是哈希表，首先回顾我们之前学习的哈希表，我们当时说了，哈希表可能会出现哈希冲突，这样保存的元素数量就会存在限制，而我们可以通过连地址法解决这种问题，最后哈希表就长这样了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package cn.meowrain.collection_;import java.util.HashMap;import java.util.Map;import java.util.Iterator;public class MapExercise &#123; public static void main(String[] args) &#123; HashMap&lt;Integer,Employee_2&gt; map = new HashMap&lt;&gt;(); map.put(1,new Employee_2(&quot;meowrain&quot;,18,18900)); map.put(2,new Employee_2(&quot;alice&quot;,19,17000)); map.put(3,new Employee_2(&quot;mike&quot;,20,20000)); map.put(4,new Employee_2(&quot;john&quot;,29,34000)); map.put(5, new Employee_2(&quot;danish&quot;,34,40000)); System.out.println(&quot;=====使用for each循环实现 ======&quot;); for(Map.Entry&lt;Integer,Employee_2&gt; entry : map.entrySet())&#123; if(entry.getValue().salary &gt; 18000)&#123; System.out.println(entry); &#125; &#125; System.out.println(&quot;=====使用iterator实现=====&quot;); Iterator&lt;Map.Entry&lt;Integer,Employee_2&gt;&gt; iterator = map.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry&lt;Integer, Employee_2&gt; next = iterator.next(); if(next.getValue().salary &gt; 18000)&#123; System.out.println(next); &#125; &#125; &#125;&#125;class Employee_2 &#123; String name; int age; double salary; public Employee_2(String name, int age,double salary) &#123; this.name = name; this.age = age; this.salary = salary; &#125; @Override public String toString() &#123; return &quot;Employee_2&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, salary=&quot; + salary + &#x27;&#125;&#x27;; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"JAVASE","slug":"Java/JAVASE","permalink":"http://example.com/categories/Java/JAVASE/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"Java泛型","slug":"49756fe6e6cc44f88ee3cc213ec4bd67","date":"2023-01-19T11:56:00.000Z","updated":"2023-01-19T11:57:00.000Z","comments":true,"path":"2023/01/19/49756fe6e6cc44f88ee3cc213ec4bd67/","link":"","permalink":"http://example.com/2023/01/19/49756fe6e6cc44f88ee3cc213ec4bd67/","excerpt":"","text":"Java-泛型文章出处:参考+摘抄: https://www.yuque.com/qingkongxiaguang/javase/rk6if6#dcab57b7 青空の霞光 泛型类泛型其实就一个待定类型，我们可以使用一个特殊的名字表示泛型，泛型在定义时并不明确是什么类型，而是需要到使用时才会确定对应的泛型类型。 我们可以将一个类定义为一个泛型类 12345678910111213141516171819202122232425package cn.meowrain.generic;public class Main &#123; public static void main(String[] args) &#123; Score&lt;String&gt; score01 = new Score&lt;String&gt;(&quot;meow&quot;,13,&quot;优秀&quot;); String value01 = score01.score; System.out.println(value01); // 优秀 Score&lt;Integer&gt; score02 = new Score&lt;Integer&gt;(&quot;meowrain&quot;,18,100); int value02 = score02.score; System.out.println(value02); // 100 &#125;&#125;class Score&lt;T&gt; &#123;//泛型类需要使用&lt;&gt;，我们需要在里面添加1 - N个类型 String name; int age; T score;//T会根据使用时提供的类型自动变成对应类型 public Score(String name, int age, T score) &#123; //这里T可以是任何类型，但是一旦确定，那么就不能修改了 this.name = name; this.age = age; this.score = score; &#125;&#125; 泛型将数据类型的确定控制在了编译阶段，在编写代码的时候就能明确泛型的类型，如果类型不符合，将无法通过编译！因为是具体使用对象时才会明确具体类型，所以说静态方法中是不能用的： 只不过这里需要注意一下，我们在方法中使用待确定类型的变量时，因为此时并不明确具体是什么类型，那么默认会认为这个变量是一个Object类型的变量，因为无论具体类型是什么，一定是Object类的子类： 我们可以对其进行强制类型转换，但是实际上没多大必要： 1234public void test(T t)&#123; String str = (String)t; //向下转型,Object转型为String类型&#125; 因为泛型本身就是对某些待定类型的简单处理，如果都明确要使用什么类型了，那大可不必使用泛型。还有，不能通过这个不确定的类型变量就去直接创建对象和对应的数组： 注意，具体类型不同的泛型类变量，不能使用不同的变量进行接收： ?通配符如果要让某个变量支持引用确定了任意类型的泛型，那么可以使用?通配符： 123456789101112131415161718192021package cn.meowrain.generic;public class Main &#123; public static void main(String[] args) &#123; Test&lt;?&gt; test = new Test&lt;&gt;(&quot;meowrain&quot;,18,98.5); System.out.println(test.name + &quot; &quot; + test.age + &quot; &quot; + test.score); &#125;&#125;class Test&lt;T&gt; &#123; T name; T age; T score; public Test(T name, T age, T score) &#123; this.name = name; this.age = age; this.score = score; &#125;&#125; 定义多个泛型变量当然，泛型变量不止可以只有一个，如果需要使用多个的话，我们也可以定义多个： 123456789101112131415161718192021package cn.meowrain.generic;import cn.meowrain.Poly.poly04.Test;public class Main &#123; public static void main(String[] args) &#123; Score&lt;String,Integer,Double&gt; score = new Score&lt;&gt;(&quot;meowrain&quot;,17,98.5); &#125;&#125;class Score&lt;A,B,C&gt; &#123;//泛型类需要使用&lt;&gt;，我们需要在里面添加1 - N个类型 A name; B age; C score;//T会根据使用时提供的类型自动变成对应类型 public Score(A name, B age, C score) &#123; this.name = name; this.age = age; this.score = score; &#125;&#125; 只要是在类中，都可以使用类型变量： 123456789101112public class Test&lt;T&gt;&#123; private T value; public void setValue(T value) &#123; this.value = value; &#125; public T getValue() &#123; return value; &#125;&#125; 注意事项只不过，泛型只能确定为一个引用类型，基本类型是不支持的： 如果要存放基本数据类型的值，我们只能使用对应的包装类： 123456789101112131415package cn.meowrain.generic;public class Main &#123; public static void main(String[] args) &#123; Test&lt;Integer&gt; test = new Test&lt;Integer&gt;(); test.value = 10; System.out.println(test.value); &#125;&#125;class Test&lt;T&gt; &#123; T value;&#125; 当然，如果是基本类型的数组，因为数组本身是引用类型，所以说是可以的： 1234567891011121314151617package cn.meowrain.generic;public class Main &#123; public static void main(String[] args) &#123; Test&lt;int[]&gt; test = new Test&lt;&gt;(); test.value = new int[]&#123;1, 2, 3, 4, 5, 6&#125;; for(int i = 0;i&lt;test.value.length;i++)&#123; System.out.println(test.value[i]); &#125; &#125;&#125;class Test&lt;T&gt; &#123; T value;&#125; 泛型与多态 不只是类，包括接口、抽象类，都是可以支持泛型的： 123interface Study&lt;T&gt; &#123; T learn();&#125; 当子类实现此接口时，我们可以选择在实现类明确泛型类型，或是继续使用此泛型让具体创建的对象来确定类型： 123456789101112131415161718192021222324252627package cn.meowrain.generic;public class Main &#123; public static void main(String[] args) &#123; Student stu1 = new Student(&quot;xiaoming&quot;); System.out.println(stu1.learn());//xiaoming is learning &#125;&#125;class Student implements Study&lt;String&gt; &#123; //在实现接口或是继承父类时，如果子类是一个普通类，那么可以直接明确对应类型 String name; public Student(String name) &#123; this.name = name; &#125; @Override public String learn() &#123; return (this.name + &quot; is learning&quot;); &#125;&#125;interface Study&lt;T&gt; &#123; T learn();&#125; 继续使用泛型: 123456789101112131415161718192021222324252627package cn.meowrain.generic;public class Main &#123; public static void main(String[] args) &#123; Student&lt;String&gt; stu1 = new Student&lt;&gt;(&quot;xiaoming&quot;); System.out.println(stu1.learn());//null &#125;&#125;class Student&lt;T&gt; implements Study&lt;T&gt; &#123; String name; public Student(String name) &#123; this.name = name; &#125; @Override public T learn() &#123; ///让子类继续为一个泛型类，那么可以不用明确 return null; &#125;&#125;interface Study&lt;T&gt; &#123; T learn();&#125; 继承也是同样的 12345678910111213141516171819202122232425262728293031323334353637383940414243package cn.meowrain.generic;public class Main &#123; public static void main(String[] args) &#123; Student stu1 = new Student(&quot;xiaoming&quot;,17,&quot;game&quot;,&quot;girls&quot;,99); System.out.println(stu1); &#125;&#125;class Human&lt;T&gt; &#123; String name; int age; String hobby; T like; public Human(String name, int age, String hobby, T like) &#123; this.name = name; this.age = age; this.hobby = hobby; this.like = like; &#125;&#125;class Student extends Human&lt;String&gt;&#123; int score; public Student(String name, int age, String hobby, String like, int score) &#123; super(name, age, hobby, like); this.score = score; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;score=&quot; + score + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, hobby=&#x27;&quot; + hobby + &#x27;\\&#x27;&#x27; + &quot;, like=&quot; + like + &#x27;&#125;&#x27;; &#125;&#125; 泛型方法当然，类型变量并不是只能在泛型类中才可以使用，我们也可以定义泛型方法。 当某个方法（无论是是静态方法还是成员方法）需要接受的参数类型并不确定时，我们也可以使用泛型来表示： 1234567891011121314151617package cn.meowrain.generic;public class Main &#123; public static void main(String[] args) &#123; String str = test(&quot;mike&quot;); System.out.println(str); &#125; public static &lt;T&gt; T test(T t) &#123; ////在返回值类型前添加&lt;&gt;并填写泛型变量表示这个是一个泛型方法 //返回类型为T ,参数类型为T return t; &#125;&#125; 泛型方法会在使用时自动确定泛型类型，比如上我们定义的是类型T作为参数，同样的类型T作为返回值，实际传入的参数是一个字符串类型的值，那么T就会自动变成String类型，因此返回值也是String类型。 12345678910111213141516171819202122package cn.meowrain.generic;import java.util.Arrays;public class Main &#123; public static void main(String[] args) &#123; String[] strings = new String[1]; Main main = new Main(); main.add(strings,&quot;hello&quot;); System.out.println(Arrays.toString(strings));//[hello] Integer[] arr = new Integer[1]; main.add(arr,1); System.out.println(Arrays.toString(arr));//[1] &#125; public &lt;T&gt; void add(T[] arr, T t) &#123; arr[0] = t; &#125;&#125; 泛型在工具类中的应用实际上泛型方法在很多工具类中也有，比如说Arrays的排序方法： 1234567891011121314151617181920212223242526272829303132package cn.meowrain.generic;import java.util.Arrays;import java.util.Comparator;public class Main &#123; public static void main(String[] args) &#123; Integer[] arr = &#123;1, 4, 5, 2, 6, 3, 0, 7, 9, 8&#125;; //从小到大排列 Arrays.sort(arr, new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; return o1 - o2; &#125; &#125;);//[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] System.out.println(Arrays.toString(arr)); //从大到小排序 Arrays.sort(arr, new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; return o2 - o1; &#125; &#125;);//[9, 8, 7, 6, 5, 4, 3, 2, 1, 0] System.out.println(Arrays.toString(arr)); &#125;&#125; 因为我们前面学习了Lambda表达式，像这种只有一个方法需要实现的接口，直接安排了： 123456789101112131415161718192021package cn.meowrain.generic;import java.util.Arrays;public class Main &#123; public static void main(String[] args) &#123; Integer[] arr = &#123;1, 4, 5, 2, 6, 3, 0, 7, 9, 8&#125;; //从小到大排列 Arrays.sort(arr, (o1, o2) -&gt; o1 - o2);//[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] System.out.println(Arrays.toString(arr)); //从大到小排序 Arrays.sort(arr, (o1, o2) -&gt; o2 - o1);//[9, 8, 7, 6, 5, 4, 3, 2, 1, 0] System.out.println(Arrays.toString(arr)); &#125;&#125; 包括数组复制方法： 12345678910111213141516package cn.meowrain.generic;import java.util.Arrays;public class Main &#123; public static void main(String[] args) &#123; String[] arr = &#123;&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;&#125;; String[] newArr = Arrays.copyOf(arr, arr.length); System.out.println(Arrays.toString(newArr));//[aaa, bbb, ccc] &#125;&#125; 泛型的界限上限现在有一个新的需求，现在没有String类型的成绩了，但是成绩依然可能是整数，也可能是小数，这时我们不希望用户将泛型指定为除数字类型外的其他类型，我们就需要使用到泛型的上界定义： 1234567891011121314151617181920212223242526272829303132333435package cn.meowrain.generic;public class Main &#123; public static void main(String[] args) &#123; Score&lt;Integer&gt; stu1 = new Score&lt;&gt;(&quot;xiaoming&quot;,1,100); Score&lt;Double&gt; stu2 = new Score&lt;&gt;(&quot;xiaohong&quot;,2,120.03); System.out.println(stu1.getValue()); // 100 System.out.println(stu2.getValue()); // 120.03 &#125;&#125;class Score&lt;T extends Number&gt;&#123; ////设定类型参数上界，必须是Number或是Number的子类 private final String name; private final int id; private final T value; public Score(String name, int id, T value) &#123; this.name = name; this.id = id; this.value = value; &#125; public T getValue() &#123; return value; &#125; public String getName() &#123; return name; &#125; public int getId() &#123; return id; &#125;&#125; 只需要在泛型变量的后面添加extends关键字即可指定上界，使用时，具体类型只能是我们指定的上界类型或是上界类型的子类，不得是其他类型。否则一律报错： 像是这样 泛型通配符在泛型界限中的使用同样的，当我们在使用变量时，泛型通配符也支持泛型的界限： 12345678910111213141516171819202122232425262728293031package cn.meowrain.generic;public class Main &#123; public static void main(String[] args) &#123; Score&lt;? extends Number&gt; score = new Score&lt;&gt;(&quot;数据结构与算法&quot;, &quot;EP074512&quot;, 60); &#125;&#125;class Score&lt;T&gt;&#123; private final String name; private final String id; private final T value; public Score(String name, String id, T value) &#123; this.name = name; this.id = id; this.value = value; &#125; public T getValue() &#123; return value; &#125; public String getName() &#123; return name; &#125; public String getId() &#123; return id; &#125;&#125; 那么限定了上界后，我们再来使用这个对象的泛型成员，会变成什么类型呢？ 123456789101112131415161718192021222324252627282930313233package cn.meowrain.generic;public class Main &#123; public static void main(String[] args) &#123; Score&lt;? extends Number&gt; score = new Score&lt;&gt;(&quot;数据结构与算法&quot;, &quot;EP074512&quot;, 60.5); Number o = score.getValue(); System.out.println(o);//60.5 &#125;&#125;class Score&lt;T&gt;&#123; private final String name; private final String id; private final T value; public Score(String name, String id, T value) &#123; this.name = name; this.id = id; this.value = value; &#125; public T getValue() &#123; return value; &#125; public String getName() &#123; return name; &#125; public String getId() &#123; return id; &#125;&#125; 可以看到，此时虽然使用的是通配符，但是不再是Object类型，而是对应的上界 但是我们限定下界的话，因为还是有可能是Object，所以说依然是跟之前一样： 那么既然泛型有上界，那么有没有下界呢？有 下限 123456789101112131415161718192021222324252627282930313233package cn.meowrain.generic;public class Main &#123; public static void main(String[] args) &#123; Score&lt;? super Integer&gt; score = new Score&lt;&gt;(&quot;数据结构与算法&quot;, &quot;EP074512&quot;, 60.5); Object o = score.getValue(); System.out.println(o);//60.5 &#125;&#125;class Score&lt;T&gt;&#123; private final String name; private final String id; private final T value; public Score(String name, String id, T value) &#123; this.name = name; this.id = id; this.value = value; &#125; public T getValue() &#123; return value; &#125; public String getName() &#123; return name; &#125; public String getId() &#123; return id; &#125;&#125; 但是我们限定下界的话，因为还是有可能是Object，所以说依然是跟之前一样： 通过给设定泛型上限，我们就可以更加灵活地控制泛型的具体类型范围。 类型擦除前面我们已经了解如何使用泛型，那么泛型到底是如何实现的呢，程序编译之后的样子是什么样的？ 123public abstract class A &lt;T&gt;&#123; abstract T test(T t);&#125; 实际上在Java中并不是真的有泛型类型（为了兼容之前的Java版本）因为所有的对象都是属于一个普通的类型，一个泛型类型编译之后，实际上会直接使用默认的类型： 123public abstract class A &#123; abstract Object test(Object t); //默认就是Object&#125; 当然，如果我们给类型变量设定了上界，那么会从默认类型变成上界定义的类型： 123public abstract class A &lt;T extends Number&gt;&#123; //设定上界为Number abstract T test(T t);&#125; 那么编译之后： 123public abstract class A &#123; abstract Number test(Number t); //上界Number，因为现在只可能出现Number的子类&#125; 因此，泛型其实仅仅是在编译阶段进行类型检查，当程序在运行时，并不会真的去检查对应类型，所以说哪怕是我们不去指定类型也可以直接使用： 123public static void main(String[] args) &#123; Test test = new Test(); //对于泛型类Test，不指定具体类型也是可以的，默认就是原始类型&#125; 只不过此时编译器会给出警告： 同样的，由于类型擦除，实际上我们在使用时，编译后的代码是进行了强制类型转换的： 1234567891011121314151617181920212223package cn.meowrain.generic;public class test &#123; public static void main(String[] args) &#123; A&lt;String&gt; a = new B(); String i = a.test(&quot;10&quot;); System.out.println(i); &#125;&#125;class A&lt;T&gt; &#123; public T test(T t) &#123; return t; &#125;&#125;class B extends A&lt;String&gt; &#123; @Override public String test(String s) &#123; return null; &#125;&#125; 实际上编译之后： 不过，我们思考一个问题，既然继承泛型类之后可以明确具体类型，那么为什么@Override不会出现错误呢？我们前面说了，重写的条件是需要和父类的返回值类型和形参一致，而泛型默认的原始类型是Object类型，子类明确后变为其他类型，这显然不满足重写的条件，但是为什么依然能编译通过呢？ 123456public class B extends A&lt;String&gt;&#123; @Override String test(String s) &#123; return null; &#125;&#125; 我们来看看编译之后长啥样： 123456// Compiled from &quot;B.java&quot;public class com.test.entity.B extends com.test.entity.A&lt;java.lang.String&gt; &#123; public com.test.entity.B(); java.lang.String test(java.lang.String); java.lang.Object test(java.lang.Object); //桥接方法，这才是真正重写的方法，但是使用时会调用上面的方法&#125; 通过反编译进行观察，实际上是编译器帮助我们生成了一个桥接方法用于支持重写： 12345678910public class B extends A &#123; public Object test(Object obj) &#123; //这才是重写的桥接方法 return this.test((Integer) obj); //桥接方法调用我们自己写的方法 &#125; public String test(String str) &#123; //我们自己写的方法 return null; &#125;&#125; 类型擦除机制其实就是为了方便使用后面集合类（不然每次都要强制类型转换）同时为了向下兼容采取的方案。因此，泛型的使用会有一些限制： 首先，在进行类型判断时，不允许使用泛型，只能使用原始类型： 只能判断是不是原始类型，里面的具体类型是不支持的： 1234567891011121314151617package cn.meowrain.generic;public class Main &#123; public static void main(String[] args) &#123; Hello&lt;String&gt; hello = new Hello&lt;&gt;(&quot;meow&quot;); System.out.println(hello instanceof Hello); // true &#125;&#125;class Hello&lt;T&gt; &#123; T name; public Hello(T name) &#123; this.name = name; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"JAVASE","slug":"Java/JAVASE","permalink":"http://example.com/categories/Java/JAVASE/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"JavaWeb笔记（二）","slug":"088fcec4e8a846479c3cfcf5a6a52da7","date":"2023-01-18T02:27:08.000Z","updated":"2023-01-22T17:01:07.802Z","comments":true,"path":"2023/01/18/088fcec4e8a846479c3cfcf5a6a52da7/","link":"","permalink":"http://example.com/2023/01/18/088fcec4e8a846479c3cfcf5a6a52da7/","excerpt":"","text":"数据库基础数据库是学习JavaWeb的一个前置，只有了解了数据库的操作和使用，我们才能更好地组织和管理网站应用产生的数据。 什么是数据库数据库是数据管理的有效技术，是由一批数据构成的有序集合，这些数据被存放在结构化的数据表里。数据表之间相互关联，反映客观事物间的本质联系。数据库能有效地帮助一个组织或企业科学地管理各类信息资源。简而言之，我们的数据可以交给数据库来帮助我们进行管理，同时数据库能够为我们提供高效的访问性能。 在JavaSE学习阶段中，我们学习了如何使用文件I&#x2F;O来将数据保存到本地，这样就可以将一个数据持久地存储在本地，即使程序重新打开，我们也能加载回上一次的数据，但是当我们的数据变得非常多的时候，这样的方式就显得不太方便了。同时我们如果需要查找众多数据的中的某一个，就只能加载到内存再进行查找，这样显然是很难受的！ 而数据库就是专门做这事的，我们可以快速查找想要的数据，便捷地插入、修改和删除数据，并且数据库不仅能做这些事，还能提供更多便于管理数据和操作数据的功能！ 常见的数据库常见的数据库有很多种，包括但不限于： MySQL - 免费，用的最多的，开源数据库，适用于中小型 Microsoft SQL Server - 收钱的，但是提供技术支持，适用于Windows Server Oracle - 收钱的，大型数据库系统 而我们要学习的是MySQL数据，其实无论学习哪种数据库，SQL语句大部分都是通用的，只有少许语法是不通用的，因此我们只需要学习一种数据库其他的也就差不多都会了。 数据模型数据模型与现实世界中的模型一样，是对现实世界数据特征的一种抽象。实际上，我们之前学习的类就是对现实世界数据的一种抽象，比如一个学生的特征包括姓名，年龄，年级，学号，专业等，这些特征也称为实体的一种属性，属性具有以下特点： 属性不可再分 一个实体的属性可以有很多个 用于唯一区分不同实体的的属性，称为Key，比如每个同学的学号都是不一样的 属性取值可以有一定的约束，比如性别只能是男或是女 实体或是属性之间可以具有一定的联系，比如一个老师可以教很多个学生，而学生相对于老师就是被教授的关系；又比如每个同学都有一个学号与其唯一对应，因此学号和学生之间也有一种联系。而像一个老师教多个学生的联系就是一种一对多的联系（1:n），而学号唯一对应，就是一种一对一的联系（1:1）；每一个老师不仅可以教多个学生，每一个学生也可以有多个教师，这就是一种多对多的联系（n:m） MySQL就是一种关系型数据库，通过使用关系型数据库，我们就可以很好地存储这样带有一定联系的数据。 通过构建一个ER图，我们就能很好地理清不同数据模型之间的关系和特点。 数据库的创建既然了解了属性和联系，那么我们就来尝试创建一个数据库，并在数据库中添加用于存放数据的表，每一张表都代表一种实体的数据。首先我们要明确，我们需要创建什么样子的表： 学生表：用于存放所有学生的数据，学生（学号，姓名，性别） 教师表：用于存放所有教师的数据，教师（教师号，姓名） 授课表：用于存放教师与学生的授课信息，授课（学号，教师号） 其中，标注下划线的属性，作为Key，用于区别于其他实体数据的唯一标记。 为了理解起来更加轻松，我们从图形界面操作再讲到SQL语句，请不要着急。我们现在通过Navicat或idea自带的数据库客户端来创建一个数据库和上述三个表。 数据库的规范化要去设计存放一个实体的表，我们就需要了解数据库的关系规范化，尽可能减少“不好”的关系存在，如何设计一个优良的关系模型是最关键的内容！简而言之，我们要学习一下每一个表该如何去设计。 第一范式（1NF）第一范式是指数据库的每一列都是不可分割的基本数据项，而下面这样的就存在可分割的情况： 学生（姓名，电话号码） 电话号码实际上包括了家用座机电话和移动电话，因此它可以被拆分为： 学生（姓名，座机号码，手机号码） 满足第一范式是关系型数据库最基本的要求！ 第二范式（2NF）第二范式要求表中必须存在主键，且其他的属性必须完全依赖于主键，比如： 学生（学号，姓名，性别） 学号是每个学生的唯一标识，每个学生都有着不同的学号，因此此表中存在一个主键，并且每个学生的所有属性都依赖于学号，学号发生改变就代表学生发生改变，姓名和性别都会因此发生改变，所有此表满足第二范式。 第三范式（3NF）在满足第二范式的情况下，所有的属性都不传递依赖于主键，满足第三范式。 学生借书情况（借阅编号，学生学号，书籍编号，书籍名称，书籍作者） 实际上书籍编号依赖于借阅编号，而书籍名称和书籍作者依赖于书籍编号，因此存在传递依赖的情况，我们可以将书籍信息进行单独拆分为另一张表： 学生借书情况（借阅编号，学生学号，书籍编号） 书籍（书籍编号，书籍名称，书籍作者） 这样就消除了传递依赖，从而满足第三范式。 BCNFBCNF作为第三范式的补充，假设仓库管理关系表为StorehouseManage(仓库ID, 存储物品ID, 管理员ID, 数量)，且有一个管理员只在一个仓库工作；一个仓库可以存储多种物品。这个数据库表中存在如下决定关系： (仓库ID, 存储物品ID) →(管理员ID, 数量) (管理员ID, 存储物品ID) → (仓库ID, 数量) 所以，(仓库ID, 存储物品ID)和(管理员ID, 存储物品ID)都是StorehouseManage的候选关键字，表中的唯一非关键字段为数量，它是符合第三范式的。但是，由于存在如下决定关系： (仓库ID) → (管理员ID) (管理员ID) → (仓库ID) 即存在关键字段决定关键字段的情况，如果修改管理员ID，那么就必须逐一进行修改，所以其不符合BCNF范式。 认识SQL语句结构化查询语言（Structured Query Language）简称SQL，这是一种特殊的语言，它专门用于数据库的操作。每一种数据库都支持SQL，但是他们之间会存在一些细微的差异，因此不同的数据库都存在自己的“方言”。 SQL语句不区分大小写（关键字推荐使用大写），它支持多行，并且需要使用;进行结尾！ SQL也支持注释，通过使用--或是#来编写注释内容，也可以使用/*来进行多行注释。 我们要学习的就是以下四种类型的SQL语言： 数据查询语言（Data Query Language, DQL）基本结构是由SELECT子句，FROM子句，WHERE子句组成的查询块。 数据操纵语言（Data Manipulation Language, DML）是SQL语言中，负责对数据库对象运行数据访问工作的指令集，以INSERT、UPDATE、DELETE三种指令为核心，分别代表插入、更新与删除，是开发以数据为中心的应用程序必定会使用到的指令。 数据库定义语言DDL(Data Definition Language)，是用于描述数据库中要存储的现实世界实体的语言。 DCL（Data Control Language）是数据库控制语言。是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke等）语句。在默认状态下，只有sysadmin,dbcreator,db_owner或db_securityadmin等人员才有权力执行DCL。 我们平时所说的CRUD其实就是增删改查（Create&#x2F;Retrieve&#x2F;Update&#x2F;Delete） 数据库定义语言（DDL）数据库操作我们可以通过create database来创建一个数据库： 1create database 数据库名 为了能够支持中文，我们在创建时可以设定编码格式： 1CREATE DATABASE IF NOT EXISTS 数据库名 DEFAULT CHARSET utf8 COLLATE utf8_general_ci; 如果我们创建错误了，我们可以将此数据库删除，通过使用drop database来删除一个数据库： 1drop database 数据库名 创建表数据库创建完成后，我们一般通过create table语句来创建一张表： 1234create table 表名(列名 数据类型[列级约束条件], 列名 数据类型[列级约束条件], ... [,表级约束条件]) SQL数据类型以下的数据类型用于字符串存储： char(n)可以存储任意字符串，但是是固定长度为n，如果插入的长度小于定义长度时，则用空格填充。 varchar(n)也可以存储任意数量字符串，长度不固定，但不能超过n，不会用空格填充。 以下数据类型用于存储数字： smallint用于存储小的整数，范围在 (-32768，32767) int用于存储一般的整数，范围在 (-2147483648，2147483647) bigint用于存储大型整数，范围在 (-9,223,372,036,854,775,808，9,223,372,036,854,775,807) float用于存储单精度小数 double用于存储双精度的小数 以下数据类型用于存储时间： date存储日期 time存储时间 year存储年份 datetime用于混合存储日期+时间 列级约束条件列级约束有六种：主键Primary key、外键foreign key 、唯一 unique、检查 check （MySQL不支持）、默认default 、非空&#x2F;空值 not null&#x2F; null 表级约束条件表级约束有四种：主键、外键、唯一、检查 现在我们通过SQL语句来创建我们之前提到的三张表。 1[CONSTRAINT &lt;外键名&gt;] FOREIGN KEY 字段名 [，字段名2，…] REFERENCES &lt;主表名&gt; 主键列1 [，主键列2，…] 修改表如果我们想修改表结构，我们可以通过alter table来进行修改： 123ALTER TABLE 表名[ADD 新列名 数据类型[列级约束条件]] [DROP COLUMN 列名[restrict|cascade]] [ALTER COLUMN 列名 新数据类型] 我们可以通过ADD来添加一个新的列，通过DROP来删除一个列，不过我们可以添加restrict或cascade，默认是restrict，表示如果此列作为其他表的约束或视图引用到此列时，将无法删除，而cascade会强制连带引用此列的约束、视图一起删除。还可以通过ALTER来修改此列的属性。 删除表我们可以通过drop table来删除一个表： 1DROP TABLE 表名[restrict|cascade] 其中restrict和cascade上面的效果一致。 数据库操纵语言（DML）前面我们已经学习了如何使用SQL语句来创建、修改、删除数据库以及表，而如何向数据库中插入、删除、更新数据，将是本版块讨论的重点。 插入数据通过使用insert into语句来向数据库中插入一条数据（一条记录）： 1INSERT INTO 表名 VALUES(值1, 值2, 值3) 如果插入的数据与列一一对应，那么可以省略列名，但是如果希望向指定列上插入数据，就需要给出列名： 1INSERT INTO 表名(列名1, 列名2) VALUES(值1, 值2) 我们也可以一次性向数据库中插入多条数据： 1INSERT INTO 表名(列名1, 列名2) VALUES(值1, 值2), (值1, 值2), (值1, 值2) 我们来试试看向我们刚刚创建的表中添加三条数据。 修改数据我们可以通过update语句来更新表中的数据： 1UPDATE 表名 SET 列名=值,... WHERE 条件 注意，SQL语句中的等于判断是= **警告：**如果忘记添加WHERE字句来限定条件，将使得整个表中此列的所有数据都被修改！ 删除数据我们可以通过使用delete来删除表中的数据： 1DELETE FROM 表名 通过这种方式，将删除表中全部数据，我们也可以使用where来添加条件，只删除指定的数据： 1DELETE FROM 表名 WHERE 条件 数据库查询语言（DQL）数据库的查询是我们整个数据库学习中的重点内容，面对数据库中庞大的数据，该如何去寻找我们想要的数据，就是我们主要讨论的问题。 单表查询单表查询是最简单的一种查询，我们只需要在一张表中去查找数据即可，通过使用select语句来进行单表查询： 12345678-- 指定查询某一列数据SELECT 列名[,列名] FROM 表名-- 会以别名显示此列SELECT 列名 别名 FROM 表名-- 查询所有的列数据SELECT * FROM 表名-- 只查询不重复的值SELECT DISTINCT 列名 FROM 表名 我们也可以添加where字句来限定查询目标： 1SELECT * FROM 表名 WHERE 条件 常用查询条件 一般的比较运算符，包括&#x3D;、&gt;、&lt;、&gt;&#x3D;、&lt;&#x3D;、!&#x3D;等。 是否在集合中：in、not in 字符模糊匹配：like，not like 多重条件连接查询：and、or、not 我们来尝试使用一下上面这几种条件。 排序查询我们可以通过order by来将查询结果进行排序： 1SELECT * FROM 表名 WHERE 条件 ORDER BY 列名 ASC|DESC 使用ASC表示升序排序，使用DESC表示降序排序，默认为升序。 我们也可以可以同时添加多个排序： 1SELECT * FROM 表名 WHERE 条件 ORDER BY 列名1 ASC|DESC, 列名2 ASC|DESC 这样会先按照列名1进行排序，每组列名1相同的数据再按照列名2排序。 聚集函数聚集函数一般用作统计，包括： count([distinct]*)统计所有的行数（distinct表示去重再统计，下同） count([distinct]列名)统计某列的值总和 sum([distinct]列名)求一列的和（注意必须是数字类型的） avg([distinct]列名)求一列的平均值（注意必须是数字类型） max([distinct]列名)求一列的最大值 min([distinct]列名)求一列的最小值 一般聚集函数是这样使用的： 1SELECT count(distinct 列名) FROM 表名 WHERE 条件 分组和分页查询通过使用group by来对查询结果进行分组，它需要结合聚合函数一起使用： 1SELECT sum(*) FROM 表名 WHERE 条件 GROUP BY 列名 我们还可以添加having来限制分组条件： 1SELECT sum(*) FROM 表名 WHERE 条件 GROUP BY 列名 HAVING 约束条件 我们可以通过limit来限制查询的数量，只取前n个结果： 1SELECT * FROM 表名 LIMIT 数量 我们也可以进行分页： 1SELECT * FROM 表名 LIMIT 起始位置,数量 多表查询多表查询是同时查询的两个或两个以上的表，多表查询会提通过连接转换为单表查询。 1SELECT * FROM 表1, 表2 直接这样查询会得到两张表的笛卡尔积，也就是每一项数据和另一张表的每一项数据都结合一次，会产生庞大的数据。 1SELECT * FROM 表1, 表2 WHERE 条件 这样，只会从笛卡尔积的结果中得到满足条件的数据。 **注意：**如果两个表中都带有此属性吗，需要添加表名前缀来指明是哪一个表的数据。 自身连接查询自身连接，就是将表本身和表进行笛卡尔积计算，得到结果，但是由于表名相同，因此要先起一个别名： 1SELECT * FROM 表名 别名1, 表名 别名2 其实自身连接查询和前面的是一样的，只是连接对象变成自己和自己了。 外连接查询外连接就是专门用于联合查询情景的，比如现在有一个存储所有用户的表，还有一张用户详细信息的表，我希望将这两张表结合到一起来查看完整的数据，我们就可以通过使用外连接来进行查询，外连接有三种方式： 通过使用inner join进行内连接，只会返回两个表满足条件的交集部分： 通过使用left join进行左连接，不仅会返回两个表满足条件的交集部分，也会返回左边表中的全部数据，而在右表中缺失的数据会使用null来代替（右连接right join同理，只是反过来而已，这里就不再介绍了）： 嵌套查询我们可以将查询的结果作为另一个查询的条件，比如： 1SELECT * FROM 表名 WHERE 列名 = (SELECT 列名 FROM 表名 WHERE 条件) 我们来再次尝试编写一下在最开始我们查找某教师所有学生的SQL语句。 数据库控制语言（DCL）庞大的数据库不可能由一个人来管理，我们需要更多的用户来一起管理整个数据库。 创建用户我们可以通过create user来创建用户： 1CREATE USER 用户名 identified by 密码; 也可以不带密码： 1CREATE USER 用户名; 我们可以通过@来限制用户登录的登录IP地址，%表示匹配所有的IP地址，默认使用的就是任意IP地址。 登陆用户首先需要添加一个环境变量，然后我们通过cmd去登陆mysql： 1login -u 用户名 -p 输入密码后即可登陆此用户，我们输入以下命令来看看能否访问所有数据库： 1show databases; 我们发现，虽然此用户能够成功登录，但是并不能查看完整的数据库列表，这是因为此用户还没有权限！ 用户授权我们可以通过使用grant来为一个数据库用户进行授权： 1grant all|权限1,权限2...(列1,...) on 数据库.表 to 用户 [with grant option] 其中all代表授予所有权限，当数据库和表为*，代表为所有的数据库和表都授权。如果在最后添加了with grant option，那么被授权的用户还能将已获得的授权继续授权给其他用户。 我们可以使用revoke来收回一个权限： 1revoke all|权限1,权限2...(列1,...) on 数据库.表 from 用户 视图视图本质就是一个查询的结果，不过我们每次都可以通过打开视图来按照我们想要的样子查看数据。既然视图本质就是一个查询的结果，那么它本身就是一个虚表，并不是真实存在的，数据实际上还是存放在原来的表中。 我们可以通过create view来创建视图; 1CREATE VIEW 视图名称(列名) as 子查询语句 [WITH CHECK OPTION]; WITH CHECK OPTION是指当创建后，如果更新视图中的数据，是否要满足子查询中的条件表达式，不满足将无法插入，创建后，我们就可以使用select语句来直接查询视图上的数据了，因此，还能在视图的基础上，导出其他的视图。 若视图是由两个以上基本表导出的，则此视图不允许更新。 若视图的字段来自字段表达式或常数，则不允许对此视图执行INSERT和UPDATE操作，但允许执行DELETE操作。 若视图的字段来自集函数，则此视图不允许更新。 若视图定义中含有GROUP BY子句，则此视图不允许更新。 若视图定义中含有DISTINCT短语，则此视图不允许更新。 若视图定义中有嵌套查询，并且内层查询的FROM子句中涉及的表也是导出该视图的基本表，则此视图不允许更新。例如将成绩在平均成绩之上的元组定义成一个视图GOOD_SC： CREATE VIEW GOOD_SC AS SELECT Sno, Cno, Grade FROM SC WHERE Grade &gt; (SELECT AVG(Grade) FROM SC); 导出视图GOOD_SC的基本表是SC，内层查询中涉及的表也是SC，所以视图GOOD_SC是不允许更新的。 一个不允许更新的视图上定义的视图也不允许更新 通过drop来删除一个视图： 1drop view apptest 索引在数据量变得非常庞大时，通过创建索引，能够大大提高我们的查询效率，就像Hash表一样，它能够快速地定位元素存放的位置，我们可以通过下面的命令创建索引： 1234-- 创建索引CREATE INDEX 索引名称 ON 表名 (列名)-- 查看表中的索引show INDEX FROM student 我们也可以通过下面的命令删除一个索引： 1drop index 索引名称 on 表名 虽然添加索引后会使得查询效率更高，但是我们不能过度使用索引，索引为我们带来高速查询效率的同时，也会在数据更新时产生额外建立索引的开销，同时也会占用磁盘资源。 触发器触发器就像其名字一样，在某种条件下会自动触发，在select&#x2F;update&#x2F;delete时，会自动执行我们预先设定的内容，触发器通常用于检查内容的安全性，相比直接添加约束，触发器显得更加灵活。 触发器所依附的表称为基本表，当触发器表上发生select&#x2F;update&#x2F;delete等操作时，会自动生成两个临时的表（new表和old表，只能由触发器使用） 比如在insert操作时，新的内容会被插入到new表中；在delete操作时，旧的内容会被移到old表中，我们仍可在old表中拿到被删除的数据；在update操作时，旧的内容会被移到old表中，新的内容会出现在new表中。 1CREATE TRIGGER 触发器名称 [BEFORE|AFTER] [INSERT|UPDATE|DELETE] ON 表名/视图名 FOR EACH ROW DELETE FROM student WHERE student.sno = new.sno FOR EACH ROW表示针对每一行都会生效，无论哪行进行指定操作都会执行触发器！ 通过下面的命令来查看触发器： 1SHOW TRIGGERS 如果不需要，我们就可以删除此触发器： 1DROP TRIGGER 触发器名称 事务当我们要进行的操作非常多时，比如要依次删除很多个表的数据，我们就需要执行大量的SQL语句来完成，这些数据库操作语句就可以构成一个事务！只有Innodb引擎支持事务，我们可以这样来查看支持的引擎： 1SHOW ENGINES; MySQL默认采用的是Innodb引擎，我们也可以去修改为其他的引擎。 事务具有以下特性： **原子性：**一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 **一致性：**在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。 **隔离性：**数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。 **持久性：**事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 我们通过以下例子来探究以下事务： 12345678begin; #开始事务...rollback; #回滚事务savepoint 回滚点; #添加回滚点rollback to 回滚点; #回滚到指定回滚点...commit; #提交事务-- 一旦提交，就无法再进行回滚了！ 选学内容函数和存储过程并没有包含在我们的教程当中，但是这并不代表它们就不重要，通过学习它们能够让你的数据库管理能力更上一层楼，它们能够捆绑一组SQL语句运行，并且可以反复使用，大大提高工作效率。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"JavaWeb笔记","slug":"Java/JavaWeb笔记","permalink":"http://example.com/categories/Java/JavaWeb%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"JavaWeb笔记（五）","slug":"5756fdcc799c4064be4e4a84d7ab5244","date":"2023-01-18T02:27:08.000Z","updated":"2023-01-24T17:35:13.259Z","comments":true,"path":"2023/01/18/5756fdcc799c4064be4e4a84d7ab5244/","link":"","permalink":"http://example.com/2023/01/18/5756fdcc799c4064be4e4a84d7ab5244/","excerpt":"","text":"JavaWeb后端经过前面的学习，现在终于可以正式进入到后端的学习当中，不过，我们还是需要再系统地讲解一下HTTP通信基础知识，它是我们学习JavaWeb的基础知识，我们之前已经学习过TCP通信，而HTTP实际上是基于TCP协议之上的应用层协议，因此理解它并不难理解。 打好基础是关键！为什么要去花费时间来讲解计算机网络基础，我们学习一门技术，如果仅仅是知道如何使用却不知道其原理，那么就成了彻头彻尾的“码农”，只知道搬运代码实现功能，却不知道这行代码的执行流程，在遇到一些问题的时候就不知道如何解决，无论是知识层面还是应用层面都得不到提升。 无论怎么样，我们都要明确，我们学习JavaWeb的最终目的是为了搭建一个网站，并且让用户能访问我们的网站并在我们的网站上做一些事情。 计算机网络基础在计算机网络（谢希仁 第七版 第264页）中，是这样描述万维网的： 万维网（World Wide Web）并非是某种特殊的计算机网络，万维网是一个大规模的联机式信息储藏所，英文简称Web，万维网用**链接**的方法，能够非常方便地从互联网上的一个站点访问另一个站点，从而主动地按需求获取丰富的信息。 这句话说的非常官方，但是也蕴藏着许多的信息，首先它指明，我们的互联网上存在许许多多的服务器，而我们通过访问这些服务器就能快速获取服务器为我们提供的信息（比如打开百度就能展示搜索、打开小破站能刷视频、打开微博能查看实时热点）而这些服务器就是由不同的公司在运营。 其次，我们通过浏览器，只需要输入对应的网址或是点击页面中的一个链接，就能够快速地跳转到另一个页面，从而按我们的意愿来访问服务器。 而书中是这样描述万维网的工作方式： 万维网以客户服务器的方式工作，浏览器就是安装在用户主机上的万维网客户程序，万维网文档所驻留的主机则运行服务器程序，因此这台主机也称为万维网服务器。客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的万维网文档，在一个客户程序主窗口上显示出的万维网文档称为页面。 上面提到的客户程序其实就是我们电脑上安装的浏览器，而服务端就是我们即将要去学习的Web服务器，也就是说，我们要明白如何搭建一个Web服务器并向用户发送我们提供的Web页面，在浏览器中显示的，一般就是HTML文档被解析后的样子。 那么，我们的服务器可能不止一个页面，可能会有很多个页面，那么客户端如何知道该去访问哪个服务器的哪个页面呢？这个时候就需要用到URL统一资源定位符。互联网上所有的资源，都有一个唯一确定的URL，比如http://www.baidu.com URL的格式为： &lt;协议&gt;:&#x2F;&#x2F;&lt;主机&gt;:&lt;端口&gt;&#x2F;&lt;路径&gt; 协议是指采用什么协议来访问服务器，不同的协议决定了服务器返回信息的格式，我们一般使用HTTP协议。 主机可以是一个域名，也可以是一个IP地址（实际上域名最后会被解析为IP地址进行访问） 端口是当前服务器上Web应用程序开启的端口，我们前面学习TCP通信的时候已经介绍过了，HTTP协议默认使用80端口，因此有时候可以省略。 路径就是我们希望去访问此服务器上的某个文件，不同的路径代表访问不同的资源。 我们接着来了解一下什么是HTTP协议： HTTP是面向事务的应用层协议，它是万维网上能够可靠交换文件的重要基础。HTTP不仅传送完成超文本跳转所需的必须信息，而且也传送任何可从互联网上得到的信息，如文本、超文本、声音和图像。 实际上我们之前访问百度、访问自己的网站，所有的传输都是以HTTP作为协议进行的。 我们来看看HTTP的传输原理： HTTP使用了面向连接的TCP作为运输层协议，保证了数据的可靠传输。HTTP不必考虑数据在传输过程中被丢弃后又怎样被重传。但是HTTP协议本身是无连接的。也就是说，HTTP虽然使用了TCP连接，但是通信的双方在交换HTTP报文之前不需要先建立HTTP连接。1997年以前使用的是HTTP&#x2F;1.0协议，之后就是HTTP&#x2F;1.1协议了。 那么既然HTTP是基于TCP进行通信的，我们首先来回顾一下TCP的通信原理： TCP协议实际上是经历了三次握手再进行通信，也就是说保证整个通信是稳定的，才可以进行数据交换，并且在连接已经建立的过程中，双方随时可以互相发送数据，直到有一方主动关闭连接，这时在进行四次挥手，完成整个TCP通信。 而HTTP和TCP并不是一个层次的通信协议，TCP是传输层协议，而HTTP是应用层协议，因此，实际上HTTP的内容会作为TCP协议的报文被封装，并继续向下一层进行传递，而传输到客户端时，会依次进行解包，还原为最开始的HTTP数据。 HTTP使用TCP协议是为了使得数据传输更加可靠，既然它是依靠TCP协议进行数据传输，那么为什么说它本身是无连接的呢？我们来看一下HTTP的传输过程： 用户在点击鼠标链接某个万维网文档时，HTTP协议首先要和服务器建立TCP连接。这需要使用三报文握手。当建立TCP连接的三报文握手的前两部分完成后（即经过了一个RTT时间后），万维网客户就把HTTP请求报文作为建立TCP连接的三报文握手中的第三个报文的数据，发送给万维网服务器。服务器收到HTTP请求报文后，就把所请求的文档作为响应报文返回给客户。 因此，我们的浏览器请求一个页面，需要两倍的往返时间。 最后，我们再来了解一下HTTP的报文结构： 由客户端向服务端发送是报文称为请求报文，而服务端返回给客户端的称为响应报文，实际上，整个报文全部是以文本形式发送的，通过使用空格和换行来完成分段。 现在，我们已经了解了HTTP协议的全部基础知识，那么什么是Web服务器呢，实际上，它就是一个软件，但是它已经封装了所有的HTTP协议层面的操作，我们无需关心如何使用HTTP协议通信，而是直接基于服务器软件进行开发，我们只需要关心我们的页面数据如何展示、前后端如何交互即可。 认识Tomcat服务器 Tomcat（汤姆猫）就是一个典型的Web应用服务器软件，通过运行Tomcat服务器，我们就可以快速部署我们的Web项目，并交由Tomcat进行管理，我们只需要直接通过浏览器访问我们的项目即可。 那么首先，我们需要进行一个简单的环境搭建，我们需要在Tomcat官网下载最新的Tomcat服务端程序：https://tomcat.apache.org/download-10.cgi（下载速度可能有点慢） 下载：64-bit Windows zip 下载完成后，解压，并放入桌面，接下来需要配置一下环境变量，打开高级系统设置，打开环境变量，添加一个新的系统变量，变量名称为JRE_HOME，填写JDK的安装目录+&#x2F;jre，比如Zulujdk默认就是：C:\\Program Files\\Zulu\\zulu-8\\jre 设置完成后，我们进入tomcat文件夹bin目录下，并在当前位置打开CMD窗口，将startup.sh拖入窗口按回车运行，如果环境变量配置有误，会提示，若没问题，服务器则正常启动。 如果出现乱码，说明编码格式配置有问题，我们修改一下服务器的配置文件，打开conf文件夹，找到logging.properties文件，这就是日志的配置文件（我们在前面已经给大家讲解过了）将ConsoleHandler的默认编码格式修改为GBK编码格式： 1java.util.logging.ConsoleHandler.encoding = GBK 现在重新启动服务器，就可以正常显示中文了。 服务器启动成功之后，不要关闭，我们打开浏览器，在浏览器中访问：http://localhost:8080/，Tomcat服务器默认是使用8080端口（可以在配置文件中修改），访问成功说明我们的Tomcat环境已经部署成功了。 整个Tomcat目录下，我们已经认识了bin目录（所有可执行文件，包括启动和关闭服务器的脚本）以及conf目录（服务器配置文件目录），那么我们接着来看其他的文件夹： lib目录：Tomcat服务端运行的一些依赖，不用关心。 logs目录：所有的日志信息都在这里。 temp目录：存放运行时产生的一些临时文件，不用关心。 work目录：工作目录，Tomcat会将jsp文件转换为java文件（我们后面会讲到，这里暂时不提及） webapp目录：所有的Web项目都在这里，每个文件夹都是一个Web应用程序： 我们发现，官方已经给我们预设了一些项目了，访问后默认使用的项目为ROOT项目，也就是我们默认打开的网站。 我们也可以访问example项目，只需要在后面填写路径即可：http://localhost:8080/examples/，或是docs项目（这个是Tomcat的一些文档）http://localhost:8080/docs/ Tomcat还自带管理页面，我们打开：http://localhost:8080/manager，提示需要用户名和密码，由于不知道是什么，我们先点击取消，页面中出现如下内容： You are not authorized to view this page. If you have not changed any configuration files, please examine the file conf/tomcat-users.xml in your installation. That file must contain the credentials to let you use this webapp. For example, to add the manager-gui role to a user named tomcat with a password of s3cret, add the following to the config file listed above. &lt;role rolename=&quot;manager-gui&quot;/&gt; &lt;user username=&quot;tomcat&quot; password=&quot;s3cret&quot; roles=&quot;manager-gui&quot;/&gt; Note that for Tomcat 7 onwards, the roles required to use the manager application were changed from the single manager role to the following four roles. You will need to assign the role(s) required for the functionality you wish to access. manager-gui - allows access to the HTML GUI and the status pages manager-script - allows access to the text interface and the status pages manager-jmx - allows access to the JMX proxy and the status pages manager-status - allows access to the status pages only The HTML interface is protected against CSRF but the text and JMX interfaces are not. To maintain the CSRF protection: Users with the manager-gui role should not be granted either the manager-script or manager-jmx roles. If the text or jmx interfaces are accessed through a browser (e.g. for testing since these interfaces are intended for tools not humans) then the browser must be closed afterwards to terminate the session. For more information - please see the Manager App How-To. 现在我们按照上面的提示，去配置文件中进行修改： 12&lt;role rolename=&quot;manager-gui&quot;/&gt;&lt;user username=&quot;admin&quot; password=&quot;admin&quot; roles=&quot;manager-gui&quot;/&gt; 现在再次打开管理页面，已经可以成功使用此用户进行登陆了。登录后，展示给我们的是一个图形化界面，我们可以快速预览当前服务器的一些信息，包括已经在运行的Web应用程序，甚至还可以查看当前的Web应用程序有没有出现内存泄露。 同样的，还有一个虚拟主机管理页面，用于一台主机搭建多个Web站点，一般情况下使用不到，这里就不做演示了。 我们可以将我们自己的项目也放到webapp文件夹中，这样就可以直接访问到了，我们在webapp目录下新建test文件夹，将我们之前编写的前端代码全部放入其中（包括html文件、js、css、icon等），重启服务器。 我们可以直接通过 http://localhost:8080/test/ 来进行访问。 使用Maven创建Web项目虽然我们已经可以在Tomcat上部署我们的前端页面了，但是依然只是一个静态页面（每次访问都是同样的样子），那么如何向服务器请求一个动态的页面呢（比如显示我们访问当前页面的时间）这时就需要我们编写一个Web应用程序来实现了，我们需要在用户向服务器发起页面请求时，进行一些处理，再将结果发送给用户的浏览器。 **注意：**这里需要使用终极版IDEA，如果你的还是社区版，就很难受了。 我们打开IDEA，新建一个项目，选择Java Enterprise（社区版没有此选项！）项目名称随便，项目模板选择Web应用程序，然后我们需要配置Web应用程序服务器，将我们的Tomcat服务器集成到IDEA中。配置很简单，首先点击新建，然后设置Tomcat主目录即可，配置完成后，点击下一步即可，依赖项使用默认即可，然后点击完成，之后IDEA会自动帮助我们创建Maven项目。 创建完成后，直接点击右上角即可运行此项目了，但是我们发现，有一个Servlet页面不生效。 需要注意的是，Tomcat10以上的版本比较新，Servlet API包名发生了一些变化，因此我们需要修改一下依赖： 123456&lt;dependency&gt; &lt;groupId&gt;jakarta.servlet&lt;/groupId&gt; &lt;artifactId&gt;jakarta.servlet-api&lt;/artifactId&gt; &lt;version&gt;5.0.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 注意包名全部从javax改为jakarta，我们需要手动修改一下。 感兴趣的可以了解一下为什么名称被修改了： Eclipse基金会在2019年对 Java EE 标准的每个规范进行了重命名，阐明了每个规范在Jakarta EE平台未来的角色。 新的名称Jakarta EE是Java EE的第二次重命名。2006年5月，“J2EE”一词被弃用，并选择了Java EE这个名称。在YouTube还只是一家独立的公司的时候，数字2就就从名字中消失了，而且当时冥王星仍然被认为是一颗行星。同样，作为Java SE 5（2004）的一部分，数字2也从J2SE中删除了，那时谷歌还没有上市。 因为不能再使用javax名称空间，Jakarta EE提供了非常明显的分界线。 Jakarta 9（2019及以后）使用jakarta命名空间。 Java EE 5（2005）到Java EE 8（2017）使用javax命名空间。 Java EE 4使用javax命名空间。 我们可以将项目直接打包为war包（默认），打包好之后，放入webapp文件夹，就可以直接运行我们通过Java编写的Web应用程序了，访问路径为文件的名称。 Servlet前面我们已经完成了基本的环境搭建，那么现在我们就可以开始来了解我们的第一个重要类——Servlet。 它是Java EE的一个标准，大部分的Web服务器都支持此标准，包括Tomcat，就像之前的JDBC一样，由官方定义了一系列接口，而具体实现由我们来编写，最后交给Web服务器（如Tomcat）来运行我们编写的Servlet。 那么，它能做什么呢？我们可以通过实现Servlet来进行动态网页响应，使用Servlet，不再是直接由Tomcat服务器发送我们编写好的静态网页内容（HTML文件），而是由我们通过Java代码进行动态拼接的结果，它能够很好地实现动态网页的返回。 当然，Servlet并不是专用于HTTP协议通信，也可以用于其他的通信，但是一般都是用于HTTP。 创建Servlet那么如何创建一个Servlet呢，非常简单，我们只需要实现Servlet类即可，并添加注解@WebServlet来进行注册。 1234@WebServlet(&quot;/test&quot;)public class TestServlet implements Servlet &#123; ...实现接口方法&#125; 我们现在就可以去访问一下我们的页面：http://localhost:8080/test/test 我们发现，直接访问此页面是没有任何内容的，这是因为我们还没有为该请求方法编写实现，这里先不做讲解，后面我们会对浏览器的请求处理做详细的介绍。 除了直接编写一个类，我们也可以在web.xml中进行注册，现将类上@WebServlet的注解去掉： 12345678&lt;servlet&gt; &lt;servlet-name&gt;test&lt;/servlet-name&gt; &lt;servlet-class&gt;com.example.webtest.TestServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;test&lt;/servlet-name&gt; &lt;url-pattern&gt;/test&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 这样的方式也能注册Servlet，但是显然直接使用注解更加方便，因此之后我们一律使用注解进行开发。只有比较新的版本才支持此注解，老的版本是不支持的哦。 实际上，Tomcat服务器会为我们提供一些默认的Servlet，也就是说在服务器启动后，即使我们什么都不编写，Tomcat也自带了几个默认的Servlet，他们编写在conf目录下的web.xml中： 12345678910111213&lt;!-- The mapping for the default servlet --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- The mappings for the JSP servlet --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;jsp&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 我们发现，默认的Servlet实际上可以帮助我们去访问一些静态资源，这也是为什么我们启动Tomcat服务器之后，能够直接访问webapp目录下的静态页面。 我们可以将之前编写的页面放入到webapp目录下，来测试一下是否能直接访问。 探究Servlet的生命周期我们已经了解了如何注册一个Servlet，那么我们接着来看看，一个Servlet是如何运行的。 首先我们需要了解，Servlet中的方法各自是在什么时候被调用的，我们先编写一个打印语句来看看： 123456789101112131415161718192021222324252627282930313233public class TestServlet implements Servlet &#123; public TestServlet()&#123; System.out.println(&quot;我是构造方法！&quot;); &#125; @Override public void init(ServletConfig servletConfig) throws ServletException &#123; System.out.println(&quot;我是init&quot;); &#125; @Override public ServletConfig getServletConfig() &#123; System.out.println(&quot;我是getServletConfig&quot;); return null; &#125; @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; System.out.println(&quot;我是service&quot;); &#125; @Override public String getServletInfo() &#123; System.out.println(&quot;我是getServletInfo&quot;); return null; &#125; @Override public void destroy() &#123; System.out.println(&quot;我是destroy&quot;); &#125;&#125; 我们首先启动一次服务器，然后访问我们定义的页面，然后再关闭服务器，得到如下的顺序： 我是构造方法！我是init我是service我是service（出现两次是因为浏览器请求了2次，是因为有一次是请求favicon.ico，浏览器通病） 我是destroy 我们可以多次尝试去访问此页面，但是init和构造方法只会执行一次，而每次访问都会执行的是service方法，因此，一个Servlet的生命周期为： 首先执行构造方法完成 Servlet 初始化 Servlet 初始化后调用 init () 方法。 Servlet 调用 service() 方法来处理客户端的请求。 Servlet 销毁前调用 destroy() 方法。 最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。 现在我们发现，实际上在Web应用程序运行时，每当浏览器向服务器发起一个请求时，都会创建一个线程执行一次service方法，来让我们处理用户的请求，并将结果响应给用户。 我们发现service方法中，还有两个参数，ServletRequest和ServletResponse，实际上，用户发起的HTTP请求，就被Tomcat服务器封装为了一个ServletRequest对象，我们得到是其实是Tomcat服务器帮助我们创建的一个实现类，HTTP请求报文中的所有内容，都可以从ServletRequest对象中获取，同理，ServletResponse就是我们需要返回给浏览器的HTTP响应报文实体类封装。 那么我们来看看ServletRequest中有哪些内容，我们可以获取请求的一些信息： 123456789101112131415@Overridepublic void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; //首先将其转换为HttpServletRequest（继承自ServletRequest，一般是此接口实现） HttpServletRequest request = (HttpServletRequest) servletRequest; System.out.println(request.getProtocol()); //获取协议版本 System.out.println(request.getRemoteAddr()); //获取访问者的IP地址 System.out.println(request.getMethod()); //获取请求方法 //获取头部信息 Enumeration&lt;String&gt; enumeration = request.getHeaderNames(); while (enumeration.hasMoreElements())&#123; String name = enumeration.nextElement(); System.out.println(name + &quot;: &quot; + request.getHeader(name)); &#125;&#125; 我们发现，整个HTTP请求报文中的所有内容，都可以通过HttpServletRequest对象来获取，当然，它的作用肯定不仅仅是获取头部信息，我们还可以使用它来完成更多操作，后面会一一讲解。 那么我们再来看看ServletResponse，这个是服务端的响应内容，我们可以在这里填写我们想要发送给浏览器显示的内容： 1234567//转换为HttpServletResponse（同上）HttpServletResponse response = (HttpServletResponse) servletResponse;//设定内容类型以及编码格式（普通HTML文本使用text/html，之后会讲解文件传输）response.setHeader(&quot;Content-type&quot;, &quot;text/html;charset=UTF-8&quot;);//获取Writer直接写入内容response.getWriter().write(&quot;我是响应内容！&quot;);//所有内容写入完成之后，再发送给浏览器 现在我们在浏览器中打开此页面，就能够收到服务器发来的响应内容了。其中，响应头部分，是由Tomcat帮助我们生成的一个默认响应头。 因此，实际上整个流程就已经很清晰明了了。 解读和使用HttpServlet前面我们已经学习了如何创建、注册和使用Servlet，那么我们继续来深入学习Servlet接口的一些实现类。 首先Servlet有一个直接实现抽象类GenericServlet，那么我们来看看此类做了什么事情。 我们发现，这个类完善了配置文件读取和Servlet信息相关的的操作，但是依然没有去实现service方法，因此此类仅仅是用于完善一个Servlet的基本操作，那么我们接着来看HttpServlet，它是遵循HTTP协议的一种Servlet，继承自GenericServlet，它根据HTTP协议的规则，完善了service方法。 在阅读了HttpServlet源码之后，我们发现，其实我们只需要继承HttpServlet来编写我们的Servlet就可以了，并且它已经帮助我们提前实现了一些操作，这样就会给我们省去很多的时间。 12345678910@Log@WebServlet(&quot;/test&quot;)public class TestServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setContentType(&quot;text/html;charset=UTF-8&quot;); resp.getWriter().write(&quot;&lt;h1&gt;恭喜你解锁了全新玩法&lt;/h1&gt;&quot;); &#125;&#125; 现在，我们只需要重写对应的请求方式，就可以快速完成Servlet的编写。 @WebServlet注解详解我们接着来看WebServlet注解，我们前面已经得知，可以直接使用此注解来快速注册一个Servlet，那么我们来想细看看此注解还有什么其他的玩法。 首先name属性就是Servlet名称，而urlPatterns和value实际上是同样功能，就是代表当前Servlet的访问路径，它不仅仅可以是一个固定值，还可以进行通配符匹配： 1@WebServlet(&quot;/test/*&quot;) 上面的路径表示，所有匹配/test/随便什么的路径名称，都可以访问此Servlet，我们可以在浏览器中尝试一下。 也可以进行某个扩展名称的匹配： 1@WebServlet(&quot;*.js&quot;) 这样的话，获取任何以js结尾的文件，都会由我们自己定义的Servlet处理。 那么如果我们的路径为/呢？ 1@WebServlet(&quot;/&quot;) 此路径和Tomcat默认为我们提供的Servlet冲突，会直接替换掉默认的，而使用我们的，此路径的意思为，如果没有找到匹配当前访问路径的Servlet，那么久会使用此Servlet进行处理。 我们还可以为一个Servlet配置多个访问路径： 1@WebServlet(&#123;&quot;/test1&quot;, &quot;/test2&quot;&#125;) 我们接着来看loadOnStartup属性，此属性决定了是否在Tomcat启动时就加载此Servlet，默认情况下，Servlet只有在被访问时才会加载，它的默认值为-1，表示不在启动时加载，我们可以将其修改为大于等于0的数，来开启启动时加载。并且数字的大小决定了此Servlet的启动优先级。 12345678910111213141516@Log@WebServlet(value = &quot;/test&quot;, loadOnStartup = 1)public class TestServlet extends HttpServlet &#123; @Override public void init() throws ServletException &#123; super.init(); log.info(&quot;我被初始化了！&quot;); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setContentType(&quot;text/html;charset=UTF-8&quot;); resp.getWriter().write(&quot;&lt;h1&gt;恭喜你解锁了全新玩法&lt;/h1&gt;&quot;); &#125;&#125; 其他内容都是Servlet的一些基本配置，这里就不详细讲解了。 使用POST请求完成登陆我们前面已经了解了如何使用Servlet来处理HTTP请求，那么现在，我们就结合前端，来实现一下登陆操作。 我们需要修改一下我们的Servlet，现在我们要让其能够接收一个POST请求： 12345678910@Log@WebServlet(&quot;/login&quot;)public class LoginServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; req.getParameterMap().forEach((k, v) -&gt; &#123; System.out.println(k + &quot;: &quot; + Arrays.toString(v)); &#125;); &#125;&#125; ParameterMap存储了我们发送的POST请求所携带的表单数据，我们可以直接将其遍历查看，浏览器发送了什么数据。 现在我们再来修改一下前端： 12345678910111213141516171819&lt;body&gt; &lt;h1&gt;登录到系统&lt;/h1&gt; &lt;form method=&quot;post&quot; action=&quot;login&quot;&gt; &lt;hr&gt; &lt;div&gt; &lt;label&gt; &lt;input type=&quot;text&quot; placeholder=&quot;用户名&quot; name=&quot;username&quot;&gt; &lt;/label&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt; &lt;input type=&quot;password&quot; placeholder=&quot;密码&quot; name=&quot;password&quot;&gt; &lt;/label&gt; &lt;/div&gt; &lt;div&gt; &lt;button&gt;登录&lt;/button&gt; &lt;/div&gt; &lt;/form&gt;&lt;/body&gt; 通过修改form标签的属性，现在我们点击登录按钮，会自动向后台发送一个POST请求，请求地址为当前地址+&#x2F;login（注意不同路径的写法），也就是我们上面编写的Servlet路径。 运行服务器，测试后发现，在点击按钮后，确实向服务器发起了一个POST请求，并且携带了表单中文本框的数据。 现在，我们根据已有的基础，将其与数据库打通，我们进行一个真正的用户登录操作，首先修改一下Servlet的逻辑： 12345678910111213141516@Overrideprotected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //首先设置一下响应类型 resp.setContentType(&quot;text/html;charset=UTF-8&quot;); //获取POST请求携带的表单数据 Map&lt;String, String[]&gt; map = req.getParameterMap(); //判断表单是否完整 if(map.containsKey(&quot;username&quot;) &amp;&amp; map.containsKey(&quot;password&quot;)) &#123; String username = req.getParameter(&quot;username&quot;); String password = req.getParameter(&quot;password&quot;); //权限校验（待完善） &#125;else &#123; resp.getWriter().write(&quot;错误，您的表单数据不完整！&quot;); &#125;&#125; 接下来我们再去编写Mybatis的依赖和配置文件，创建一个表，用于存放我们用户的账号和密码。 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;驱动类（含包名）&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;数据库连接URL&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;用户名&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;密码&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt; 12345678910&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.27&lt;/version&gt;&lt;/dependency&gt; 配置完成后，在我们的Servlet的init方法中编写Mybatis初始化代码，因为它只需要初始化一次。 123456SqlSessionFactory factory;@SneakyThrows@Overridepublic void init() throws ServletException &#123; factory = new SqlSessionFactoryBuilder().build(Resources.getResourceAsReader(&quot;mybatis-config.xml&quot;));&#125; 现在我们创建一个实体类以及Mapper来进行用户信息查询： 12345@Datapublic class User &#123; String username; String password;&#125; 12345public interface UserMapper &#123; @Select(&quot;select * from users where username = #&#123;username&#125; and password = #&#123;password&#125;&quot;) User getUser(@Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password);&#125; 123&lt;mappers&gt; &lt;mapper class=&quot;com.example.dao.UserMapper&quot;/&gt;&lt;/mappers&gt; 好了，现在完事具备，只欠东风了，我们来完善一下登陆验证逻辑： 1234567891011//登陆校验（待完善）try (SqlSession sqlSession = factory.openSession(true))&#123; UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.getUser(username, password); //判断用户是否登陆成功，若查询到信息则表示存在此用户 if(user != null)&#123; resp.getWriter().write(&quot;登陆成功！&quot;); &#125;else &#123; resp.getWriter().write(&quot;登陆失败，请验证您的用户名或密码！&quot;); &#125;&#125; 现在再去浏览器上进行测试吧！ 注册界面其实是同理的，这里就不多做讲解了。 上传和下载文件首先我们来看看比较简单的下载文件，首先将我们的icon.png放入到resource文件夹中，接着我们编写一个Servlet用于处理文件下载： 1234567891011@WebServlet(&quot;/file&quot;)public class FileServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setContentType(&quot;image/png&quot;); OutputStream outputStream = resp.getOutputStream(); InputStream inputStream = Resources.getResourceAsStream(&quot;icon.png&quot;); &#125;&#125; 为了更加快速地编写IO代码，我们可以引入一个工具库： 12345&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt; 使用此类库可以快速完成IO操作： 12345resp.setContentType(&quot;image/png&quot;);OutputStream outputStream = resp.getOutputStream();InputStream inputStream = Resources.getResourceAsStream(&quot;icon.png&quot;);//直接使用copy方法完成转换IOUtils.copy(inputStream, outputStream); 现在我们在前端页面添加一个链接，用于下载此文件： 12&lt;hr&gt;&lt;a href=&quot;file&quot; download=&quot;icon.png&quot;&gt;点我下载高清资源&lt;/a&gt; 下载文件搞定，那么如何上传一个文件呢？ 首先我们编写前端部分： 12345678&lt;form method=&quot;post&quot; action=&quot;file&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;div&gt; &lt;input type=&quot;file&quot; name=&quot;test-file&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;button&gt;上传文件&lt;/button&gt; &lt;/div&gt;&lt;/form&gt; 注意必须添加enctype=&quot;multipart/form-data&quot;，来表示此表单用于文件传输。 现在我们来修改一下Servlet代码： 1234567891011121314@MultipartConfig@WebServlet(&quot;/file&quot;)public class FileServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; try(FileOutputStream stream = new FileOutputStream(&quot;/Users/nagocoler/Documents/IdeaProjects/WebTest/test.png&quot;))&#123; Part part = req.getPart(&quot;test-file&quot;); IOUtils.copy(part.getInputStream(), stream); resp.setContentType(&quot;text/html;charset=UTF-8&quot;); resp.getWriter().write(&quot;文件上传成功！&quot;); &#125; &#125;&#125; 注意，必须添加@MultipartConfig注解来表示此Servlet用于处理文件上传请求。 现在我们再运行服务器，并将我们刚才下载的文件又上传给服务端。 使用XHR请求数据现在我们希望，网页中的部分内容，可以动态显示，比如网页上有一个时间，旁边有一个按钮，点击按钮就可以刷新当前时间。 这个时候就需要我们在网页展示时向后端发起请求了，并根据后端响应的结果，动态地更新页面中的内容，要实现此功能，就需要用到JavaScript来帮助我们，首先在js中编写我们的XHR请求，并在请求中完成动态更新： 12345678910function updateTime() &#123; let xhr = new XMLHttpRequest(); xhr.onreadystatechange = function() &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; document.getElementById(&quot;time&quot;).innerText = xhr.responseText &#125; &#125;; xhr.open(&#x27;GET&#x27;, &#x27;time&#x27;, true); xhr.send();&#125; 接着修改一下前端页面，添加一个时间显示区域： 1234567&lt;hr&gt;&lt;div id=&quot;time&quot;&gt;&lt;/div&gt;&lt;br&gt;&lt;button onclick=&quot;updateTime()&quot;&gt;更新数据&lt;/button&gt;&lt;script&gt; updateTime()&lt;/script&gt; 最后创建一个Servlet用于处理时间更新请求： 1234567891011@WebServlet(&quot;/time&quot;)public class TimeServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;); String date = dateFormat.format(new Date()); resp.setContentType(&quot;text/html;charset=UTF-8&quot;); resp.getWriter().write(date); &#125;&#125; 现在点击按钮就可以更新了。 GET请求也能传递参数，这里做一下演示。 重定向与请求转发当我们希望用户登录完成之后，直接跳转到网站的首页，那么这个时候，我们就可以使用重定向来完成。当浏览器收到一个重定向的响应时，会按照重定向响应给出的地址，再次向此地址发出请求。 实现重定向很简单，只需要调用一个方法即可，我们修改一下登陆成功后执行的代码： 1resp.sendRedirect(&quot;time&quot;); 调用后，响应的状态码会被设置为302，并且响应头中添加了一个Location属性，此属性表示，需要重定向到哪一个网址。 现在，如果我们成功登陆，那么服务器会发送给我们一个重定向响应，这时，我们的浏览器会去重新请求另一个网址。这样，我们在登陆成功之后，就可以直接帮助用户跳转到用户首页了。 那么我们接着来看请求转发，请求转发其实是一种服务器内部的跳转机制，我们知道，重定向会使得浏览器去重新请求一个页面，而请求转发则是服务器内部进行跳转，它的目的是，直接将本次请求转发给其他Servlet进行处理，并由其他Servlet来返回结果，因此它是在进行内部的转发。 1req.getRequestDispatcher(&quot;/time&quot;).forward(req, resp); 现在，在登陆成功的时候，我们将请求转发给处理时间的Servlet，注意这里的路径规则和之前的不同，我们需要填写Servlet上指明的路径，并且请求转发只能转发到此应用程序内部的Servlet，不能转发给其他站点或是其他Web应用程序。 现在再次进行登陆操作，我们发现，返回结果为一个405页面，证明了，我们的请求现在是被另一个Servlet进行处理，并且请求的信息全部被转交给另一个Servlet，由于此Servlet不支持POST请求，因此返回405状态码。 那么也就是说，该请求包括请求参数也一起被传递了，那么我们可以尝试获取以下POST请求的参数。 现在我们给此Servlet添加POST请求处理，直接转交给Get请求处理： 1234@Overrideprotected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req, resp);&#125; 再次访问，成功得到结果，但是我们发现，浏览器只发起了一次请求，并没有再次请求新的URL，也就是说，这一次请求直接返回了请求转发后的处理结果。 那么，请求转发有什么好处呢？它可以携带数据！ 12req.setAttribute(&quot;test&quot;, &quot;我是请求转发前的数据&quot;);req.getRequestDispatcher(&quot;/time&quot;).forward(req, resp); 1System.out.println(req.getAttribute(&quot;test&quot;)); 通过setAttribute方法来给当前请求添加一个附加数据，在请求转发后，我们可以直接获取到该数据。 重定向属于2次请求，因此无法使用这种方式来传递数据，那么，如何在重定向之间传递数据呢？我们可以使用即将要介绍的ServletContext对象。 最后总结，两者的区别为： 请求转发是一次请求，重定向是两次请求 请求转发地址栏不会发生改变， 重定向地址栏会发生改变 请求转发可以共享请求参数 ，重定向之后，就获取不了共享参数了 请求转发只能转发给内部的Servlet 了解ServletContext对象ServletContext全局唯一，它是属于整个Web应用程序的，我们可以通过getServletContext()来获取到此对象。 此对象也能设置附加值： 123ServletContext context = getServletContext();context.setAttribute(&quot;test&quot;, &quot;我是重定向之前的数据&quot;);resp.sendRedirect(&quot;time&quot;); 1System.out.println(getServletContext().getAttribute(&quot;test&quot;)); 因为无论在哪里，无论什么时间，获取到的ServletContext始终是同一个对象，因此我们可以随时随地获取我们添加的属性。 它不仅仅可以用来进行数据传递，还可以做一些其他的事情，比如请求转发： 1context.getRequestDispatcher(&quot;/time&quot;).forward(req, resp); 它还可以获取根目录下的资源文件（注意是webapp根目录下的，不是resource中的资源） 初始化参数初始化参数类似于初始化配置需要的一些值，比如我们的数据库连接相关信息，就可以通过初始化参数来给予Servlet，或是一些其他的配置项，也可以使用初始化参数来实现。 我们可以给一个Servlet添加一些初始化参数： 123@WebServlet(value = &quot;/login&quot;, initParams = &#123; @WebInitParam(name = &quot;test&quot;, value = &quot;我是一个默认的初始化参数&quot;)&#125;) 它也是以键值对形式保存的，我们可以直接通过Servlet的getInitParameter方法获取： 1System.out.println(getInitParameter(&quot;test&quot;)); 但是，这里的初始化参数仅仅是针对于此Servlet，我们也可以定义全局初始化参数，只需要在web.xml编写即可： 1234&lt;context-param&gt; &lt;param-name&gt;lbwnb&lt;/param-name&gt; &lt;param-value&gt;我是全局初始化参数&lt;/param-value&gt;&lt;/context-param&gt; 我们需要使用ServletContext来读取全局初始化参数： 12ServletContext context = getServletContext();System.out.println(context.getInitParameter(&quot;lbwnb&quot;)); 有关ServletContext其他的内容，我们需要完成后面内容的学习，才能理解。 Cookie什么是Cookie？不是曲奇，它可以在浏览器中保存一些信息，并且在下次请求时，请求头中会携带这些信息。 我们可以编写一个测试用例来看看： 123Cookie cookie = new Cookie(&quot;test&quot;, &quot;yyds&quot;);resp.addCookie(cookie);resp.sendRedirect(&quot;time&quot;); 123for (Cookie cookie : req.getCookies()) &#123; System.out.println(cookie.getName() + &quot;: &quot; + cookie.getValue());&#125; 我们可以观察一下，在HttpServletResponse中添加Cookie之后，浏览器的响应头中会包含一个Set-Cookie属性，同时，在重定向之后，我们的请求头中，会携带此Cookie作为一个属性，同时，我们可以直接通过HttpServletRequest来快速获取有哪些Cookie信息。 还有这么神奇的事情吗？那么我们来看看，一个Cookie包含哪些信息： name - Cookie的名称，Cookie一旦创建，名称便不可更改 value - Cookie的值，如果值为Unicode字符，需要为字符编码。如果为二进制数据，则需要使用BASE64编码 maxAge - Cookie失效的时间，单位秒。如果为正数，则该Cookie在maxAge秒后失效。如果为负数，该Cookie为临时Cookie，关闭浏览器即失效，浏览器也不会以任何形式保存该Cookie。如果为0，表示删除该Cookie。默认为-1。 secure - 该Cookie是否仅被使用安全协议传输。安全协议。安全协议有HTTPS，SSL等，在网络上传输数据之前先将数据加密。默认为false。 path - Cookie的使用路径。如果设置为“&#x2F;sessionWeb&#x2F;”，则只有contextPath为“&#x2F;sessionWeb”的程序可以访问该Cookie。如果设置为“&#x2F;”，则本域名下contextPath都可以访问该Cookie。注意最后一个字符必须为“&#x2F;”。 domain - 可以访问该Cookie的域名。如果设置为“.google.com”，则所有以“google.com”结尾的域名都可以访问该Cookie。注意第一个字符必须为“.”。 comment - 该Cookie的用处说明，浏览器显示Cookie信息的时候显示该说明。 version - Cookie使用的版本号。0表示遵循Netscape的Cookie规范，1表示遵循W3C的RFC 2109规范 我们发现，最关键的其实是name、value、maxAge、domain属性。 那么我们来尝试修改一下maxAge来看看失效时间： 1cookie.setMaxAge(20); 设定为20秒，我们可以直接看到，响应头为我们设定了20秒的过期时间。20秒内访问都会携带此Cookie，而超过20秒，Cookie消失。 既然了解了Cookie的作用，我们就可以通过使用Cookie来实现记住我功能，我们可以将用户名和密码全部保存在Cookie中，如果访问我们的首页时携带了这些Cookie，那么我们就可以直接为用户进行登陆，如果登陆成功则直接跳转到首页，如果登陆失败，则清理浏览器中的Cookie。 那么首先，我们先在前端页面的表单中添加一个勾选框： 123456&lt;div&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot; placeholder=&quot;记住我&quot; name=&quot;remember-me&quot;&gt; 记住我 &lt;/label&gt;&lt;/div&gt; 接着，我们在登陆成功时进行判断，如果用户勾选了记住我，那么就讲Cookie存储到本地： 12345678if(map.containsKey(&quot;remember-me&quot;))&#123; //若勾选了勾选框，那么会此表单信息 Cookie cookie_username = new Cookie(&quot;username&quot;, username); cookie_username.setMaxAge(30); Cookie cookie_password = new Cookie(&quot;password&quot;, password); cookie_password.setMaxAge(30); resp.addCookie(cookie_username); resp.addCookie(cookie_password);&#125; 然后，我们修改一下默认的请求地址，现在一律通过http://localhost:8080/yyds/login进行登陆，那么我们需要添加GET请求的相关处理： 123456789101112131415161718192021222324@Overrideprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; Cookie[] cookies = req.getCookies(); if(cookies != null)&#123; String username = null; String password = null; for (Cookie cookie : cookies) &#123; if(cookie.getName().equals(&quot;username&quot;)) username = cookie.getValue(); if(cookie.getName().equals(&quot;password&quot;)) password = cookie.getValue(); &#125; if(username != null &amp;&amp; password != null)&#123; //登陆校验 try (SqlSession sqlSession = factory.openSession(true))&#123; UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.getUser(username, password); if(user != null)&#123; resp.sendRedirect(&quot;time&quot;); return; //直接返回 &#125; &#125; &#125; &#125; req.getRequestDispatcher(&quot;/&quot;).forward(req, resp); //正常情况还是转发给默认的Servlet帮我们返回静态页面&#125; 现在，30秒内都不需要登陆，访问登陆页面后，会直接跳转到time页面。 现在已经离我们理想的页面越来越接近了，但是仍然有一个问题，就是我们的首页，无论是否登陆，所有人都可以访问，那么，如何才可以实现只有登陆之后才能访问呢？这就需要用到Session了。 Session由于HTTP是无连接的，那么如何能够辨别当前的请求是来自哪个用户发起的呢？Session就是用来处理这种问题的，每个用户的会话都会有一个自己的Session对象，来自同一个浏览器的所有请求，就属于同一个会话。 但是HTTP协议是无连接的呀，那Session是如何做到辨别是否来自同一个浏览器呢？Session实际上是基于Cookie实现的，前面我们了解了Cookie，我们知道，服务端可以将Cookie保存到浏览器，当浏览器下次访问时，就会附带这些Cookie信息。 Session也利用了这一点，它会给浏览器设定一个叫做JSESSIONID的Cookie，值是一个随机的排列组合，而此Cookie就对应了你属于哪一个对话，只要我们的浏览器携带此Cookie访问服务器，服务器就会通过Cookie的值进行辨别，得到对应的Session对象，因此，这样就可以追踪到底是哪一个浏览器在访问服务器。 那么现在，我们在用户登录成功之后，将用户对象添加到Session中，只要是此用户发起的请求，我们都可以从HttpSession中读取到存储在会话中的数据： 12HttpSession session = req.getSession();session.setAttribute(&quot;user&quot;, user); 同时，如果用户没有登录就去访问首页，那么我们将发送一个重定向请求，告诉用户，需要先进行登录才可以访问： 123456HttpSession session = req.getSession();User user = (User) session.getAttribute(&quot;user&quot;);if(user == null) &#123; resp.sendRedirect(&quot;login&quot;); return;&#125; 在访问的过程中，注意观察Cookie变化。 Session并不是永远都存在的，它有着自己的过期时间，默认时间为30分钟，若超过此时间，Session将丢失，我们可以在配置文件中修改过期时间： 123&lt;session-config&gt; &lt;session-timeout&gt;1&lt;/session-timeout&gt;&lt;/session-config&gt; 我们也可以在代码中使用invalidate方法来使Session立即失效： 1session.invalidate(); 现在，通过Session，我们就可以更好地控制用户对于资源的访问，只有完成登陆的用户才有资格访问首页。 Filter有了Session之后，我们就可以很好地控制用户的登陆验证了，只有授权的用户，才可以访问一些页面，但是我们需要一个一个去进行配置，还是太过复杂，能否一次性地过滤掉没有登录验证的用户呢？ 过滤器相当于在所有访问前加了一堵墙，来自浏览器的所有访问请求都会首先经过过滤器，只有过滤器允许通过的请求，才可以顺利地到达对应的Servlet，而过滤器不允许的通过的请求，我们可以自由地进行控制是否进行重定向或是请求转发。并且过滤器可以添加很多个，就相当于添加了很多堵墙，我们的请求只有穿过层层阻碍，才能与Servlet相拥，像极了爱情。 添加一个过滤器非常简单，只需要实现Filter接口，并添加@WebFilter注解即可： 1234567@WebFilter(&quot;/*&quot;) //路径的匹配规则和Servlet一致，这里表示匹配所有请求public class TestFilter implements Filter &#123; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; &#125;&#125; 这样我们就成功地添加了一个过滤器，那么添加一句打印语句看看，是否所有的请求都会经过此过滤器： 12HttpServletRequest request = (HttpServletRequest) servletRequest;System.out.println(request.getRequestURL()); 我们发现，现在我们发起的所有请求，一律需要经过此过滤器，并且所有的请求都没有任何的响应内容。 那么如何让请求可以顺利地到达对应的Servlet，也就是说怎么让这个请求顺利通过呢？我们只需要在最后添加一句： 1filterChain.doFilter(servletRequest, servletResponse); 那么这行代码是什么意思呢？ 由于我们整个应用程序可能存在多个过滤器，那么这行代码的意思实际上是将此请求继续传递给下一个过滤器，当没有下一个过滤器时，才会到达对应的Servlet进行处理，我们可以再来创建一个过滤器看看效果： 12345678@WebFilter(&quot;/*&quot;)public class TestFilter2 implements Filter &#123; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(&quot;我是2号过滤器&quot;); filterChain.doFilter(servletRequest, servletResponse); &#125;&#125; 由于过滤器的过滤顺序是按照类名的自然排序进行的，因此我们将第一个过滤器命名进行调整。 我们发现，在经过第一个过滤器之后，会继续前往第二个过滤器，只有两个过滤器全部经过之后，才会到达我们的Servlet中。 实际上，当doFilter方法调用时，就会一直向下直到Servlet，在Servlet处理完成之后，又依次返回到最前面的Filter，类似于递归的结构，我们添加几个输出语句来判断一下： 123456@Overridepublic void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(&quot;我是2号过滤器&quot;); filterChain.doFilter(servletRequest, servletResponse); System.out.println(&quot;我是2号过滤器，处理后&quot;);&#125; 123456@Overridepublic void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(&quot;我是1号过滤器&quot;); filterChain.doFilter(servletRequest, servletResponse); System.out.println(&quot;我是1号过滤器，处理后&quot;);&#125; 最后验证我们的结论。 同Servlet一样，Filter也有对应的HttpFilter专用类，它针对HTTP请求进行了专门处理，因此我们可以直接使用HttpFilter来编写： 123456789101112131415161718public abstract class HttpFilter extends GenericFilter &#123; private static final long serialVersionUID = 7478463438252262094L; public HttpFilter() &#123; &#125; public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException &#123; if (req instanceof HttpServletRequest &amp;&amp; res instanceof HttpServletResponse) &#123; this.doFilter((HttpServletRequest)req, (HttpServletResponse)res, chain); &#125; else &#123; throw new ServletException(&quot;non-HTTP request or response&quot;); &#125; &#125; protected void doFilter(HttpServletRequest req, HttpServletResponse res, FilterChain chain) throws IOException, ServletException &#123; chain.doFilter(req, res); &#125;&#125; 那么现在，我们就可以给我们的应用程序添加一个过滤器，用户在未登录情况下，只允许静态资源和登陆页面请求通过，登陆之后畅行无阻： 12345678910111213141516171819@WebFilter(&quot;/*&quot;)public class MainFilter extends HttpFilter &#123; @Override protected void doFilter(HttpServletRequest req, HttpServletResponse res, FilterChain chain) throws IOException, ServletException &#123; String url = req.getRequestURL().toString(); //判断是否为静态资源 if(!url.endsWith(&quot;.js&quot;) &amp;&amp; !url.endsWith(&quot;.css&quot;) &amp;&amp; !url.endsWith(&quot;.png&quot;))&#123; HttpSession session = req.getSession(); User user = (User) session.getAttribute(&quot;user&quot;); //判断是否未登陆 if(user == null &amp;&amp; !url.endsWith(&quot;login&quot;))&#123; res.sendRedirect(&quot;login&quot;); return; &#125; &#125; //交给过滤链处理 chain.doFilter(req, res); &#125;&#125; 现在，我们的页面已经基本完善为我们想要的样子了。 当然，可能跟着教程编写的项目比较乱，大家可以自己花费一点时间来重新编写一个Web应用程序，加深对之前讲解知识的理解。我们也会在之后安排一个编程实战进行深化练习。 Listener监听器并不是我们学习的重点内容，那么什么是监听器呢？ 如果我们希望，在应用程序加载的时候，或是Session创建的时候，亦或是在Request对象创建的时候进行一些操作，那么这个时候，我们就可以使用监听器来实现。 默认为我们提供了很多类型的监听器，我们这里就演示一下监听Session的创建即可： 1234567@WebListenerpublic class TestListener implements HttpSessionListener &#123; @Override public void sessionCreated(HttpSessionEvent se) &#123; System.out.println(&quot;有一个Session被创建了&quot;); &#125;&#125; 有关监听器相关内容，了解即可。 了解JSP页面与加载规则前面我们已经完成了整个Web应用程序生命周期中所有内容的学习，我们已经完全了解，如何编写一个Web应用程序，并放在Tomcat上部署运行，以及如何控制浏览器发来的请求，通过Session+Filter实现用户登陆验证，通过Cookie实现自动登陆等操作。到目前为止，我们已经具备编写一个完整Web网站的能力。 在之前的教程中，我们的前端静态页面并没有与后端相结合，我们前端页面所需的数据全部需要单独向后端发起请求获取，并动态进行内容填充，这是一种典型的前后端分离写法，前端只负责要数据和显示数据，后端只负责处理数据和提供数据，这也是现在更流行的一种写法，让前端开发者和后端开发者各尽其责，更加专一，这才是我们所希望的开发模式。 JSP并不是我们需要重点学习的内容，因为它已经过时了，使用JSP会导致前后端严重耦合，因此这里只做了解即可。 JSP其实就是一种模板引擎，那么何谓模板引擎呢？顾名思义，它就是一个模板，而模板需要我们填入数据，才可以变成一个页面，也就是说，我们可以直接在前端页面中直接填写数据，填写后生成一个最终的HTML页面返回给前端。 首先我们来创建一个新的项目，项目创建成功后，删除Java目录下的内容，只留下默认创建的jsp文件，我们发现，在webapp目录中，存在一个index.jsp文件，现在我们直接运行项目，会直接访问这个JSP页面。 12345678910111213&lt;%@ page contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;JSP - Hello World&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;&lt;%= &quot;Hello World!&quot; %&gt;&lt;/h1&gt;&lt;br/&gt;&lt;a href=&quot;hello-servlet&quot;&gt;Hello Servlet&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 但是我们并没有编写对应的Servlet来解析啊，那么为什么这个JSP页面会被加载呢？ 实际上，我们一开始提到的两个Tomcat默认的Servlet中，一个是用于请求静态资源，还有一个就是用于处理jsp的： 123456&lt;!-- The mappings for the JSP servlet --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;jsp&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 那么，JSP和普通HTML页面有什么区别呢，我们发现它的语法和普通HTML页面几乎一致，我们可以直接在JSP中编写Java代码，并在页面加载的时候执行，我们随便找个地方插入： 123&lt;% System.out.println(&quot;JSP页面被加载&quot;);%&gt; 我们发现，请求一次页面，页面就会加载一次，并执行我们填写的Java代码。也就是说，我们可以直接在此页面中执行Java代码来填充我们的数据，这样我们的页面就变成了一个动态页面，使用&lt;%= %&gt;来填写一个值： 1&lt;h1&gt;&lt;%= new Date() %&gt;&lt;/h1&gt; 现在访问我们的网站，每次都会创建一个新的Date对象，因此每次访问获取的时间都不一样，我们的网站已经算是一个动态的网站的了。 虽然这样在一定程度上上为我们提供了便利，但是这样的写法相当于整个页面既要编写前端代码，也要编写后端代码，随着项目的扩大，整个页面会显得难以阅读，并且现在都是前后端开发人员职责非常明确的，如果要编写JSP页面，那就必须要招一个既会前端也会后端的程序员，这样显然会导致不必要的开销。 那么我们来研究一下，为什么JSP页面能够在加载的时候执行Java代码呢？ 首先我们将此项目打包，并在Tomcat服务端中运行，生成了一个文件夹并且可以正常访问。 我们现在看到work目录，我们发现这个里面多了一个index_jsp.java和index_jsp.class，那么这些东西是干嘛的呢，我们来反编译一下就啥都知道了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public final class index_jsp extends org.apache.jasper.runtime.HttpJspBase //继承自HttpServlet implements org.apache.jasper.runtime.JspSourceDependent, org.apache.jasper.runtime.JspSourceImports &#123; ... public void _jspService(final jakarta.servlet.http.HttpServletRequest request, final jakarta.servlet.http.HttpServletResponse response) throws java.io.IOException, jakarta.servlet.ServletException &#123; if (!jakarta.servlet.DispatcherType.ERROR.equals(request.getDispatcherType())) &#123; final java.lang.String _jspx_method = request.getMethod(); if (&quot;OPTIONS&quot;.equals(_jspx_method)) &#123; response.setHeader(&quot;Allow&quot;,&quot;GET, HEAD, POST, OPTIONS&quot;); return; &#125; if (!&quot;GET&quot;.equals(_jspx_method) &amp;&amp; !&quot;POST&quot;.equals(_jspx_method) &amp;&amp; !&quot;HEAD&quot;.equals(_jspx_method)) &#123; response.setHeader(&quot;Allow&quot;,&quot;GET, HEAD, POST, OPTIONS&quot;); response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, &quot;JSP 只允许 GET、POST 或 HEAD。Jasper 还允许 OPTIONS&quot;); return; &#125; &#125; final jakarta.servlet.jsp.PageContext pageContext; jakarta.servlet.http.HttpSession session = null; final jakarta.servlet.ServletContext application; final jakarta.servlet.ServletConfig config; jakarta.servlet.jsp.JspWriter out = null; final java.lang.Object page = this; jakarta.servlet.jsp.JspWriter _jspx_out = null; jakarta.servlet.jsp.PageContext _jspx_page_context = null; try &#123; response.setContentType(&quot;text/html; charset=UTF-8&quot;); pageContext = _jspxFactory.getPageContext(this, request, response, null, true, 8192, true); _jspx_page_context = pageContext; application = pageContext.getServletContext(); config = pageContext.getServletConfig(); session = pageContext.getSession(); out = pageContext.getOut(); _jspx_out = out; out.write(&quot;\\n&quot;); out.write(&quot;\\n&quot;); out.write(&quot;&lt;!DOCTYPE html&gt;\\n&quot;); out.write(&quot;&lt;html&gt;\\n&quot;); out.write(&quot;&lt;head&gt;\\n&quot;); out.write(&quot; &lt;title&gt;JSP - Hello World&lt;/title&gt;\\n&quot;); out.write(&quot;&lt;/head&gt;\\n&quot;); out.write(&quot;&lt;body&gt;\\n&quot;); out.write(&quot;&lt;h1&gt;&quot;); out.print( new Date() ); out.write(&quot;&lt;/h1&gt;\\n&quot;); System.out.println(&quot;JSP页面被加载&quot;); out.write(&quot;\\n&quot;); out.write(&quot;&lt;br/&gt;\\n&quot;); out.write(&quot;&lt;a href=\\&quot;hello-servlet\\&quot;&gt;Hello Servlet&lt;/a&gt;\\n&quot;); out.write(&quot;&lt;/body&gt;\\n&quot;); out.write(&quot;&lt;/html&gt;&quot;); &#125; catch (java.lang.Throwable t) &#123; if (!(t instanceof jakarta.servlet.jsp.SkipPageException))&#123; out = _jspx_out; if (out != null &amp;&amp; out.getBufferSize() != 0) try &#123; if (response.isCommitted()) &#123; out.flush(); &#125; else &#123; out.clearBuffer(); &#125; &#125; catch (java.io.IOException e) &#123;&#125; if (_jspx_page_context != null) _jspx_page_context.handlePageException(t); else throw new ServletException(t); &#125; &#125; finally &#123; _jspxFactory.releasePageContext(_jspx_page_context); &#125; &#125;&#125; 我们发现，它是继承自HttpJspBase类，我们可以反编译一下jasper.jar（它在tomcat的lib目录中）来看看: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package org.apache.jasper.runtime;import jakarta.servlet.ServletConfig;import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import jakarta.servlet.jsp.HttpJspPage;import java.io.IOException;import org.apache.jasper.compiler.Localizer;public abstract class HttpJspBase extends HttpServlet implements HttpJspPage &#123; private static final long serialVersionUID = 1L; protected HttpJspBase() &#123; &#125; public final void init(ServletConfig config) throws ServletException &#123; super.init(config); this.jspInit(); this._jspInit(); &#125; public String getServletInfo() &#123; return Localizer.getMessage(&quot;jsp.engine.info&quot;, new Object[]&#123;&quot;3.0&quot;&#125;); &#125; public final void destroy() &#123; this.jspDestroy(); this._jspDestroy(); &#125; public final void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this._jspService(request, response); &#125; public void jspInit() &#123; &#125; public void _jspInit() &#123; &#125; public void jspDestroy() &#123; &#125; protected void _jspDestroy() &#123; &#125; public abstract void _jspService(HttpServletRequest var1, HttpServletResponse var2) throws ServletException, IOException;&#125; 实际上，Tomcat在加载JSP页面时，会将其动态转换为一个java类并编译为class进行加载，而生成的Java类，正是一个Servlet的子类，而页面的内容全部被编译为输出字符串，这便是JSP的加载原理，因此，JSP本质上依然是一个Servlet！ 如果同学们感兴趣的话，可以查阅一下其他相关的教程，本教程不再讲解此技术。 使用Thymeleaf模板引擎虽然JSP为我们带来了便捷，但是其缺点也是显而易见的，那么有没有一种既能实现模板，又能兼顾前后端分离的模板引擎呢？ Thymeleaf（百里香叶）是一个适用于Web和独立环境的现代化服务器端Java模板引擎，官方文档：https://www.thymeleaf.org/documentation.html。 那么它和JSP相比，好在哪里呢，我们来看官网给出的例子： 1234567891011121314&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th th:text=&quot;#&#123;msgs.headers.name&#125;&quot;&gt;Name&lt;/th&gt; &lt;th th:text=&quot;#&#123;msgs.headers.price&#125;&quot;&gt;Price&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr th:each=&quot;prod: $&#123;allProducts&#125;&quot;&gt; &lt;td th:text=&quot;$&#123;prod.name&#125;&quot;&gt;Oranges&lt;/td&gt; &lt;td th:text=&quot;$&#123;#numbers.formatDecimal(prod.price, 1, 2)&#125;&quot;&gt;0.99&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 我们可以在前端页面中填写占位符，而这些占位符的实际值则由后端进行提供，这样，我们就不用再像JSP那样前后端都写在一起了。 那么我们来创建一个例子感受一下，首先还是新建一个项目，注意，在创建时，勾选Thymeleaf依赖。 首先编写一个前端页面，名称为test.html，注意，是放在resource目录下，在html标签内部添加xmlns:th=&quot;http://www.thymeleaf.org&quot;引入Thymeleaf定义的标签属性： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div th:text=&quot;$&#123;title&#125;&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 接着我们编写一个Servlet作为默认页面： 123456789101112131415161718@WebServlet(&quot;/index&quot;)public class HelloServlet extends HttpServlet &#123; TemplateEngine engine; @Override public void init() throws ServletException &#123; engine = new TemplateEngine(); ClassLoaderTemplateResolver r = new ClassLoaderTemplateResolver(); engine.setTemplateResolver(r); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; Context context = new Context(); context.setVariable(&quot;title&quot;, &quot;我是标题&quot;); engine.process(&quot;test.html&quot;, context, resp.getWriter()); &#125;&#125; 我们发现，浏览器得到的页面，就是已经经过模板引擎解析好的页面，而我们的代码依然是后端处理数据，前端展示数据，因此使用Thymeleaf就能够使得当前Web应用程序的前后端划分更加清晰。 虽然Thymeleaf在一定程度上分离了前后端，但是其依然是在后台渲染HTML页面并发送给前端，并不是真正意义上的前后端分离。 Thymeleaf语法基础那么，如何使用Thymeleaf呢？ 首先我们看看后端部分，我们需要通过TemplateEngine对象来将模板文件渲染为最终的HTML页面： 12345678TemplateEngine engine;@Overridepublic void init() throws ServletException &#123; engine = new TemplateEngine(); //设定模板解析器决定了从哪里获取模板文件，这里直接使用ClassLoaderTemplateResolver表示加载内部资源文件 ClassLoaderTemplateResolver r = new ClassLoaderTemplateResolver(); engine.setTemplateResolver(r);&#125; 由于此对象只需要创建一次，之后就可以一直使用了。接着我们来看如何使用模板引擎进行解析： 12345678@Overrideprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //创建上下文，上下文中包含了所有需要替换到模板中的内容 Context context = new Context(); context.setVariable(&quot;title&quot;, &quot;&lt;h1&gt;我是标题&lt;/h1&gt;&quot;); //通过此方法就可以直接解析模板并返回响应 engine.process(&quot;test.html&quot;, context, resp.getWriter());&#125; 操作非常简单，只需要简单几步配置就可以实现模板的解析。接下来我们就可以在前端页面中通过上下文提供的内容，来将Java代码中的数据解析到前端页面。 接着我们来了解Thymeleaf如何为普通的标签添加内容，比如我们示例中编写的： 1&lt;div th:text=&quot;$&#123;title&#125;&quot;&gt;&lt;/div&gt; 我们使用了th:text来为当前标签指定内部文本，注意任何内容都会变成普通文本，即使传入了一个HTML代码，如果我希望向内部添加一个HTML文本呢？我们可以使用th:utext属性： 1&lt;div th:utext=&quot;$&#123;title&#125;&quot;&gt;&lt;/div&gt; 并且，传入的title属性，不仅仅只是一个字符串的值，而是一个字符串的引用，我们可以直接通过此引用调用相关的方法： 1&lt;div th:text=&quot;$&#123;title.toLowerCase()&#125;&quot;&gt;&lt;/div&gt; 这样看来，Thymeleaf既能保持JSP为我们带来的便捷，也能兼顾前后端代码的界限划分。 除了替换文本，它还支持替换一个元素的任意属性，我们发现，th:能够拼接几乎所有的属性，一旦使用th:属性名称，那么属性的值就可以通过后端提供了，比如我们现在想替换一个图片的链接： 1234567@Overrideprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; Context context = new Context(); context.setVariable(&quot;url&quot;, &quot;http://n.sinaimg.cn/sinakd20121/600/w1920h1080/20210727/a700-adf8480ff24057e04527bdfea789e788.jpg&quot;); context.setVariable(&quot;alt&quot;, &quot;图片就是加载不出来啊&quot;); engine.process(&quot;test.html&quot;, context, resp.getWriter());&#125; 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;img width=&quot;700&quot; th:src=&quot;$&#123;url&#125;&quot; th:alt=&quot;$&#123;alt&#125;&quot;&gt;&lt;/body&gt;&lt;/html&gt; 现在访问我们的页面，就可以看到替换后的结果了。 Thymeleaf还可以进行一些算术运算，几乎Java中的运算它都可以支持： 1&lt;div th:text=&quot;$&#123;value % 2&#125;&quot;&gt;&lt;/div&gt; 同样的，它还支持三元运算： 1&lt;div th:text=&quot;$&#123;value % 2 == 0 ? &#x27;yyds&#x27; : &#x27;lbwnb&#x27;&#125;&quot;&gt;&lt;/div&gt; 多个属性也可以通过+进行拼接，就像Java中的字符串拼接一样，这里要注意一下，字符串不能直接写，要添加单引号： 1&lt;div th:text=&quot;$&#123;name&#125;+&#x27; 我是文本 &#x27;+$&#123;value&#125;&quot;&gt;&lt;/div&gt; Thymeleaf流程控制语法除了一些基本的操作，我们还可以使用Thymeleaf来处理流程控制语句，当然，不是直接编写Java代码的形式，而是添加一个属性即可。 首先我们来看if判断语句，如果if条件满足，则此标签留下，若if条件不满足，则此标签自动被移除： 123456@Overrideprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; Context context = new Context(); context.setVariable(&quot;eval&quot;, true); engine.process(&quot;test.html&quot;, context, resp.getWriter());&#125; 1&lt;div th:if=&quot;$&#123;eval&#125;&quot;&gt;我是判断条件标签&lt;/div&gt; th:if会根据其中传入的值或是条件表达式的结果进行判断，只有满足的情况下，才会显示此标签，具体的判断规则如下： 如果值不是空的： 如果值是布尔值并且为true。 如果值是一个数字，并且是非零 如果值是一个字符，并且是非零 如果值是一个字符串，而不是“错误”、“关闭”或“否” 如果值不是布尔值、数字、字符或字符串。 如果值为空，th:if将计算为false th:if还有一个相反的属性th:unless，效果完全相反，这里就不演示了。 我们接着来看多分支条件判断，我们可以使用th:switch属性来实现： 12345&lt;div th:switch=&quot;$&#123;eval&#125;&quot;&gt; &lt;div th:case=&quot;1&quot;&gt;我是1&lt;/div&gt; &lt;div th:case=&quot;2&quot;&gt;我是2&lt;/div&gt; &lt;div th:case=&quot;3&quot;&gt;我是3&lt;/div&gt;&lt;/div&gt; 只不过没有default属性，但是我们可以使用th:case=&quot;*&quot;来代替： 1&lt;div th:case=&quot;*&quot;&gt;我是Default&lt;/div&gt; 最后我们再来看看，它如何实现遍历，假如我们有一个存放书籍信息的List需要显示，那么如何快速生成一个列表呢？我们可以使用th:each来进行遍历操作： 123456@Overrideprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; Context context = new Context(); context.setVariable(&quot;list&quot;, Arrays.asList(&quot;伞兵一号的故事&quot;, &quot;倒一杯卡布奇诺&quot;, &quot;玩游戏要啸着玩&quot;, &quot;十七张牌前的电脑屏幕&quot;)); engine.process(&quot;test.html&quot;, context, resp.getWriter());&#125; 123&lt;ul&gt; &lt;li th:each=&quot;title : $&#123;list&#125;&quot; th:text=&quot;&#x27;《&#x27;+$&#123;title&#125;+&#x27;》&#x27;&quot;&gt;&lt;/li&gt;&lt;/ul&gt; th:each中需要填写 “单个元素名称 : ${列表}”，这样，所有的列表项都可以使用遍历的单个元素，只要使用了th:each，都会被循环添加。因此最后生成的结果为： 123456&lt;ul&gt; &lt;li&gt;《伞兵一号的故事》&lt;/li&gt; &lt;li&gt;《倒一杯卡布奇诺》&lt;/li&gt; &lt;li&gt;《玩游戏要啸着玩》&lt;/li&gt; &lt;li&gt;《十七张牌前的电脑屏幕》&lt;/li&gt; &lt;/ul&gt; 我们还可以获取当前循环的迭代状态，只需要在最后添加iterStat即可，从中可以获取很多信息，比如当前的顺序： 123&lt;ul&gt; &lt;li th:each=&quot;title, iterStat : $&#123;list&#125;&quot; th:text=&quot;$&#123;iterStat.index&#125;+&#x27;.《&#x27;+$&#123;title&#125;+&#x27;》&#x27;&quot;&gt;&lt;/li&gt;&lt;/ul&gt; 状态变量在th:each属性中定义，并包含以下数据： 当前迭代索引，以0开头。这是index属性。 当前迭代索引，以1开头。这是count属性。 迭代变量中的元素总量。这是size属性。 每个迭代的迭代变量。这是current属性。 当前迭代是偶数还是奇数。这些是even/odd布尔属性。 当前迭代是否是第一个迭代。这是first布尔属性。 当前迭代是否是最后一个迭代。这是last布尔属性。 通过了解了流程控制语法，现在我们就可以很轻松地使用Thymeleaf来快速替换页面中的内容了。 Thymeleaf模板布局在某些网页中，我们会发现，整个网站的页面，除了中间部分的内容会随着我们的页面跳转而变化外，有些部分是一直保持一个状态的，比如打开小破站，我们翻动评论或是切换视频分P的时候，变化的仅仅是对应区域的内容，实际上，其他地方的内容会无论内部页面如何跳转，都不会改变。 Thymeleaf就可以轻松实现这样的操作，我们只需要将不会改变的地方设定为模板布局，并在不同的页面中插入这些模板布局，就无需每个页面都去编写同样的内容了。现在我们来创建两个页面： 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;head&quot;&gt; &lt;div&gt; &lt;h1&gt;我是标题内容，每个页面都有&lt;/h1&gt; &lt;/div&gt; &lt;hr&gt; &lt;/div&gt; &lt;div class=&quot;body&quot;&gt; &lt;ul&gt; &lt;li th:each=&quot;title, iterStat : $&#123;list&#125;&quot; th:text=&quot;$&#123;iterStat.index&#125;+&#x27;.《&#x27;+$&#123;title&#125;+&#x27;》&#x27;&quot;&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;head&quot;&gt; &lt;div&gt; &lt;h1&gt;我是标题内容，每个页面都有&lt;/h1&gt; &lt;/div&gt; &lt;hr&gt; &lt;/div&gt; &lt;div class=&quot;body&quot;&gt; &lt;div&gt;这个页面的样子是这样的&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 接着将模板引擎写成工具类的形式： 12345678910111213public class ThymeleafUtil &#123; private static final TemplateEngine engine; static &#123; engine = new TemplateEngine(); ClassLoaderTemplateResolver r = new ClassLoaderTemplateResolver(); engine.setTemplateResolver(r); &#125; public static TemplateEngine getEngine() &#123; return engine; &#125;&#125; 123456789@WebServlet(&quot;/index2&quot;)public class HelloServlet2 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; Context context = new Context(); ThymeleafUtil.getEngine().process(&quot;test2.html&quot;, context, resp.getWriter()); &#125;&#125; 现在就有两个Servlet分别对应两个页面了，但是这两个页面实际上是存在重复内容的，我们要做的就是将这些重复内容提取出来。 我们单独编写一个head.html来存放重复部分： 1234567891011&lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot; lang=&quot;en&quot;&gt;&lt;body&gt; &lt;div class=&quot;head&quot; th:fragment=&quot;head-title&quot;&gt; &lt;div&gt; &lt;h1&gt;我是标题内容，每个页面都有&lt;/h1&gt; &lt;/div&gt; &lt;hr&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 现在，我们就可以直接将页面中的内容快速替换： 123456&lt;div th:include=&quot;head.html::head-title&quot;&gt;&lt;/div&gt;&lt;div class=&quot;body&quot;&gt; &lt;ul&gt; &lt;li th:each=&quot;title, iterStat : $&#123;list&#125;&quot; th:text=&quot;$&#123;iterStat.index&#125;+&#x27;.《&#x27;+$&#123;title&#125;+&#x27;》&#x27;&quot;&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 我们可以使用th:insert和th:replace和th:include这三种方法来进行页面内容替换，那么th:insert和th:replace（和th:include，自3.0年以来不推荐）有什么区别？ th:insert最简单：它只会插入指定的片段作为标签的主体。 th:replace实际上将标签直接替换为指定的片段。 th:include和th:insert相似，但它没有插入片段，而是只插入此片段的内容。 你以为这样就完了吗？它还支持参数传递，比如我们现在希望插入二级标题，并且由我们的子页面决定： 1234567&lt;div class=&quot;head&quot; th:fragment=&quot;head-title&quot;&gt; &lt;div&gt; &lt;h1&gt;我是标题内容，每个页面都有&lt;/h1&gt; &lt;h2&gt;我是二级标题&lt;/h2&gt; &lt;/div&gt; &lt;hr&gt;&lt;/div&gt; 稍加修改，就像JS那样添加一个参数名称： 1234567&lt;div class=&quot;head&quot; th:fragment=&quot;head-title(sub)&quot;&gt; &lt;div&gt; &lt;h1&gt;我是标题内容，每个页面都有&lt;/h1&gt; &lt;h2 th:text=&quot;$&#123;sub&#125;&quot;&gt;&lt;/h2&gt; &lt;/div&gt; &lt;hr&gt;&lt;/div&gt; 现在直接在替换位置添加一个参数即可： 123456&lt;div th:include=&quot;head.html::head-title(&#x27;这个是第1个页面的二级标题&#x27;)&quot;&gt;&lt;/div&gt;&lt;div class=&quot;body&quot;&gt; &lt;ul&gt; &lt;li th:each=&quot;title, iterStat : $&#123;list&#125;&quot; th:text=&quot;$&#123;iterStat.index&#125;+&#x27;.《&#x27;+$&#123;title&#125;+&#x27;》&#x27;&quot;&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 这样，不同的页面还有着各自的二级标题。 探讨Tomcat类加载机制有关JavaWeb的内容，我们就聊到这里，在最后，我们还是来看一下Tomcat到底是如何加载和运行我们的Web应用程序的。 Tomcat服务器既然要同时运行多个Web应用程序，那么就必须要实现不同应用程序之间的隔离，也就是说，Tomcat需要分别去加载不同应用程序的类以及依赖，还必须保证应用程序之间的类无法相互访问，而传统的类加载机制无法做到这一点，同时每个应用程序都有自己的依赖，如果两个应用程序使用了同一个版本的同一个依赖，那么还有必要去重新加载吗，带着诸多问题，Tomcat服务器编写了一套自己的类加载机制。 首先我们要知道，Tomcat本身也是一个Java程序，它要做的是去动态加载我们编写的Web应用程序中的类，而要解决以上提到的一些问题，就出现了几个新的类加载器，我们来看看各个加载器的不同之处： Common ClassLoader：Tomcat最基本的类加载器，加载路径中的class可以被Tomcat容器本身以及各个Web应用程序访问。 Catalina ClassLoader：Tomcat容器私有的类加载器，加载路径中的class对于Web应用程序不可见。 Shared ClassLoader：各个Web应用程序共享的类加载器，加载路径中的class对于所有Web应用程序可见，但是对于Tomcat容器不可见。 Webapp ClassLoader：各个Web应用程序私有的类加载器，加载路径中的class只对当前Web应用程序可见，每个Web应用程序都有一个自己的类加载器，此加载器可能存在多个实例。 JasperLoader：JSP类加载器，每个JSP文件都有一个自己的类加载器，也就是说，此加载器可能会存在多个实例。 通过这样进行划分，就很好地解决了我们上面所提到的问题，但是我们发现，这样的类加载机制，破坏了JDK的双亲委派机制（在JavaSE阶段讲解过），比如Webapp ClassLoader，它只加载自己的class文件，它没有将类交给父类加载器进行加载，也就是说，我们可以随意创建和JDK同包同名的类，岂不是就出问题了？ 难道Tomcat的开发团队没有考虑到这个问题吗？ 实际上，WebAppClassLoader的加载机制是这样的：WebAppClassLoader 加载类的时候，绕开了 AppClassLoader，直接先使用 ExtClassLoader 来加载类。这样的话，如果定义了同包同名的类，就不会被加载，而如果是自己定义 的类，由于该类并不是JDK内部或是扩展类，所有不会被加载，而是再次回到WebAppClassLoader进行加载，如果还失败，再使用AppClassloader进行加载。 实战：编写图书管理系统图书管理系统需要再次迎来升级，现在，我们可以直接访问网站来操作图书，这里我们给大家提供一个前端模板直接编写，省去编写前端的时间。 本次实战使用到的框架：Servlet+Mybatis+Thymeleaf 注意在编写的时候，为了使得整体的代码简洁高效，我们严格遵守三层架构模式： 就是说，表示层只做UI，包括接受请求和相应，给模板添加上下文，以及进行页面的解析，最后响应给浏览器；业务逻辑层才是用于进行数据处理的地方，表示层需要向逻辑层索要数据，才能将数据添加到模板的上下文中；数据访问层一般就是连接数据库，包括增删改查等基本的数据库操作，业务逻辑层如果需要从数据库取数据，就需要向数据访问层请求数据。 当然，贯穿三大层次的当属实体类了，我们还需要创建对应的实体类进行数据的封装，以便于在三层架构中进行数据传递。 接下来，明确我们要实现的功能，也就是项目需求： 图书管理员的登陆和退出（只有登陆之后才能进入管理页面） 图书的列表浏览（包括书籍是否被借出的状态也要进行显示）以及图书的添加和删除 学生的列表浏览 查看所有的借阅列表，添加借阅信息 结束语首先祝贺各位顺利完成了JavaWeb相关知识的学习。 本教程创作的动力离不开各位观众姥爷们的支持，我们也会在后面为大家录制更多的Java技术栈教程，如果您喜欢本系列视频的话，直接用三连狠狠的砸向UP主吧！ 虽然我们现在已经学会了如何去编写一个网站，但是实际上，这样的开发模式已经过时（不过拿去当毕设当期末设计直接无敌好吧），我们还需要继续深入了解更加现代化的开发模式，这样我们才有机会参与到企业的项目开发当中。 希望在后续的视频中，还能看到各位的身影，完结撒花！","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"JavaWeb笔记","slug":"Java/JavaWeb笔记","permalink":"http://example.com/categories/Java/JavaWeb%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"JavaWeb笔记（一）","slug":"b79318accafa44dfaabad60dbbe8de4c","date":"2023-01-18T02:27:08.000Z","updated":"2023-01-19T16:03:14.640Z","comments":true,"path":"2023/01/18/b79318accafa44dfaabad60dbbe8de4c/","link":"","permalink":"http://example.com/2023/01/18/b79318accafa44dfaabad60dbbe8de4c/","excerpt":"","text":"Java网络编程在JavaSE阶段，我们学习了I&#x2F;O流，既然I&#x2F;O流如此强大，那么能否跨越不同的主机进行I&#x2F;O操作呢？这就要提到Java的网络编程了。 **注意：**本章会涉及到计算机网络相关内容（只会讲解大致内容，不会完整的讲解计算机网络知识） 计算机网络基础利用通信线路和通信设备，将地理位置不同的、功能独立的多台计算机互连起来，以功能完善的网络软件来实现资源共享和信息传递，就构成了计算机网络系统。 比如我们家里的路由器，通过将我们的设备（手机、平板、电脑、电视剧）连接到路由器，来实现对互联网的访问。实际上，我们的路由器连接在互联网上，而我们的设备又连接了路由器，这样我们的设备就可以通过路由器访问到互联网了。通过网络，我们可以直接访问互联网上的另一台主机，比如我们要把QQ的消息发送给我们的朋友，或是通过远程桌面管理来操作另一台电脑，也可以是连接本地网络上的打印机。 既然我们可以通过网络访问其他计算机，那么如何区别不同的计算机呢？通过IP地址，我们就可以区分不同的计算机了： 每一台电脑在同一个网络上都有一个自己的IP地址，用于区别于其他的电脑，我们可以通过对方主机的IP地址对其进行访问。那么我手机连接的移动流量，能访问到连接家里路由器的电脑吗？（不能，因为他们不属于同一个网络） 而我们的电脑上可能运行着大量的程序，每一个程序可能都需要通过网络来访问其他计算机，那这时该如何区分呢？我们可以通过端口号来区分： 因此，我们一般看到的是这样的：192.168.0.11:8080，通过IP:端口的形式来访问目标主机上的一个应用程序服务。注意端口号只能是0-65535之间的值！ IP地址分为IPv4和IPv6，IPv4类似于192.168.0.11，我们上面提到的例子都是使用的IPv4，它一共有四组数字，每组数字占8个bit位，IPv4地址0.0.0.0表示为2进制就是：00000000.00000000.00000000.00000000，共32个bit，最大为255.255.255.255，实际上，IPv4能够表示的所有地址，早就已经被用完了。IPv6能够保存128个bit位，因此它也可以表示更多的IP地址，一个IPv6地址看起来像这样：1030::C9B4:FF12:48AA:1A2B，目前也正在向IPv6的阶段过度。 TCP和UDP是两种不同的传输层协议： TCP：当一台计算机想要与另一台计算机通讯时，两台计算机之间的通信需要畅通且可靠（会进行三次握手，断开也会进行四次挥手），这样才能保证正确收发数据，因此TCP更适合一些可靠的数据传输场景。 UDP：它是一种无连接协议，数据想发就发，而且不会建立可靠传输，也就是说传输过程中有可能会导致部分数据丢失，但是它比TCP传输更加简单高效，适合视频直播之类的。 了解Socket技术通过Socket技术（它是计算机之间进行通信的一种约定或一种方式），我们就可以实现两台计算机之间的通信，Socket也被翻译为套接字，是操作系统底层提供的一项通信技术，它支持TCP和UDP。而Java就对socket底层支持进行了一套完整的封装，我们可以通过Java来实现Socket通信。 要实现Socket通信，我们必须创建一个数据发送者和一个数据接收者，也就是客户端和服务端，我们需要提前启动服务端，来等待客户端的连接，而客户端只需要随时启动去连接服务端即可！ 12345678910//服务端public static void main(String[] args) &#123; try(ServerSocket server = new ServerSocket(8080))&#123; //将服务端创建在端口8080上 System.out.println(&quot;正在等待客户端连接...&quot;); Socket socket = server.accept(); //当没有客户端连接时，线程会阻塞，直到有客户端连接为止 System.out.println(&quot;客户端已连接，IP地址为：&quot;+socket.getInetAddress().getHostAddress()); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125;&#125; 123456789//客户端public static void main(String[] args) &#123; try (Socket socket = new Socket(&quot;localhost&quot;, 8080))&#123; System.out.println(&quot;已连接到服务端！&quot;); &#125;catch (IOException e)&#123; System.out.println(&quot;服务端连接失败！&quot;); e.printStackTrace(); &#125;&#125; 实际上它就是一个TCP连接的建立过程： 一旦TCP连接建立，服务端和客户端之间就可以相互发送数据，直到客户端主动关闭连接。当然，服务端不仅仅只可以让一个客户端进行连接，我们可以尝试让服务端一直运行来不断接受客户端的连接： 1234567891011public static void main(String[] args) &#123; try(ServerSocket server = new ServerSocket(8080))&#123; //将服务端创建在端口8080上 System.out.println(&quot;正在等待客户端连接...&quot;); while (true)&#123; //无限循环等待客户端连接 Socket socket = server.accept(); System.out.println(&quot;客户端已连接，IP地址为：&quot;+socket.getInetAddress().getHostAddress()); &#125; &#125;catch (IOException e)&#123; e.printStackTrace(); &#125;&#125; 现在我们就可以多次去连接此服务端了。 使用Socket进行数据传输通过Socket对象，我们就可以获取到对应的I&#x2F;O流进行网络数据传输： 12345678910111213141516171819public static void main(String[] args) &#123; try (Socket socket = new Socket(&quot;localhost&quot;, 8080); Scanner scanner = new Scanner(System.in))&#123; System.out.println(&quot;已连接到服务端！&quot;); OutputStream stream = socket.getOutputStream(); OutputStreamWriter writer = new OutputStreamWriter(stream); //通过转换流来帮助我们快速写入内容 System.out.println(&quot;请输入要发送给服务端的内容：&quot;); String text = scanner.nextLine(); writer.write(text+&#x27;\\n&#x27;); //因为对方是readLine()这里加个换行符 writer.flush(); System.out.println(&quot;数据已发送：&quot;+text); &#125;catch (IOException e)&#123; System.out.println(&quot;服务端连接失败！&quot;); e.printStackTrace(); &#125;finally &#123; System.out.println(&quot;客户端断开连接！&quot;); &#125; &#125;&#125; 12345678910111213public static void main(String[] args) &#123; try(ServerSocket server = new ServerSocket(8080))&#123; //将服务端创建在端口8080上 System.out.println(&quot;正在等待客户端连接...&quot;); Socket socket = server.accept(); System.out.println(&quot;客户端已连接，IP地址为：&quot;+socket.getInetAddress().getHostAddress()); BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); //通过 System.out.print(&quot;接收到客户端数据：&quot;); System.out.println(reader.readLine()); socket.close(); //和服务端TCP连接完成之后，记得关闭socket &#125;catch (IOException e)&#123; e.printStackTrace(); &#125;&#125; 同理，既然服务端可以读取客户端的内容，客户端也可以在发送后等待服务端给予响应： 1234567891011121314151617181920public static void main(String[] args) &#123; try (Socket socket = new Socket(&quot;localhost&quot;, 8080); Scanner scanner = new Scanner(System.in))&#123; System.out.println(&quot;已连接到服务端！&quot;); OutputStream stream = socket.getOutputStream(); OutputStreamWriter writer = new OutputStreamWriter(stream); //通过转换流来帮助我们快速写入内容 System.out.println(&quot;请输入要发送给服务端的内容：&quot;); String text = scanner.nextLine(); writer.write(text+&#x27;\\n&#x27;); //因为对方是readLine()这里加个换行符 writer.flush(); System.out.println(&quot;数据已发送：&quot;+text); BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); System.out.println(&quot;收到服务器返回：&quot;+reader.readLine()); &#125;catch (IOException e)&#123; System.out.println(&quot;服务端连接失败！&quot;); e.printStackTrace(); &#125;finally &#123; System.out.println(&quot;客户端断开连接！&quot;); &#125;&#125; 123456789101112131415public static void main(String[] args) &#123; try(ServerSocket server = new ServerSocket(8080))&#123; //将服务端创建在端口8080上 System.out.println(&quot;正在等待客户端连接...&quot;); Socket socket = server.accept(); System.out.println(&quot;客户端已连接，IP地址为：&quot;+socket.getInetAddress().getHostAddress()); BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); //通过 System.out.print(&quot;接收到客户端数据：&quot;); System.out.println(reader.readLine()); OutputStreamWriter writer = new OutputStreamWriter(socket.getOutputStream()); writer.write(&quot;已收到！&quot;); writer.flush(); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125;&#125; 我们可以手动关闭单向的流： 12socket.shutdownOutput(); //关闭输出方向的流socket.shutdownInput(); //关闭输入方向的流 如果我们不希望服务端等待太长的时间，我们可以通过调用setSoTimeout()方法来设定IO超时时间： 1socket.setSoTimeout(3000); 当超过设定时间都依然没有收到客户端或是服务端的数据时，会抛出异常： 12345678910111213java.net.SocketTimeoutException: Read timed out at java.net.SocketInputStream.socketRead0(Native Method) at java.net.SocketInputStream.socketRead(SocketInputStream.java:116) at java.net.SocketInputStream.read(SocketInputStream.java:171) at java.net.SocketInputStream.read(SocketInputStream.java:141) at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:284) at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:326) at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:178) at java.io.InputStreamReader.read(InputStreamReader.java:184) at java.io.BufferedReader.fill(BufferedReader.java:161) at java.io.BufferedReader.readLine(BufferedReader.java:324) at java.io.BufferedReader.readLine(BufferedReader.java:389) at com.test.Main.main(Main.java:41) 我们之前使用的都是通过构造方法直接连接服务端，那么是否可以等到我们想要的时候再去连接呢？ 123try (Socket socket = new Socket(); //调用无参构造不会自动连接 Scanner scanner = new Scanner(System.in))&#123; socket.connect(new InetSocketAddress(&quot;localhost&quot;, 8080), 1000); //手动调用connect方法进行连接 如果连接的双方发生意外而通知不到对方，导致一方还持有连接，这样就会占用资源，因此我们可以使用setKeepAlive()方法来防止此类情况发生： 1socket.setKeepAlive(true); 当客户端连接后，如果设置了keeplive为 true，当对方没有发送任何数据过来，超过一个时间(看系统内核参数配置)，那么我们这边会发送一个ack探测包发到对方，探测双方的TCP&#x2F;IP连接是否有效。 TCP在传输过程中，实际上会有一个缓冲区用于数据的发送和接收： 此缓冲区大小为：8192，我们可以手动调整其大小来优化传输效率： 12socket.setReceiveBufferSize(25565); //TCP接收缓冲区socket.setSendBufferSize(25565); //TCP发送缓冲区 使用Socket传输文件既然Socket为我们提供了IO流便于数据传输，那么我们就可以轻松地实现文件传输了。 使用浏览器访问Socket服务器在了解了如何使用Socket传输文件后，我们来看看，浏览器是如何向服务器发起请求的： 12345678910111213141516public static void main(String[] args) &#123; try(ServerSocket server = new ServerSocket(8080))&#123; //将服务端创建在端口8080上 System.out.println(&quot;正在等待客户端连接...&quot;); Socket socket = server.accept(); System.out.println(&quot;客户端已连接，IP地址为：&quot;+socket.getInetAddress().getHostAddress()); InputStream in = socket.getInputStream(); //通过 System.out.println(&quot;接收到客户端数据：&quot;); while (true)&#123; int i = in.read(); if(i == -1) break; System.out.print((char) i); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; 我们现在打开浏览器，输入http://localhost:8080或是http://127.0.0.1:8080/，来连接我们本地开放的服务器。 我们发现浏览器是无法打开这个链接的，但是我们服务端却收到了不少的信息： 12345678910111213141516GET / HTTP/1.1Host: 127.0.0.1:8080Connection: keep-aliveCache-Control: max-age=0sec-ch-ua: &quot;Chromium&quot;;v=&quot;94&quot;, &quot;Google Chrome&quot;;v=&quot;94&quot;, &quot;;Not A Brand&quot;;v=&quot;99&quot;sec-ch-ua-mobile: ?0sec-ch-ua-platform: &quot;macOS&quot;Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.81 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Sec-Fetch-Site: noneSec-Fetch-Mode: navigateSec-Fetch-User: ?1Sec-Fetch-Dest: documentAccept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9,und;q=0.8,en;q=0.7 实际上这些内容都是Http协议规定的请求头内容。HTTP是一种应用层协议，全称为超文本传输协议，它本质也是基于TCP协议进行数据传输，因此我们的服务端能够读取HTTP请求。但是Http协议并不会保持长连接，在得到我们响应的数据后会立即关闭TCP连接。 既然使用的是Http连接，如果我们的服务器要支持响应HTTP请求，那么就需要按照HTTP协议的规则，返回一个规范的响应文本，首先是响应头，它至少要包含一个响应码： 1HTTP/1.1 200 Accpeted 然后就是响应内容（注意一定要换行再写），我们尝试来编写一下支持HTTP协议的响应内容： 1234567891011121314151617public static void main(String[] args) &#123; try(ServerSocket server = new ServerSocket(8080))&#123; //将服务端创建在端口8080上 System.out.println(&quot;正在等待客户端连接...&quot;); Socket socket = server.accept(); System.out.println(&quot;客户端已连接，IP地址为：&quot;+socket.getInetAddress().getHostAddress()); BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); //通过 System.out.println(&quot;接收到客户端数据：&quot;); while (reader.ready()) System.out.println(reader.readLine()); //ready是判断当前流中是否还有可读内容 OutputStreamWriter writer = new OutputStreamWriter(socket.getOutputStream()); writer.write(&quot;HTTP/1.1 200 Accepted\\r\\n&quot;); //200是响应码，Http协议规定200为接受请求，400为错误的请求，404为找不到此资源（不止这些，还有很多） writer.write(&quot;\\r\\n&quot;); //在请求头写完之后还要进行一次换行，然后写入我们的响应实体（会在浏览器上展示的内容） writer.write(&quot;lbwnb!&quot;); writer.flush(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;&#125; 我们可以打开浏览器的开发者模式（这里推荐使用Chrome&#x2F;Edge浏览器，按下F12即可打开），我们来观察一下浏览器的实际请求过程。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"JavaWeb笔记","slug":"Java/JavaWeb笔记","permalink":"http://example.com/categories/Java/JavaWeb%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"javaweb","slug":"javaweb","permalink":"http://example.com/tags/javaweb/"}]},{"title":"JavaWeb笔记（三）","slug":"f795be55936d42ddafd17995abae6aa8","date":"2023-01-18T02:27:08.000Z","updated":"2023-01-19T16:03:14.715Z","comments":true,"path":"2023/01/18/f795be55936d42ddafd17995abae6aa8/","link":"","permalink":"http://example.com/2023/01/18/f795be55936d42ddafd17995abae6aa8/","excerpt":"","text":"Java与数据库通过Java如何去使用数据库来帮助我们存储数据呢，这将是本章节讨论的重点。 初识JDBCJDBC是什么？JDBC英文名为：Java Data Base Connectivity(Java数据库连接)，官方解释它是Java编程语言和广泛的数据库之间独立于数据库的连接标准的Java API，根本上说JDBC是一种规范，它提供的接口，一套完整的，允许便捷式访问底层数据库。可以用JAVA来写不同类型的可执行文件：JAVA应用程序、JAVA Applets、Java Servlet、JSP等，不同的可执行文件都能通过JDBC访问数据库，又兼备存储的优势。简单说它就是Java与数据库的连接的桥梁或者插件，用Java代码就能操作数据库的增删改查、存储过程、事务等。 我们可以发现，JDK自带了一个java.sql包，而这里面就定义了大量的接口，不同类型的数据库，都可以通过实现此接口，编写适用于自己数据库的实现类。而不同的数据库厂商实现的这套标准，我们称为数据库驱动。 准备工作那么我们首先来进行一些准备工作，以便开始JDBC的学习： 将idea连接到我们的数据库，以便以后调试。 将mysql驱动jar依赖导入到项目中（推荐6.0版本以上，这里用到是8.0） 向Jetbrians申请一个学生&#x2F;教师授权，用于激活idea终极版（进行JavaWeb开发需要用到，一般申请需要3-7天时间审核）不是大学生的话…emmm…懂的都懂。 教育授权申请地址：https://www.jetbrains.com/shop/eform/students 一个Java程序并不是一个人的战斗，我们可以在别人开发的基础上继续向上开发，其他的开发者可以将自己编写的Java代码打包为jar，我们只需要导入这个jar作为依赖，即可直接使用别人的代码，就像我们直接去使用JDK提供的类一样。 使用JDBC连接数据库**注意：**6.0版本以上，不用手动加载驱动，我们直接使用即可！ 1234567891011121314//1. 通过DriverManager来获得数据库连接try (Connection connection = DriverManager.getConnection(&quot;连接URL&quot;,&quot;用户名&quot;,&quot;密码&quot;); //2. 创建一个用于执行SQL的Statement对象 Statement statement = connection.createStatement())&#123; //注意前两步都放在try()中，因为在最后需要释放资源！ //3. 执行SQL语句，并得到结果集 ResultSet set = statement.executeQuery(&quot;select * from 表名&quot;); //4. 查看结果 while (set.next())&#123; ... &#125;&#125;catch (SQLException e)&#123; e.printStackTrace();&#125;//5. 释放资源，try-with-resource语法会自动帮助我们close 其中，连接的URL如果记不住格式，我们可以打开idea的数据库连接配置，复制一份即可。（其实idea本质也是使用的JDBC，整个idea程序都是由Java编写的，实际上idea就是一个Java程序） 了解DriverManager我们首先来了解一下DriverManager是什么东西，它其实就是管理我们的数据库驱动的： 123456789101112131415public static synchronized void registerDriver(java.sql.Driver driver, DriverAction da) throws SQLException &#123; /* Register the driver if it has not already been added to our list */ if(driver != null) &#123; registeredDrivers.addIfAbsent(new DriverInfo(driver, da)); //在刚启动时，mysql实现的驱动会被加载，我们可以断点调试一下。 &#125; else &#123; // This is for compatibility with the original DriverManager throw new NullPointerException(); &#125; println(&quot;registerDriver: &quot; + driver);&#125; 我们可以通过调用getConnection()来进行数据库的链接： 1234567891011121314@CallerSensitivepublic static Connection getConnection(String url, String user, String password) throws SQLException &#123; java.util.Properties info = new java.util.Properties(); if (user != null) &#123; info.put(&quot;user&quot;, user); &#125; if (password != null) &#123; info.put(&quot;password&quot;, password); &#125; return (getConnection(url, info, Reflection.getCallerClass())); //内部有实现&#125; 我们可以手动为驱动管理器添加一个日志打印： 123static &#123; DriverManager.setLogWriter(new PrintWriter(System.out)); //这里直接设定为控制台输出&#125; 现在我们执行的数据库操作日志会在控制台实时打印。 了解ConnectionConnection是数据库的连接对象，可以通过连接对象来创建一个Statement用于执行SQL语句： 1Statement createStatement() throws SQLException; 我们发现除了普通的Statement，还存在PreparedStatement： 12PreparedStatement prepareStatement(String sql) throws SQLException; 在后面我们会详细介绍PreparedStatement的使用，它能够有效地预防SQL注入式攻击。 它还支持事务的处理，也放到后面来详细进行讲解。 了解Statement我们发现，我们之前使用了executeQuery()方法来执行select语句，此方法返回给我们一个ResultSet对象，查询得到的数据，就存放在ResultSet中！ Statement除了执行这样的DQL语句外，我们还可以使用executeUpdate()方法来执行一个DML或是DDL语句，它会返回一个int类型，表示执行后受影响的行数，可以通过它来判断DML语句是否执行成功。 也可以通过excute()来执行任意的SQL语句，它会返回一个boolean来表示执行结果是一个ResultSet还是一个int，我们可以通过使用getResultSet()或是getUpdateCount()来获取。 执行DML操作我们通过几个例子来向数据库中插入数据。 执行DQL操作执行DQL操作会返回一个ResultSet对象，我们来看看如何从ResultSet中去获取数据： 1234//首先要明确，select返回的数据类似于一个excel表格while (set.next())&#123; //每调用一次next()就会向下移动一行，首次调用会移动到第一行&#125; 我们在移动行数后，就可以通过set中提供的方法，来获取每一列的数据。 执行批处理操作当我们要执行很多条语句时，可以不用一次一次地提交，而是一口气全部交给数据库处理，这样会节省很多的时间。 123456789101112public static void main(String[] args) throws ClassNotFoundException &#123; try (Connection connection = DriverManager.getConnection(); Statement statement = connection.createStatement())&#123; statement.addBatch(&quot;insert into user values (&#x27;f&#x27;, 1234)&quot;); statement.addBatch(&quot;insert into user values (&#x27;e&#x27;, 1234)&quot;); //添加每一条批处理语句 statement.executeBatch(); //一起执行 &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125;&#125; 将查询结果映射为对象既然我们现在可以从数据库中获取数据了，那么现在就可以将这些数据转换为一个类来进行操作，首先定义我们的实体类： 123456789101112131415public class Student &#123; Integer sid; String name; String sex; public Student(Integer sid, String name, String sex) &#123; this.sid = sid; this.name = name; this.sex = sex; &#125; public void say()&#123; System.out.println(&quot;我叫：&quot;+name+&quot;，学号为：&quot;+sid+&quot;，我的性别是：&quot;+sex); &#125;&#125; 现在我们来进行一个转换： 1234while (set.next())&#123; Student student = new Student(set.getInt(1), set.getString(2), set.getString(3)); student.say();&#125; **注意：**列的下标是从1开始的。 我们也可以利用反射机制来将查询结果映射为对象，使用反射的好处是，无论什么类型都可以通过我们的方法来进行实体类型映射： 12345678910111213141516private static &lt;T&gt; T convert(ResultSet set, Class&lt;T&gt; clazz)&#123; try &#123; Constructor&lt;T&gt; constructor = clazz.getConstructor(clazz.getConstructors()[0].getParameterTypes()); //默认获取第一个构造方法 Class&lt;?&gt;[] param = constructor.getParameterTypes(); //获取参数列表 Object[] object = new Object[param.length]; //存放参数 for (int i = 0; i &lt; param.length; i++) &#123; //是从1开始的 object[i] = set.getObject(i+1); if(object[i].getClass() != param[i]) throw new SQLException(&quot;错误的类型转换：&quot;+object[i].getClass()+&quot; -&gt; &quot;+param[i]); &#125; return constructor.newInstance(object); &#125; catch (ReflectiveOperationException | SQLException e) &#123; e.printStackTrace(); return null; &#125;&#125; 现在我们就可以通过我们的方法来将查询结果转换为一个对象了： 1234while (set.next())&#123; Student student = convert(set, Student.class); if(student != null) student.say();&#125; 实际上，在后面我们会学习Mybatis框架，它对JDBC进行了深层次的封装，而它就进行类似上面反射的操作来便于我们对数据库数据与实体类的转换。 实现登陆与SQL注入攻击在使用之前，我们先来看看如果我们想模拟登陆一个用户，我们该怎么去写： 1234567891011try (Connection connection = DriverManager.getConnection(&quot;URL&quot;,&quot;用户名&quot;,&quot;密码&quot;); Statement statement = connection.createStatement(); Scanner scanner = new Scanner(System.in))&#123; ResultSet res = statement.executeQuery(&quot;select * from user where username=&#x27;&quot;+scanner.nextLine()+&quot;&#x27;and pwd=&#x27;&quot;+scanner.nextLine()+&quot;&#x27;;&quot;); while (res.next())&#123; String username = res.getString(1); System.out.println(username+&quot; 登陆成功！&quot;); &#125;&#125;catch (SQLException e)&#123; e.printStackTrace();&#125; 用户可以通过自己输入用户名和密码来登陆，乍一看好像没啥问题，那如果我输入的是以下内容呢： 123Test1111&#x27; or 1=1; -- # Test 登陆成功！ 1&#x3D;1一定是true，那么我们原本的SQL语句会变为： 1select * from user where username=&#x27;Test&#x27; and pwd=&#x27;1111&#x27; or 1=1; -- &#x27; 我们发现，如果允许这样的数据插入，那么我们原有的SQL语句结构就遭到了破坏，使得用户能够随意登陆别人的账号。因此我们可能需要限制用户的输入来防止用户输入一些SQL语句关键字，但是关键字非常多，这并不是解决问题的最好办法。 使用PreparedStatement我们发现，如果单纯地使用Statement来执行SQL命令，会存在严重的SQL注入攻击漏洞！而这种问题，我们可以使用PreparedStatement来解决： 1234567891011121314151617public static void main(String[] args) throws ClassNotFoundException &#123; try (Connection connection = DriverManager.getConnection(&quot;URL&quot;,&quot;用户名&quot;,&quot;密码&quot;); PreparedStatement statement = connection.prepareStatement(&quot;select * from user where username= ? and pwd=?;&quot;); Scanner scanner = new Scanner(System.in))&#123; statement.setString(1, scanner.nextLine()); statement.setString(2, scanner.nextLine()); System.out.println(statement); //打印查看一下最终执行的 ResultSet res = statement.executeQuery(); while (res.next())&#123; String username = res.getString(1); System.out.println(username+&quot; 登陆成功！&quot;); &#125; &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125;&#125; 我们发现，我们需要提前给到PreparedStatement一个SQL语句，并且使用?作为占位符，它会预编译一个SQL语句，通过直接将我们的内容进行替换的方式来填写数据。使用这种方式，我们之前的例子就失效了！我们来看看实际执行的SQL语句是什么： com.mysql.cj.jdbc.ClientPreparedStatement: select * from user where username= &#39;Test&#39; and pwd=&#39;123456&#39;&#39; or 1=1; -- &#39;; 我们发现，我们输入的参数一旦出现&#39;时，会被变为转义形式\\&#39;，而最外层有一个真正的&#39;来将我们输入的内容进行包裹，因此它能够有效地防止SQL注入攻击！ 管理事务JDBC默认的事务处理行为是自动提交，所以前面我们执行一个SQL语句就会被直接提交（相当于没有启动事务），所以JDBC需要进行事务管理时，首先要通过Connection对象调用setAutoCommit(false) 方法, 将SQL语句的提交（commit）由驱动程序转交给应用程序负责。 12345con.setAutoCommit(); //关闭自动提交后相当于开启事务。// SQL语句// SQL语句// SQL语句con.commit();或 con.rollback(); 一旦关闭自动提交，那么现在执行所有的操作如果在最后不进行commit()来提交事务的话，那么所有的操作都会丢失，只有提交之后，所有的操作才会被保存！也可以使用rollback()来手动回滚之前的全部操作！ 1234567891011121314public static void main(String[] args) throws ClassNotFoundException &#123; try (Connection connection = DriverManager.getConnection(&quot;URL&quot;,&quot;用户名&quot;,&quot;密码&quot;); Statement statement = connection.createStatement())&#123; connection.setAutoCommit(false); //关闭自动提交，现在将变为我们手动提交 statement.executeUpdate(&quot;insert into user values (&#x27;a&#x27;, 1234)&quot;); statement.executeUpdate(&quot;insert into user values (&#x27;b&#x27;, 1234)&quot;); statement.executeUpdate(&quot;insert into user values (&#x27;c&#x27;, 1234)&quot;); connection.commit(); //如果前面任何操作出现异常，将不会执行commit()，之前的操作也就不会生效 &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125;&#125; 我们来接着尝试一下使用回滚操作： 123456789101112131415161718public static void main(String[] args) throws ClassNotFoundException &#123; try (Connection connection = DriverManager.getConnection(&quot;URL&quot;,&quot;用户名&quot;,&quot;密码&quot;); Statement statement = connection.createStatement())&#123; connection.setAutoCommit(false); //关闭自动提交，现在将变为我们手动提交 statement.executeUpdate(&quot;insert into user values (&#x27;a&#x27;, 1234)&quot;); statement.executeUpdate(&quot;insert into user values (&#x27;b&#x27;, 1234)&quot;); connection.rollback(); //回滚，撤销前面全部操作 statement.executeUpdate(&quot;insert into user values (&#x27;c&#x27;, 1234)&quot;); connection.commit(); //提交事务（注意，回滚之前的内容都没了） &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125;&#125; 同样的，我们也可以去创建一个回滚点来实现定点回滚： 1234567891011121314151617181920public static void main(String[] args) throws ClassNotFoundException &#123; try (Connection connection = DriverManager.getConnection(&quot;URL&quot;,&quot;用户名&quot;,&quot;密码&quot;); Statement statement = connection.createStatement())&#123; connection.setAutoCommit(false); //关闭自动提交，现在将变为我们手动提交 statement.executeUpdate(&quot;insert into user values (&#x27;a&#x27;, 1234)&quot;); Savepoint savepoint = connection.setSavepoint(); //创建回滚点 statement.executeUpdate(&quot;insert into user values (&#x27;b&#x27;, 1234)&quot;); connection.rollback(savepoint); //回滚到回滚点，撤销前面全部操作 statement.executeUpdate(&quot;insert into user values (&#x27;c&#x27;, 1234)&quot;); connection.commit(); //提交事务（注意，回滚之前的内容都没了） &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125;&#125; 通过开启事务，我们就可以更加谨慎地进行一些操作了，如果我们想从事务模式切换为原有的自动提交模式，我们可以直接将其设置回去： 12345678910111213public static void main(String[] args) throws ClassNotFoundException &#123; try (Connection connection = DriverManager.getConnection(&quot;URL&quot;,&quot;用户名&quot;,&quot;密码&quot;); Statement statement = connection.createStatement())&#123; connection.setAutoCommit(false); //关闭自动提交，现在将变为我们手动提交 statement.executeUpdate(&quot;insert into user values (&#x27;a&#x27;, 1234)&quot;); connection.setAutoCommit(true); //重新开启自动提交，开启时把之前的事务模式下的内容给提交了 statement.executeUpdate(&quot;insert into user values (&#x27;d&#x27;, 1234)&quot;); //没有commit也成功了！ &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125; 通过学习JDBC，我们现在就可以通过Java来访问和操作我们的数据库了！为了更好地衔接，我们还会接着讲解主流持久层框架——Mybatis，加深JDBC的记忆。 使用Lombok我们发现，在以往编写项目时，尤其是在类进行类内部成员字段封装时，需要编写大量的get&#x2F;set方法，这不仅使得我们类定义中充满了get和set方法，同时如果字段名称发生改变，又要挨个进行修改，甚至当字段变得很多时，构造方法的编写会非常麻烦！ 通过使用Lombok（小辣椒）就可以解决这样的问题！ 我们来看看，使用原生方式和小辣椒方式编写类的区别，首先是传统方式： 1234567891011121314151617181920212223242526272829303132333435public class Student &#123; private Integer sid; private String name; private String sex; public Student(Integer sid, String name, String sex) &#123; this.sid = sid; this.name = name; this.sex = sex; &#125; public Integer getSid() &#123; //长！ return sid; &#125; public void setSid(Integer sid) &#123; //到！ this.sid = sid; &#125; public String getName() &#123; //爆！ return name; &#125; public void setName(String name) &#123; //炸！ this.name = name; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125;&#125; 而使用Lombok之后： 12345678@Getter@Setter@AllArgsConstructorpublic class Student &#123; private Integer sid; private String name; private String sex;&#125; 我们发现，使用Lombok之后，只需要添加几个注解，就能够解决掉我们之前长长的一串代码！ 配置Lombok 首先我们需要导入Lombok的jar依赖，和jdbc依赖是一样的，放在项目目录下直接导入就行了。可以在这里进行下载：https://projectlombok.org/download 然后我们要安装一下Lombok插件，由于IDEA默认都安装了Lombok的插件，因此直接导入依赖后就可以使用了。 重启IDEA Lombok是一种插件化注解API，是通过添加注解来实现的，然后在javac进行编译的时候，进行处理。 Java的编译过程可以分成三个阶段： 所有源文件会被解析成语法树。 调用注解处理器。如果注解处理器产生了新的源文件，新文件也要进行编译。 最后，语法树会被分析并转化成类文件。 实际上在上述的第二阶段，会执行*lombok.core.AnnotationProcessor*，它所做的工作就是我们上面所说的，修改语法树。 使用Lombok我们通过实战来演示一下Lombok的实用注解： 我们通过添加@Getter和@Setter来为当前类的所有字段生成get&#x2F;set方法，他们可以添加到类或是字段上，注意静态字段不会生成，final字段无法生成set方法。 我们还可以使用@Accessors来控制生成Getter和Setter的样式。 我们通过添加@ToString来为当前类生成预设的toString方法。 我们可以通过添加@EqualsAndHashCode来快速生成比较和哈希值方法。 我们可以通过添加@AllArgsConstructor和@NoArgsConstructor来快速生成全参构造和无参构造。 我们可以添加@RequiredArgsConstructor来快速生成参数只包含final或被标记为@NonNull的成员字段。 使用@Data能代表@Setter、@Getter、@RequiredArgsConstructor、@ToString、@EqualsAndHashCode全部注解。 一旦使用@Data就不建议此类有继承关系，因为equal方法可能不符合预期结果（尤其是仅比较子类属性）。 使用@Value与@Data类似，但是并不会生成setter并且成员属性都是final的。 使用@SneakyThrows来自动生成try-catch代码块。 使用@Cleanup作用与局部变量，在最后自动调用其close()方法（可以自由更换） 使用@Builder来快速生成建造者模式。 通过使用@Builder.Default来指定默认值。 通过使用@Builder.ObtainVia来指定默认值的获取方式。 认识Mybatis在前面JDBC的学习中，虽然我们能够通过JDBC来连接和操作数据库，但是哪怕只是完成一个SQL语句的执行，都需要编写大量的代码，更不用说如果我还需要进行实体类映射，将数据转换为我们可以直接操作的实体类型，JDBC很方便，但是还不够方便，我们需要一种更加简洁高效的方式来和数据库进行交互。 **再次强调：**学习厉害的框架或是厉害的技术，并不是为了一定要去使用它，而是它们能够使得我们在不同的开发场景下，合理地使用这些技术，以灵活地应对需要解决的问题。 MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。 我们依然使用传统的jar依赖方式，从最原始开始讲起，不使用Maven，有关Maven内容我们会在后面统一讲解！全程围绕官方文档讲解！ 这一块内容很多很杂，再次强调要多实践！ XML语言概述在开始介绍Mybatis之前，XML语言发明最初是用于数据的存储和传输，它可以长这样： 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;outer&gt; &lt;name&gt;阿伟&lt;/name&gt; &lt;desc&gt;怎么又在玩电动啊&lt;/desc&gt; &lt;inner type=&quot;1&quot;&gt; &lt;age&gt;10&lt;/age&gt; &lt;sex&gt;男&lt;/sex&gt; &lt;/inner&gt;&lt;/outer&gt; 如果你学习过前端知识，你会发现它和HTML几乎长得一模一样！但是请注意，虽然它们长得差不多，但是他们的意义却不同，HTML主要用于通过编排来展示数据，而XML主要是存放数据，它更像是一个配置文件！当然，浏览器也是可以直接打开XML文件的。 一个XML文件存在以下的格式规范： 必须存在一个根节点，将所有的子标签全部包含。 可以但不必须包含一个头部声明（主要是可以设定编码格式） 所有的标签必须成对出现，可以嵌套但不能交叉嵌套 区分大小写。 标签中可以存在属性，比如上面的type=&quot;1&quot;就是inner标签的一个属性，属性的值由单引号或双引号包括。 XML文件也可以使用注释： 12&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!-- 注释内容 --&gt; 通过IDEA我们可以使用Ctrl+/来快速添加注释文本（不仅仅适用于XML，还支持很多种类型的文件） 那如果我们的内容中出现了&lt;或是&gt;字符，那该怎么办呢？我们就可以使用XML的转义字符来代替： 如果嫌一个一个改太麻烦，也可以使用CD来快速创建不解析区域： 123&lt;test&gt; &lt;name&gt;&lt;![CDATA[我看你&lt;&gt;&lt;&gt;&lt;&gt;是一点都不懂哦&gt;&gt;&gt;]]&gt;&lt;/name&gt;&lt;/test&gt; 那么，我们现在了解了XML文件的定义，现在该如何去解析一个XML文件呢？比如我们希望将定义好的XML文件读取到Java程序中，这时该怎么做呢？ JDK为我们内置了一个叫做org.w3c的XML解析库，我们来看看如何使用它来进行XML文件内容解析： 12345678910111213141516171819202122// 创建DocumentBuilderFactory对象DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();// 创建DocumentBuilder对象try &#123; DocumentBuilder builder = factory.newDocumentBuilder(); Document d = builder.parse(&quot;file:mappers/test.xml&quot;); // 每一个标签都作为一个节点 NodeList nodeList = d.getElementsByTagName(&quot;test&quot;); // 可能有很多个名字为test的标签 Node rootNode = nodeList.item(0); // 获取首个 NodeList childNodes = rootNode.getChildNodes(); // 一个节点下可能会有很多个节点，比如根节点下就囊括了所有的节点 //节点可以是一个带有内容的标签（它内部就还有子节点），也可以是一段文本内容 for (int i = 0; i &lt; childNodes.getLength(); i++) &#123; Node child = childNodes.item(i); if(child.getNodeType() == Node.ELEMENT_NODE) //过滤换行符之类的内容，因为它们都被认为是一个文本节点 System.out.println(child.getNodeName() + &quot;：&quot; +child.getFirstChild().getNodeValue()); // 输出节点名称，也就是标签名称，以及标签内部的文本（内部的内容都是子节点，所以要获取内部的节点） &#125;&#125; catch (Exception e) &#123; e.printStackTrace();&#125; 当然，学习和使用XML只是为了更好地去认识Mybatis的工作原理，以及如何使用XML来作为Mybatis的配置文件，这是在开始之前必须要掌握的内容（使用Java读取XML内容不要求掌握，但是需要知道Mybatis就是通过这种方式来读取配置文件的） 不仅仅是Mybatis，包括后面的Spring等众多框架都会用到XML来作为框架的配置文件！ 初次使用Mybatis那么我们首先来感受一下Mybatis给我们带来的便捷，就从搭建环境开始，中文文档网站：https://mybatis.org/mybatis-3/zh/configuration.html 我们需要导入Mybatis的依赖，Jar包需要在github上下载，如果卡得一匹，连不上可以在视频简介处从分享的文件中获取。同样地放入到项目的根目录下，右键作为依赖即可！（依赖变多之后，我们可以将其放到一个单独的文件夹，不然会很繁杂） 依赖导入完成后，我们就可以编写Mybatis的配置文件了（现在不是在Java代码中配置了，而是通过一个XML文件去配置，这样就使得硬编码的部分大大减少，项目后期打包成Jar运行不方便修复，但是通过配置文件，我们随时都可以去修改，就变得很方便了，同时代码量也大幅度减少，配置文件填写完成后，我们只需要关心项目的业务逻辑而不是如何去读取配置文件）我们按照官方文档给定的提示，在项目根目录下新建名为mybatis-config.xml的文件，并填写以下内容： 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;驱动类（含包名）&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;数据库连接URL&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;用户名&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;密码&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt; 我们发现，在最上方还引入了一个叫做DTD（文档类型定义）的东西，它提前帮助我们规定了一些标签，我们就需要使用Mybatis提前帮助我们规定好的标签来进行配置（因为只有这样Mybatis才能正确识别我们配置的内容） 通过进行配置，我们就告诉了Mybatis我们链接数据库的一些信息，包括URL、用户名、密码等，这样Mybatis就知道该链接哪个数据库、使用哪个账号进行登陆了（也可以不使用配置文件，这里不做讲解，还请各位小伙伴自行阅读官方文档） 配置文件完成后，我们需要在Java程序启动时，让Mybatis对配置文件进行读取并得到一个SqlSessionFactory对象： 123456public static void main(String[] args) throws FileNotFoundException &#123; SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(new FileInputStream(&quot;mybatis-config.xml&quot;)); try (SqlSession sqlSession = sqlSessionFactory.openSession(true))&#123; //暂时还没有业务 &#125;&#125; 直接运行即可，虽然没有干什么事情，但是不会出现错误，如果之前的配置文件编写错误，直接运行会产生报错！那么现在我们来看看，SqlSessionFactory对象是什么东西： 每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的，我们可以通过SqlSessionFactory来创建多个新的会话，SqlSession对象，每个会话就相当于我不同的地方登陆一个账号去访问数据库，你也可以认为这就是之前JDBC中的Statement对象，会话之间相互隔离，没有任何关联。 而通过SqlSession就可以完成几乎所有的数据库操作，我们发现这个接口中定义了大量数据库操作的方法，因此，现在我们只需要通过一个对象就能完成数据库交互了，极大简化了之前的流程。 我们来尝试一下直接读取实体类，读取实体类肯定需要一个映射规则，比如类中的哪个字段对应数据库中的哪个字段，在查询语句返回结果后，Mybatis就会自动将对应的结果填入到对象的对应字段上。首先编写实体类，，直接使用Lombok是不是就很方便了： 12345678import lombok.Data;@Datapublic class Student &#123; int sid; //名称最好和数据库字段名称保持一致，不然可能会映射失败导致查询结果丢失 String name; String sex;&#125; 在根目录下重新创建一个mapper文件夹，新建名为TestMapper.xml的文件作为我们的映射器，并填写以下内容： 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;TestMapper&quot;&gt; &lt;select id=&quot;selectStudent&quot; resultType=&quot;com.test.entity.Student&quot;&gt; select * from student &lt;/select&gt;&lt;/mapper&gt; 其中namespace就是命名空间，每个Mapper都是唯一的，因此需要用一个命名空间来区分，它还可以用来绑定一个接口。我们在里面写入了一个select标签，表示添加一个select操作，同时id作为操作的名称，resultType指定为我们刚刚定义的实体类，表示将数据库结果映射为Student类，然后就在标签中写入我们的查询语句即可。 编写好后，我们在配置文件中添加这个Mapper映射器： 1234&lt;mappers&gt; &lt;mapper url=&quot;file:mappers/TestMapper.xml&quot;/&gt; &lt;!-- 这里用的是url，也可以使用其他类型，我们会在后面讲解 --&gt;&lt;/mappers&gt; 最后在程序中使用我们定义好的Mapper即可： 1234567public static void main(String[] args) throws FileNotFoundException &#123; SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(new FileInputStream(&quot;mybatis-config.xml&quot;)); try (SqlSession sqlSession = sqlSessionFactory.openSession(true))&#123; List&lt;Student&gt; student = sqlSession.selectList(&quot;selectStudent&quot;); student.forEach(System.out::println); &#125;&#125; 我们会发现，Mybatis非常智能，我们只需要告诉一个映射关系，就能够直接将查询结果转化为一个实体类！ 配置Mybatis在了解了Mybatis为我们带来的便捷之后，现在我们就可以正式地去学习使用Mybatis了！ 由于SqlSessionFactory一般只需要创建一次，因此我们可以创建一个工具类来集中创建SqlSession，这样会更加方便一些： 123456789101112131415161718192021public class MybatisUtil &#123; //在类加载时就进行创建 private static SqlSessionFactory sqlSessionFactory; static &#123; try &#123; sqlSessionFactory = new SqlSessionFactoryBuilder().build(new FileInputStream(&quot;mybatis-config.xml&quot;)); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取一个新的会话 * @param autoCommit 是否开启自动提交（跟JDBC是一样的，如果不自动提交，则会变成事务操作） * @return SqlSession对象 */ public static SqlSession getSession(boolean autoCommit)&#123; return sqlSessionFactory.openSession(autoCommit); &#125;&#125; 现在我们只需要在main方法中这样写即可查询结果了： 123456public static void main(String[] args) &#123; try (SqlSession sqlSession = MybatisUtil.getSession(true))&#123; List&lt;Student&gt; student = sqlSession.selectList(&quot;selectStudent&quot;); student.forEach(System.out::println); &#125;&#125; 之前我们演示了，如何创建一个映射器来将结果快速转换为实体类，但是这样可能还是不够方便，我们每次都需要去找映射器对应操作的名称，而且还要知道对应的返回类型，再通过SqlSession来执行对应的方法，能不能再方便一点呢？ 现在，我们可以通过namespace来绑定到一个接口上，利用接口的特性，我们可以直接指明方法的行为，而实际实现则是由Mybatis来完成。 123public interface TestMapper &#123; List&lt;Student&gt; selectStudent();&#125; 将Mapper文件的命名空间修改为我们的接口，建议同时将其放到同名包中，作为内部资源： 12345&lt;mapper namespace=&quot;com.test.mapper.TestMapper&quot;&gt; &lt;select id=&quot;selectStudent&quot; resultType=&quot;com.test.entity.Student&quot;&gt; select * from student &lt;/select&gt;&lt;/mapper&gt; 作为内部资源后，我们需要修改一下配置文件中的mapper定义，不使用url而是resource表示是Jar内部的文件： 123&lt;mappers&gt; &lt;mapper resource=&quot;com/test/mapper/TestMapper.xml&quot;/&gt;&lt;/mappers&gt; 现在我们就可以直接通过SqlSession获取对应的实现类，通过接口中定义的行为来直接获取结果： 1234567public static void main(String[] args) &#123; try (SqlSession sqlSession = MybatisUtil.getSession(true))&#123; TestMapper testMapper = sqlSession.getMapper(TestMapper.class); List&lt;Student&gt; student = testMapper.selectStudent(); student.forEach(System.out::println); &#125;&#125; 那么肯定有人好奇，TestMapper明明是一个我们自己定义接口啊，Mybatis也不可能提前帮我们写了实现类啊，那这接口怎么就出现了一个实现类呢？我们可以通过调用getClass()方法来看看实现类是个什么： 12TestMapper testMapper = sqlSession.getMapper(TestMapper.class);System.out.println(testMapper.getClass()); 我们发现，实现类名称很奇怪，名称为com.sun.proxy.$Proxy4，它是通过动态代理生成的，相当于动态生成了一个实现类，而不是预先定义好的，有关Mybatis这一部分的原理，我们放在最后一节进行讲解。 接下来，我们再来看配置文件，之前我们并没有对配置文件进行一个详细的介绍： 12345678910111213141516&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/study&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;test&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;com/test/mapper/TestMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 首先就从environments标签说起，一般情况下，我们在开发中，都需要指定一个数据库的配置信息，包含连接URL、用户、密码等信息，而environment就是用于进行这些配置的！实际情况下可能会不止有一个数据库连接信息，比如开发过程中我们一般会使用本地的数据库，而如果需要将项目上传到服务器或是防止其他人的电脑上运行时，我们可能就需要配置另一个数据库的信息，因此，我们可以提前定义好所有的数据库信息，该什么时候用什么即可！ 在environments标签上有一个default属性，来指定默认的环境，当然如果我们希望使用其他环境，可以修改这个默认环境，也可以在创建工厂时选择环境： 12sqlSessionFactory = new SqlSessionFactoryBuilder() .build(new FileInputStream(&quot;mybatis-config.xml&quot;), &quot;环境ID&quot;); 我们还可以给类型起一个别名，以简化Mapper的编写： 1234&lt;!-- 需要在environments的上方 --&gt;&lt;typeAliases&gt; &lt;typeAlias type=&quot;com.test.entity.Student&quot; alias=&quot;Student&quot;/&gt;&lt;/typeAliases&gt; 现在Mapper就可以直接使用别名了： 12345&lt;mapper namespace=&quot;com.test.mapper.TestMapper&quot;&gt; &lt;select id=&quot;selectStudent&quot; resultType=&quot;Student&quot;&gt; select * from student &lt;/select&gt;&lt;/mapper&gt; 如果这样还是很麻烦，我们也可以直接让Mybatis去扫描一个包，并将包下的所有类自动起别名（别名为首字母小写的类名） 123&lt;typeAliases&gt; &lt;package name=&quot;com.test.entity&quot;/&gt;&lt;/typeAliases&gt; 也可以为指定实体类添加一个注解，来指定别名： 1234567@Data@Alias(&quot;lbwnb&quot;)public class Student &#123; private int sid; private String name; private String sex;&#125; 当然，Mybatis也包含许多的基础配置，通过使用： 123&lt;settings&gt; &lt;setting name=&quot;&quot; value=&quot;&quot;/&gt;&lt;/settings&gt; 所有的配置项可以在中文文档处查询，本文不会进行详细介绍，在后面我们会提出一些比较重要的配置项。 有关配置文件的介绍就暂时到这里为止，我们讨论的重心应该是Mybatis的应用，而不是配置文件，所以省略了一部分内容的讲解。 增删改查在了解了Mybatis的一些基本配置之后，我们就可以正式来使用Mybatis来进行数据库操作了！ 在前面我们演示了如何快速进行查询，我们只需要编写一个对应的映射器既可以了： 12345&lt;mapper namespace=&quot;com.test.mapper.TestMapper&quot;&gt; &lt;select id=&quot;studentList&quot; resultType=&quot;Student&quot;&gt; select * from student &lt;/select&gt;&lt;/mapper&gt; 当然，如果你不喜欢使用实体类，那么这些属性还可以被映射到一个Map上： 123&lt;select id=&quot;selectStudent&quot; resultType=&quot;Map&quot;&gt; select * from student&lt;/select&gt; 123public interface TestMapper &#123; List&lt;Map&gt; selectStudent();&#125; Map中就会以键值对的形式来存放这些结果了。 通过设定一个resultType属性，让Mybatis知道查询结果需要映射为哪个实体类，要求字段名称保持一致。那么如果我们不希望按照这样的规则来映射呢？我们可以自定义resultMap来设定映射规则： 12345&lt;resultMap id=&quot;Test&quot; type=&quot;Student&quot;&gt; &lt;result column=&quot;sid&quot; property=&quot;sid&quot;/&gt; &lt;result column=&quot;sex&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;name&quot; property=&quot;sex&quot;/&gt;&lt;/resultMap&gt; 通过指定映射规则，我们现在名称和性别一栏就发生了交换，因为我们将其映射字段进行了交换。 如果一个类中存在多个构造方法，那么很有可能会出现这样的错误： 123456789### Exception in thread &quot;main&quot; org.apache.ibatis.exceptions.PersistenceException: ### Error querying database. Cause: org.apache.ibatis.executor.ExecutorException: No constructor found in com.test.entity.Student matching [java.lang.Integer, java.lang.String, java.lang.String]### The error may exist in com/test/mapper/TestMapper.xml### The error may involve com.test.mapper.TestMapper.getStudentBySid### The error occurred while handling results### SQL: select * from student where sid = ?### Cause: org.apache.ibatis.executor.ExecutorException: No constructor found in com.test.entity.Student matching [java.lang.Integer, java.lang.String, java.lang.String] at org.apache.ibatis.exceptions.ExceptionFactory.wrapException(ExceptionFactory.java:30) ... 这时就需要使用constructor标签来指定构造方法： 123456&lt;resultMap id=&quot;test&quot; type=&quot;Student&quot;&gt; &lt;constructor&gt; &lt;arg column=&quot;sid&quot; javaType=&quot;Integer&quot;/&gt; &lt;arg column=&quot;name&quot; javaType=&quot;String&quot;/&gt; &lt;/constructor&gt;&lt;/resultMap&gt; 值得注意的是，指定构造方法后，若此字段被填入了构造方法作为参数，将不会通过反射给字段单独赋值，而构造方法中没有传入的字段，依然会被反射赋值，有关resultMap的内容，后面还会继续讲解。 如果数据库中存在一个带下划线的字段，我们可以通过设置让其映射为以驼峰命名的字段，比如my_test映射为myTest 123&lt;settings&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt; 如果不设置，默认为不开启，也就是默认需要名称保持一致。 我们接着来看看条件查询，既然是条件查询，那么肯定需要我们传入查询条件，比如现在我们想通过sid字段来通过学号查找信息： 1Student getStudentBySid(int sid); 123&lt;select id=&quot;getStudentBySid&quot; parameterType=&quot;int&quot; resultType=&quot;Student&quot;&gt; select * from student where sid = #&#123;sid&#125;&lt;/select&gt; 我们通过使用#&#123;xxx&#125;或是$&#123;xxx&#125;来填入我们给定的属性，实际上Mybatis本质也是通过PreparedStatement首先进行一次预编译，有效地防止SQL注入问题，但是如果使用$&#123;xxx&#125;就不再是通过预编译，而是直接传值，因此我们一般都使用#&#123;xxx&#125;来进行操作。 使用parameterType属性来指定参数类型（非必须，可以不用，推荐不用） 接着我们来看插入、更新和删除操作，其实与查询操作差不多，不过需要使用对应的标签，比如插入操作： 123&lt;insert id=&quot;addStudent&quot; parameterType=&quot;Student&quot;&gt; insert into student(name, sex) values(#&#123;name&#125;, #&#123;sex&#125;)&lt;/insert&gt; 1int addStudent(Student student); 我们这里使用的是一个实体类，我们可以直接使用实体类里面对应属性替换到SQL语句中，只需要填写属性名称即可，和条件查询是一样的。 复杂查询一个老师可以教授多个学生，那么能否一次性将老师的学生全部映射给此老师的对象呢，比如： 123456@Datapublic class Teacher &#123; int tid; String name; List&lt;Student&gt; studentList;&#125; 映射为Teacher对象时，同时将其教授的所有学生一并映射为List列表，显然这是一种一对多的查询，那么这时就需要进行复杂查询了。而我们之前编写的都非常简单，直接就能完成映射，因此我们现在需要使用resultMap来自定义映射规则： 1234567891011121314&lt;select id=&quot;getTeacherByTid&quot; resultMap=&quot;asTeacher&quot;&gt; select *, teacher.name as tname from student inner join teach on student.sid = teach.sid inner join teacher on teach.tid = teacher.tid where teach.tid = #&#123;tid&#125;&lt;/select&gt;&lt;resultMap id=&quot;asTeacher&quot; type=&quot;Teacher&quot;&gt; &lt;id column=&quot;tid&quot; property=&quot;tid&quot;/&gt; &lt;result column=&quot;tname&quot; property=&quot;name&quot;/&gt; &lt;collection property=&quot;studentList&quot; ofType=&quot;Student&quot;&gt; &lt;id property=&quot;sid&quot; column=&quot;sid&quot;/&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt; &lt;/collection&gt;&lt;/resultMap&gt; 可以看到，我们的查询结果是一个多表联查的结果，而联查的数据就是我们需要映射的数据（比如这里是一个老师有N个学生，联查的结果也是这一个老师对应N个学生的N条记录），其中id标签用于在多条记录中辨别是否为同一个对象的数据，比如上面的查询语句得到的结果中，tid这一行始终为1，因此所有的记录都应该是tid=1的教师的数据，而不应该变为多个教师的数据，如果不加id进行约束，那么会被识别成多个教师的数据！ 通过使用collection来表示将得到的所有结果合并为一个集合，比如上面的数据中每个学生都有单独的一条记录，因此tid相同的全部学生的记录就可以最后合并为一个List，得到最终的映射结果，当然，为了区分，最好也设置一个id，只不过这个例子中可以当做普通的result使用。 了解了一对多，那么多对一又该如何查询呢，比如每个学生都有一个对应的老师，现在Student新增了一个Teacher对象，那么现在又该如何去处理呢？ 1234567891011121314@Data@Accessors(chain = true)public class Student &#123; private int sid; private String name; private String sex; private Teacher teacher;&#125;@Datapublic class Teacher &#123; int tid; String name;&#125; 现在我们希望的是，每次查询到一个Student对象时都带上它的老师，同样的，我们也可以使用resultMap来实现（先修改一下老师的类定义，不然会很麻烦）： 12345678910111213&lt;resultMap id=&quot;test2&quot; type=&quot;Student&quot;&gt; &lt;id column=&quot;sid&quot; property=&quot;sid&quot;/&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt; &lt;association property=&quot;teacher&quot; javaType=&quot;Teacher&quot;&gt; &lt;id column=&quot;tid&quot; property=&quot;tid&quot;/&gt; &lt;result column=&quot;tname&quot; property=&quot;name&quot;/&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectStudent&quot; resultMap=&quot;test2&quot;&gt; select *, teacher.name as tname from student left join teach on student.sid = teach.sid left join teacher on teach.tid = teacher.tid&lt;/select&gt; 通过使用association进行关联，形成多对一的关系，实际上和一对多是同理的，都是对查询结果的一种处理方式罢了。 事务操作我们可以在获取SqlSession关闭自动提交来开启事务模式，和JDBC其实都差不多： 123456789public static void main(String[] args) &#123; try (SqlSession sqlSession = MybatisUtil.getSession(false))&#123; TestMapper testMapper = sqlSession.getMapper(TestMapper.class); testMapper.addStudent(new Student().setSex(&quot;男&quot;).setName(&quot;小王&quot;)); testMapper.selectStudent().forEach(System.out::println); &#125;&#125; 我们发现，在关闭自动提交后，我们的内容是没有进入到数据库的，现在我们来试一下在最后提交事务： 1sqlSession.commit(); 在事务提交后，我们的内容才会被写入到数据库中。现在我们来试试看回滚操作： 123456789try (SqlSession sqlSession = MybatisUtil.getSession(false))&#123; TestMapper testMapper = sqlSession.getMapper(TestMapper.class); testMapper.addStudent(new Student().setSex(&quot;男&quot;).setName(&quot;小王&quot;)); testMapper.selectStudent().forEach(System.out::println); sqlSession.rollback(); sqlSession.commit();&#125; 回滚操作也印证成功。 动态SQL动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。 我们直接使用官网的例子进行讲解。 缓存机制MyBatis 内置了一个强大的事务性查询缓存机制，它可以非常方便地配置和定制。 其实缓存机制我们在之前学习IO流的时候已经提及过了，我们可以提前将一部分内容放入缓存，下次需要获取数据时，我们就可以直接从缓存中读取，这样的话相当于直接从内存中获取而不是再去向数据库索要数据，效率会更高。 因此Mybatis内置了一个缓存机制，我们查询时，如果缓存中存在数据，那么我们就可以直接从缓存中获取，而不是再去向数据库进行请求。 Mybatis存在一级缓存和二级缓存，我们首先来看一下一级缓存，默认情况下，只启用了本地的会话缓存，它仅仅对一个会话中的数据进行缓存（一级缓存无法关闭，只能调整），我们来看看下面这段代码： 12345678public static void main(String[] args) throws InterruptedException &#123; try (SqlSession sqlSession = MybatisUtil.getSession(true))&#123; TestMapper testMapper = sqlSession.getMapper(TestMapper.class); Student student1 = testMapper.getStudentBySid(1); Student student2 = testMapper.getStudentBySid(1); System.out.println(student1 == student2); &#125;&#125; 我们发现，两次得到的是同一个Student对象，也就是说我们第二次查询并没有重新去构造对象，而是直接得到之前创建好的对象。如果还不是很明显，我们可以修改一下实体类： 123456789101112@Data@Accessors(chain = true)public class Student &#123; public Student()&#123; System.out.println(&quot;我被构造了&quot;); &#125; private int sid; private String name; private String sex;&#125; 我们通过前面的学习得知Mybatis在映射为对象时，在只有一个构造方法的情况下，无论你构造方法写成什么样子，都会去调用一次构造方法，如果存在多个构造方法，那么就会去找匹配的构造方法。我们可以通过查看构造方法来验证对象被创建了几次。 结果显而易见，只创建了一次，也就是说当第二次进行同样的查询时，会直接使用第一次的结果，因为第一次的结果已经被缓存了。 那么如果我修改了数据库中的内容，缓存还会生效吗： 123456789public static void main(String[] args) throws InterruptedException &#123; try (SqlSession sqlSession = MybatisUtil.getSession(true))&#123; TestMapper testMapper = sqlSession.getMapper(TestMapper.class); Student student1 = testMapper.getStudentBySid(1); testMapper.addStudent(new Student().setName(&quot;小李&quot;).setSex(&quot;男&quot;)); Student student2 = testMapper.getStudentBySid(1); System.out.println(student1 == student2); &#125;&#125; 我们发现，当我们进行了插入操作后，缓存就没有生效了，我们再次进行查询得到的是一个新创建的对象。 也就是说，一级缓存，在进行DML操作后，会使得缓存失效，也就是说Mybatis知道我们对数据库里面的数据进行了修改，所以之前缓存的内容可能就不是当前数据库里面最新的内容了。还有一种情况就是，当前会话结束后，也会清理全部的缓存，因为已经不会再用到了。但是一定注意，一级缓存只针对于单个会话，多个会话之间不相通。 1234567891011121314public static void main(String[] args) &#123; try (SqlSession sqlSession = MybatisUtil.getSession(true))&#123; TestMapper testMapper = sqlSession.getMapper(TestMapper.class); Student student2; try(SqlSession sqlSession2 = MybatisUtil.getSession(true))&#123; TestMapper testMapper2 = sqlSession2.getMapper(TestMapper.class); student2 = testMapper2.getStudentBySid(1); &#125; Student student1 = testMapper.getStudentBySid(1); System.out.println(student1 == student2); &#125;&#125; **注意：**一个会话DML操作只会重置当前会话的缓存，不会重置其他会话的缓存，也就是说，其他会话缓存是不会更新的！ 一级缓存给我们提供了很高速的访问效率，但是它的作用范围实在是有限，如果一个会话结束，那么之前的缓存就全部失效了，但是我们希望缓存能够扩展到所有会话都能使用，因此我们可以通过二级缓存来实现，二级缓存默认是关闭状态，要开启二级缓存，我们需要在映射器XML文件中添加： 1&lt;cache/&gt; 可见二级缓存是Mapper级别的，也就是说，当一个会话失效时，它的缓存依然会存在于二级缓存中，因此如果我们再次创建一个新的会话会直接使用之前的缓存，我们首先根据官方文档进行一些配置： 12345&lt;cache eviction=&quot;FIFO&quot; flushInterval=&quot;60000&quot; size=&quot;512&quot; readOnly=&quot;true&quot;/&gt; 我们来编写一个代码： 12345678910111213public static void main(String[] args) &#123; Student student; try (SqlSession sqlSession = MybatisUtil.getSession(true))&#123; TestMapper testMapper = sqlSession.getMapper(TestMapper.class); student = testMapper.getStudentBySid(1); &#125; try (SqlSession sqlSession2 = MybatisUtil.getSession(true))&#123; TestMapper testMapper2 = sqlSession2.getMapper(TestMapper.class); Student student2 = testMapper2.getStudentBySid(1); System.out.println(student2 == student); &#125;&#125; 我们可以看到，上面的代码中首先是第一个会话在进行读操作，完成后会结束会话，而第二个操作重新创建了一个新的会话，再次执行了同样的查询，我们发现得到的依然是缓存的结果。 那么如果我不希望某个方法开启缓存呢？我们可以添加useCache属性来关闭缓存： 123&lt;select id=&quot;getStudentBySid&quot; resultType=&quot;Student&quot; useCache=&quot;false&quot;&gt; select * from student where sid = #&#123;sid&#125;&lt;/select&gt; 我们也可以使用flushCache&#x3D;”false”在每次执行后都清空缓存，通过这这个我们还可以控制DML操作完成之后不清空缓存。 123&lt;select id=&quot;getStudentBySid&quot; resultType=&quot;Student&quot; flushCache=&quot;true&quot;&gt; select * from student where sid = #&#123;sid&#125;&lt;/select&gt; 添加了二级缓存之后，会先从二级缓存中查找数据，当二级缓存中没有时，才会从一级缓存中获取，当一级缓存中都还没有数据时，才会请求数据库，因此我们再来执行上面的代码： 1234567891011121314public static void main(String[] args) &#123; try (SqlSession sqlSession = MybatisUtil.getSession(true))&#123; TestMapper testMapper = sqlSession.getMapper(TestMapper.class); Student student2; try(SqlSession sqlSession2 = MybatisUtil.getSession(true))&#123; TestMapper testMapper2 = sqlSession2.getMapper(TestMapper.class); student2 = testMapper2.getStudentBySid(1); &#125; Student student1 = testMapper.getStudentBySid(1); System.out.println(student1 == student2); &#125;&#125; 得到的结果就会是同一个对象了，因为现在是优先从二级缓存中获取。 读取顺序：二级缓存 &#x3D;&gt; 一级缓存 &#x3D;&gt; 数据库 虽然缓存机制给我们提供了很大的性能提升，但是缓存存在一个问题，我们之前在计算机组成原理中可能学习过缓存一致性问题，也就是说当多个CPU在操作自己的缓存时，可能会出现各自的缓存内容不同步的问题，而Mybatis也会这样，我们来看看这个例子： 123456789public static void main(String[] args) throws InterruptedException &#123; try (SqlSession sqlSession = MybatisUtil.getSession(true))&#123; TestMapper testMapper = sqlSession.getMapper(TestMapper.class); while (true)&#123; Thread.sleep(3000); System.out.println(testMapper.getStudentBySid(1)); &#125; &#125;&#125; 我们现在循环地每三秒读取一次，而在这个过程中，我们使用IDEA手动修改数据库中的数据，将1号同学的学号改成100，那么理想情况下，下一次读取将无法获取到小明，因为小明的学号已经发生变化了。 但是结果却是依然能够读取，并且sid并没有发生改变，这也证明了Mybatis的缓存在生效，因为我们是从外部进行修改，Mybatis不知道我们修改了数据，所以依然在使用缓存中的数据，但是这样很明显是不正确的，因此，如果存在多台服务器或者是多个程序都在使用Mybatis操作同一个数据库，并且都开启了缓存，需要解决这个问题，要么就得关闭Mybatis的缓存来保证一致性： 123&lt;settings&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;false&quot;/&gt;&lt;/settings&gt; 123&lt;select id=&quot;getStudentBySid&quot; resultType=&quot;Student&quot; useCache=&quot;false&quot; flushCache=&quot;true&quot;&gt; select * from student where sid = #&#123;sid&#125;&lt;/select&gt; 要么就需要实现缓存共用，也就是让所有的Mybatis都使用同一个缓存进行数据存取，在后面，我们会继续学习Redis、Ehcache、Memcache等缓存框架，通过使用这些工具，就能够很好地解决缓存一致性问题。 使用注解开发在之前的开发中，我们已经体验到Mybatis为我们带来的便捷了，我们只需要编写对应的映射器，并将其绑定到一个接口上，即可直接通过该接口执行我们的SQL语句，极大的简化了我们之前JDBC那样的代码编写模式。那么，能否实现无需xml映射器配置，而是直接使用注解在接口上进行配置呢？答案是可以的，也是现在推荐的一种方式（也不是说XML就不要去用了，由于Java 注解的表达能力和灵活性十分有限，可能相对于XML配置某些功能实现起来会不太好办，但是在大部分场景下，直接使用注解开发已经绰绰有余了） 首先我们来看一下，使用XML进行映射器编写时，我们需要现在XML中定义映射规则和SQL语句，然后再将其绑定到一个接口的方法定义上，然后再使用接口来执行： 123&lt;insert id=&quot;addStudent&quot;&gt; insert into student(name, sex) values(#&#123;name&#125;, #&#123;sex&#125;)&lt;/insert&gt; 1int addStudent(Student student); 而现在，我们可以直接使用注解来实现，每个操作都有一个对应的注解： 12@Insert(&quot;insert into student(name, sex) values(#&#123;name&#125;, #&#123;sex&#125;)&quot;)int addStudent(Student student); 当然，我们还需要修改一下配置文件中的映射器注册： 1234&lt;mappers&gt; &lt;mapper class=&quot;com.test.mapper.MyMapper&quot;/&gt; &lt;!-- 也可以直接注册整个包下的 &lt;package name=&quot;com.test.mapper&quot;/&gt; --&gt;&lt;/mappers&gt; 通过直接指定Class，来让Mybatis知道我们这里有一个通过注解实现的映射器。 我们接着来看一下，如何使用注解进行自定义映射规则： 1234567@Results(&#123; @Result(id = true, column = &quot;sid&quot;, property = &quot;sid&quot;), @Result(column = &quot;sex&quot;, property = &quot;name&quot;), @Result(column = &quot;name&quot;, property = &quot;sex&quot;)&#125;)@Select(&quot;select * from student&quot;)List&lt;Student&gt; getAllStudent(); 直接通过@Results注解，就可以直接进行配置了，此注解的value是一个@Result注解数组，每个@Result注解都都一个单独的字段配置，其实就是我们之前在XML映射器中写的： 12345&lt;resultMap id=&quot;test&quot; type=&quot;Student&quot;&gt; &lt;id property=&quot;sid&quot; column=&quot;sid&quot;/&gt; &lt;result column=&quot;name&quot; property=&quot;sex&quot;/&gt; &lt;result column=&quot;sex&quot; property=&quot;name&quot;/&gt;&lt;/resultMap&gt; 现在我们就可以通过注解来自定义映射规则了。那么如何使用注解来完成复杂查询呢？我们还是使用一个老师多个学生的例子： 123456789101112@Results(&#123; @Result(id = true, column = &quot;tid&quot;, property = &quot;tid&quot;), @Result(column = &quot;name&quot;, property = &quot;name&quot;), @Result(column = &quot;tid&quot;, property = &quot;studentList&quot;, many = @Many(select = &quot;getStudentByTid&quot;) )&#125;)@Select(&quot;select * from teacher where tid = #&#123;tid&#125;&quot;)Teacher getTeacherBySid(int tid);@Select(&quot;select * from student inner join teach on student.sid = teach.sid where tid = #&#123;tid&#125;&quot;)List&lt;Student&gt; getStudentByTid(int tid); 我们发现，多出了一个子查询，而这个子查询是单独查询该老师所属学生的信息，而子查询结果作为@Result注解的一个many结果，代表子查询的所有结果都归入此集合中（也就是之前的collection标签） 123456789&lt;resultMap id=&quot;asTeacher&quot; type=&quot;Teacher&quot;&gt; &lt;id column=&quot;tid&quot; property=&quot;tid&quot;/&gt; &lt;result column=&quot;tname&quot; property=&quot;name&quot;/&gt; &lt;collection property=&quot;studentList&quot; ofType=&quot;Student&quot;&gt; &lt;id property=&quot;sid&quot; column=&quot;sid&quot;/&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt; &lt;/collection&gt;&lt;/resultMap&gt; 同理，@Result也提供了@One子注解来实现一对一的关系表示，类似于之前的assocation标签： 12345678910@Results(&#123; @Result(id = true, column = &quot;sid&quot;, property = &quot;sid&quot;), @Result(column = &quot;sex&quot;, property = &quot;name&quot;), @Result(column = &quot;name&quot;, property = &quot;sex&quot;), @Result(column = &quot;sid&quot;, property = &quot;teacher&quot;, one = @One(select = &quot;getTeacherBySid&quot;) )&#125;)@Select(&quot;select * from student&quot;)List&lt;Student&gt; getAllStudent(); 如果现在我希望直接使用注解编写SQL语句但是我希望映射规则依然使用XML来实现，这时该怎么办呢？ 123@ResultMap(&quot;test&quot;)@Select(&quot;select * from student&quot;)List&lt;Student&gt; getAllStudent(); 提供了@ResultMap注解，直接指定ID即可，这样我们就可以使用XML中编写的映射规则了，这里就不再演示了。 那么如果出现之前的两个构造方法的情况，且没有任何一个构造方法匹配的话，该怎么处理呢？ 12345678910111213141516@Data@Accessors(chain = true)public class Student &#123; public Student(int sid)&#123; System.out.println(&quot;我是一号构造方法&quot;+sid); &#125; public Student(int sid, String name)&#123; System.out.println(&quot;我是二号构造方法&quot;+sid+name); &#125; private int sid; private String name; private String sex;&#125; 我们可以通过@ConstructorArgs注解来指定构造方法： 123456@ConstructorArgs(&#123; @Arg(column = &quot;sid&quot;, javaType = int.class), @Arg(column = &quot;name&quot;, javaType = String.class)&#125;)@Select(&quot;select * from student where sid = #&#123;sid&#125; and sex = #&#123;sex&#125;&quot;)Student getStudentBySidAndSex(@Param(&quot;sid&quot;) int sid, @Param(&quot;sex&quot;) String sex); 得到的结果和使用constructor标签效果一致，这里就不多做讲解了。 我们发现，当参数列表中出现两个以上的参数时，会出现错误： 12@Select(&quot;select * from student where sid = #&#123;sid&#125; and sex = #&#123;sex&#125;&quot;)Student getStudentBySidAndSex(int sid, String sex); 12345678910111213Exception in thread &quot;main&quot; org.apache.ibatis.exceptions.PersistenceException: ### Error querying database. Cause: org.apache.ibatis.binding.BindingException: Parameter &#x27;sid&#x27; not found. Available parameters are [arg1, arg0, param1, param2]### Cause: org.apache.ibatis.binding.BindingException: Parameter &#x27;sid&#x27; not found. Available parameters are [arg1, arg0, param1, param2] at org.apache.ibatis.exceptions.ExceptionFactory.wrapException(ExceptionFactory.java:30) at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:153) at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:145) at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:140) at org.apache.ibatis.session.defaults.DefaultSqlSession.selectOne(DefaultSqlSession.java:76) at org.apache.ibatis.binding.MapperMethod.execute(MapperMethod.java:87) at org.apache.ibatis.binding.MapperProxy$PlainMethodInvoker.invoke(MapperProxy.java:145) at org.apache.ibatis.binding.MapperProxy.invoke(MapperProxy.java:86) at com.sun.proxy.$Proxy6.getStudentBySidAndSex(Unknown Source) at com.test.Main.main(Main.java:16) 原因是Mybatis不明确到底哪个参数是什么，因此我们可以添加@Param来指定参数名称： 12@Select(&quot;select * from student where sid = #&#123;sid&#125; and sex = #&#123;sex&#125;&quot;)Student getStudentBySidAndSex(@Param(&quot;sid&quot;) int sid, @Param(&quot;sex&quot;) String sex); **探究：**要是我两个参数一个是基本类型一个是对象类型呢？ 1System.out.println(testMapper.addStudent(100, new Student().setName(&quot;小陆&quot;).setSex(&quot;男&quot;))); 12@Insert(&quot;insert into student(sid, name, sex) values(#&#123;sid&#125;, #&#123;name&#125;, #&#123;sex&#125;)&quot;)int addStudent(@Param(&quot;sid&quot;) int sid, @Param(&quot;student&quot;) Student student); 那么这个时候，就出现问题了，Mybatis就不能明确这些属性是从哪里来的： 12345678910### SQL: insert into student(sid, name, sex) values(?, ?, ?)### Cause: org.apache.ibatis.binding.BindingException: Parameter &#x27;name&#x27; not found. Available parameters are [student, param1, sid, param2] at org.apache.ibatis.exceptions.ExceptionFactory.wrapException(ExceptionFactory.java:30) at org.apache.ibatis.session.defaults.DefaultSqlSession.update(DefaultSqlSession.java:196) at org.apache.ibatis.session.defaults.DefaultSqlSession.insert(DefaultSqlSession.java:181) at org.apache.ibatis.binding.MapperMethod.execute(MapperMethod.java:62) at org.apache.ibatis.binding.MapperProxy$PlainMethodInvoker.invoke(MapperProxy.java:145) at org.apache.ibatis.binding.MapperProxy.invoke(MapperProxy.java:86) at com.sun.proxy.$Proxy6.addStudent(Unknown Source) at com.test.Main.main(Main.java:16) 那么我们就通过参数名称.属性的方式去让Mybatis知道我们要用的是哪个属性： 12@Insert(&quot;insert into student(sid, name, sex) values(#&#123;sid&#125;, #&#123;student.name&#125;, #&#123;student.sex&#125;)&quot;)int addStudent(@Param(&quot;sid&quot;) int sid, @Param(&quot;student&quot;) Student student); 那么如何通过注解控制缓存机制呢？ 123456@CacheNamespace(readWrite = false)public interface MyMapper &#123; @Select(&quot;select * from student&quot;) @Options(useCache = false) List&lt;Student&gt; getAllStudent(); 使用@CacheNamespace注解直接定义在接口上即可，然后我们可以通过使用@Options来控制单个操作的缓存启用。 探究Mybatis的动态代理机制在探究动态代理机制之前，我们要先聊聊什么是代理：其实顾名思义，就好比我开了个大棚，里面栽种的西瓜，那么西瓜成熟了是不是得去卖掉赚钱，而我们的西瓜非常多，一个人肯定卖不过来，肯定就要去多找几个开水果摊的帮我们卖，这就是一种代理。实际上是由水果摊老板在帮我们卖瓜，我们只告诉老板卖多少钱，而至于怎么卖的是由水果摊老板决定的。 那么现在我们来尝试实现一下这样的类结构，首先定义一个接口用于规范行为： 12345public interface Shopper &#123; //卖瓜行为 void saleWatermelon(String customer);&#125; 然后需要实现一下卖瓜行为，也就是我们要告诉老板卖多少钱，这里就直接写成成功出售： 12345678public class ShopperImpl implements Shopper&#123; //卖瓜行为的实现 @Override public void saleWatermelon(String customer) &#123; System.out.println(&quot;成功出售西瓜给 ===&gt; &quot;+customer); &#125;&#125; 最后老板代理后肯定要用自己的方式去出售这些西瓜，成交之后再按照我们告诉老板的价格进行出售： 123456789101112131415161718192021public class ShopperProxy implements Shopper&#123; private final Shopper impl; public ShopperProxy(Shopper impl)&#123; this.impl = impl; &#125; //代理卖瓜行为 @Override public void saleWatermelon(String customer) &#123; //首先进行 代理商讨价还价行为 System.out.println(customer + &quot;：哥们，这瓜多少钱一斤啊？&quot;); System.out.println(&quot;老板：两块钱一斤。&quot;); System.out.println(customer + &quot;：你这瓜皮子是金子做的，还是瓜粒子是金子做的？&quot;); System.out.println(&quot;老板：你瞅瞅现在哪有瓜啊，这都是大棚的瓜，你嫌贵我还嫌贵呢。&quot;); System.out.println(customer + &quot;：给我挑一个。&quot;); impl.saleWatermelon(customer); //讨价还价成功，进行我们告诉代理商的卖瓜行为 &#125;&#125; 现在我们来试试看： 123456public class Main &#123; public static void main(String[] args) &#123; Shopper shopper = new ShopperProxy(new ShopperImpl()); shopper.saleWatermelon(&quot;小强&quot;); &#125;&#125; 这样的操作称为静态代理，也就是说我们需要提前知道接口的定义并进行实现才可以完成代理，而Mybatis这样的是无法预知代理接口的，我们就需要用到动态代理。 JDK提供的反射框架就为我们很好地解决了动态代理的问题，在这里相当于对JavaSE阶段反射的内容进行一个补充。 123456789101112131415161718public class ShopperProxy implements InvocationHandler &#123; Object target; public ShopperProxy(Object target)&#123; this.target = target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; String customer = (String) args[0]; System.out.println(customer + &quot;：哥们，这瓜多少钱一斤啊？&quot;); System.out.println(&quot;老板：两块钱一斤。&quot;); System.out.println(customer + &quot;：你这瓜皮子是金子做的，还是瓜粒子是金子做的？&quot;); System.out.println(&quot;老板：你瞅瞅现在哪有瓜啊，这都是大棚的瓜，你嫌贵我还嫌贵呢。&quot;); System.out.println(customer + &quot;：行，给我挑一个。&quot;); return method.invoke(target, args); &#125;&#125; 通过实现InvocationHandler来成为一个动态代理，我们发现它提供了一个invoke方法，用于调用被代理对象的方法并完成我们的代理工作。现在就可以通过 Proxy.newProxyInstance来生成一个动态代理类： 1234567public static void main(String[] args) &#123; Shopper impl = new ShopperImpl(); Shopper shopper = (Shopper) Proxy.newProxyInstance(impl.getClass().getClassLoader(), impl.getClass().getInterfaces(), new ShopperProxy(impl)); shopper.saleWatermelon(&quot;小强&quot;); System.out.println(shopper.getClass());&#125; 通过打印类型我们发现，就是我们之前看到的那种奇怪的类：class com.sun.proxy.$Proxy0，因此Mybatis其实也是这样的来实现的（肯定有人问了：Mybatis是直接代理接口啊，你这个不还是要把接口实现了吗？）那我们来改改，现在我们不代理任何类了，直接做接口实现： 12345678910111213public class ShopperProxy implements InvocationHandler &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; String customer = (String) args[0]; System.out.println(customer + &quot;：哥们，这瓜多少钱一斤啊？&quot;); System.out.println(&quot;老板：两块钱一斤。&quot;); System.out.println(customer + &quot;：你这瓜皮子是金子做的，还是瓜粒子是金子做的？&quot;); System.out.println(&quot;老板：你瞅瞅现在哪有瓜啊，这都是大棚的瓜，你嫌贵我还嫌贵呢。&quot;); System.out.println(customer + &quot;：行，给我挑一个。&quot;); return null; &#125;&#125; 1234567public static void main(String[] args) &#123; Shopper shopper = (Shopper) Proxy.newProxyInstance(Shopper.class.getClassLoader(), new Class[]&#123; Shopper.class &#125;, //因为本身就是接口，所以直接用就行 new ShopperProxy()); shopper.saleWatermelon(&quot;小强&quot;); System.out.println(shopper.getClass());&#125; 我们可以去看看Mybatis的源码。 Mybatis的学习差不多就到这里为止了，不过，同样类型的框架还有很多，Mybatis属于半自动框架，SQL语句依然需要我们自己编写，虽然存在一定的麻烦，但是会更加灵活，而后面我们还会学习JPA，它是全自动的框架，你几乎见不到SQL的影子！ 使用JUnit进行单元测试首先一问：我们为什么需要单元测试？ 随着我们的项目逐渐变大，比如我们之前编写的图书管理系统，我们都是边在写边在测试，而我们当时使用的测试方法，就是直接在主方法中运行测试，但是，在很多情况下，我们的项目可能会很庞大，不可能每次都去完整地启动一个项目来测试某一个功能，这样显然会降低我们的开发效率，因此，我们需要使用单元测试来帮助我们针对于某个功能或是某个模块单独运行代码进行测试，而不是启动整个项目。 同时，在我们项目的维护过程中，难免会涉及到一些原有代码的修改，很有可能出现改了代码导致之前的功能出现问题（牵一发而动全身），而我们又不一定能立即察觉到，因此，我们可以提前保存一些测试用例，每次完成代码后都可以跑一遍测试用例，来确保之前的功能没有因为后续的修改而出现问题。 我们还可以利用单元测试来评估某个模块或是功能的耗时和性能，快速排查导致程序运行缓慢的问题，这些都可以通过单元测试来完成，可见单元测试对于开发的重要性。 尝试JUnit首先需要导入JUnit依赖，我们在这里使用Junit4进行介绍，最新的Junit5放到Maven板块一起讲解，Jar包已经放在视频下方简介中，直接去下载即可。同时IDEA需要安装JUnit插件（默认是已经捆绑安装的，因此无需多余配置） 现在我们创建一个新的类，来编写我们的单元测试用例： 1234567891011public class TestMain &#123; @Test public void method()&#123; System.out.println(&quot;我是测试用例1&quot;); &#125; @Test public void method2()&#123; System.out.println(&quot;我是测试用例2&quot;); &#125;&#125; 我们可以点击类前面的测试按钮，或是单个方法前的测试按钮，如果点击类前面的测试按钮，会执行所有的测试用例。 运行测试后，我们发现控制台得到了一个测试结果，显示为绿色表示测试通过。 只需要通过打上@Test注解，即可将一个方法标记为测试案例，我们可以直接运行此测试案例，但是我们编写的测试方法有以下要求： 方法必须是public的 不能是静态方法 返回值必须是void 必须是没有任何参数的方法 对于一个测试案例来说，我们肯定希望测试的结果是我们所期望的一个值，因此，如果测试的结果并不是我们所期望的结果，那么这个测试就应该没有成功通过！ 我们可以通过断言工具类来进行判定： 1234567public class TestMain &#123; @Test public void method()&#123; System.out.println(&quot;我是测试案例！&quot;); Assert.assertEquals(1, 2); //参数1是期盼值，参数2是实际测试结果值 &#125;&#125; 通过运行代码后，我们发现测试过程中抛出了一个错误，并且IDEA给我们显示了期盼结果和测试结果，那么现在我们来测试一个案例，比如我们想查看冒泡排序的编写是否正确： 1234567891011121314151617@Testpublic void method()&#123; int[] arr = &#123;0, 4, 5, 2, 6, 9, 3, 1, 7, 8&#125;; //错误的冒泡排序 for (int i = 0; i &lt; arr.length - 1; i++) &#123; for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123; if(arr[j] &gt; arr[j + 1])&#123; int tmp = arr[j]; arr[j] = arr[j+1]; // arr[j+1] = tmp; &#125; &#125; &#125; Assert.assertArrayEquals(new int[]&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;, arr);&#125; 通过测试，我们发现得到的结果并不是我们想要的结果，因此现在我们需要去修改为正确的冒泡排序，修改后，测试就能正确通过了。我们还可以再通过一个案例来更加深入地了解测试，现在我们想测试从数据库中取数据是否为我们预期的数据： 123456789@Testpublic void method()&#123; try (SqlSession sqlSession = MybatisUtil.getSession(true))&#123; TestMapper mapper = sqlSession.getMapper(TestMapper.class); Student student = mapper.getStudentBySidAndSex(1, &quot;男&quot;); Assert.assertEquals(new Student().setName(&quot;小明&quot;).setSex(&quot;男&quot;).setSid(1), student); &#125;&#125; 那么如果我们在进行所有的测试之前需要做一些前置操作该怎么办呢，一种办法是在所有的测试用例前面都加上前置操作，但是这样显然是很冗余的，因为一旦发生修改就需要挨个进行修改，因此我们需要更加智能的方法，我们可以通过@Before注解来添加测试用例开始之前的前置操作： 12345678910111213141516171819202122232425262728293031323334353637public class TestMain &#123; private SqlSessionFactory sqlSessionFactory; @Before public void before()&#123; System.out.println(&quot;测试前置正在初始化...&quot;); try &#123; sqlSessionFactory = new SqlSessionFactoryBuilder() .build(new FileInputStream(&quot;mybatis-config.xml&quot;)); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;测试初始化完成，正在开始测试案例...&quot;); &#125; @Test public void method1()&#123; try (SqlSession sqlSession = sqlSessionFactory.openSession(true))&#123; TestMapper mapper = sqlSession.getMapper(TestMapper.class); Student student = mapper.getStudentBySidAndSex(1, &quot;男&quot;); Assert.assertEquals(new Student().setName(&quot;小明&quot;).setSex(&quot;男&quot;).setSid(1), student); System.out.println(&quot;测试用例1通过！&quot;); &#125; &#125; @Test public void method2()&#123; try (SqlSession sqlSession = sqlSessionFactory.openSession(true))&#123; TestMapper mapper = sqlSession.getMapper(TestMapper.class); Student student = mapper.getStudentBySidAndSex(2, &quot;女&quot;); Assert.assertEquals(new Student().setName(&quot;小红&quot;).setSex(&quot;女&quot;).setSid(2), student); System.out.println(&quot;测试用例2通过！&quot;); &#125; &#125;&#125; 同理，在所有的测试完成之后，我们还想添加一个收尾的动作，那么只需要使用@After注解即可添加结束动作： 1234@Afterpublic void after()&#123; System.out.println(&quot;测试结束，收尾工作正在进行...&quot;);&#125; 有关JUnit的使用我们就暂时只介绍这么多。 JUL日志系统首先一问：我们为什么需要日志系统？ 我们之前一直都在使用System.out.println来打印信息，但是，如果项目中存在大量的控制台输出语句，会显得很凌乱，而且日志的粒度是不够细的，假如我们现在希望，项目只在debug的情况下打印某些日志，而在实际运行时不打印日志，采用直接输出的方式就很难实现了，因此我们需要使用日志框架来规范化日志输出。 而JDK为我们提供了一个自带的日志框架，位于java.util.logging包下，我们可以使用此框架来实现日志的规范化打印，使用起来非常简单： 12345678public class Main &#123; public static void main(String[] args) &#123; // 首先获取日志打印器 Logger logger = Logger.getLogger(Main.class.getName()); // 调用info来输出一个普通的信息，直接填写字符串即可 logger.info(&quot;我是普通的日志&quot;); &#125;&#125; 我们可以在主类中使用日志打印，得到日志的打印结果： 12十一月 15, 2021 12:55:37 下午 com.test.Main main信息: 我是普通的日志 我们发现，通过日志输出的结果会更加规范。 JUL日志讲解日志分为7个级别，详细信息我们可以在Level类中查看： SEVERE（最高值）- 一般用于代表严重错误 WARNING - 一般用于表示某些警告，但是不足以判断为错误 INFO （默认级别） - 常规消息 CONFIG FINE FINER FINEST（最低值） 我们之前通过info方法直接输出的结果就是使用的默认级别的日志，我们可以通过log方法来设定该条日志的输出级别： 1234567public static void main(String[] args) &#123; Logger logger = Logger.getLogger(Main.class.getName()); logger.log(Level.SEVERE, &quot;严重的错误&quot;, new IOException(&quot;我就是错误&quot;)); logger.log(Level.WARNING, &quot;警告的内容&quot;); logger.log(Level.INFO, &quot;普通的信息&quot;); logger.log(Level.CONFIG, &quot;级别低于普通信息&quot;);&#125; 我们发现，级别低于默认级别的日志信息，无法输出到控制台，我们可以通过设置来修改日志的打印级别： 1234567891011121314151617public static void main(String[] args) &#123; Logger logger = Logger.getLogger(Main.class.getName()); //修改日志级别 logger.setLevel(Level.CONFIG); //不使用父日志处理器 logger.setUseParentHandlers(false); //使用自定义日志处理器 ConsoleHandler handler = new ConsoleHandler(); handler.setLevel(Level.CONFIG); logger.addHandler(handler); logger.log(Level.SEVERE, &quot;严重的错误&quot;, new IOException(&quot;我就是错误&quot;)); logger.log(Level.WARNING, &quot;警告的内容&quot;); logger.log(Level.INFO, &quot;普通的信息&quot;); logger.log(Level.CONFIG, &quot;级别低于普通信息&quot;);&#125; 每个Logger都有一个父日志打印器，我们可以通过getParent()来获取： 1234public static void main(String[] args) throws IOException &#123; Logger logger = Logger.getLogger(Main.class.getName()); System.out.println(logger.getParent().getClass());&#125; 我们发现，得到的是java.util.logging.LogManager$RootLogger这个类，它默认使用的是ConsoleHandler，且日志级别为INFO，由于每一个日志打印器都会直接使用父类的处理器，因此我们之前需要关闭父类然后使用我们自己的处理器。 我们通过使用自己日志处理器来自定义级别的信息打印到控制台，当然，日志处理器不仅仅只有控制台打印，我们也可以使用文件处理器来处理日志信息，我们继续添加一个处理器： 1234//添加输出到本地文件FileHandler fileHandler = new FileHandler(&quot;test.log&quot;);fileHandler.setLevel(Level.WARNING);logger.addHandler(fileHandler); 注意，这个时候就有两个日志处理器了，因此控制台和文件的都会生效。如果日志的打印格式我们不喜欢，我们还可以自定义打印格式，比如我们控制台处理器就默认使用的是SimpleFormatter，而文件处理器则是使用的XMLFormatter，我们可以自定义： 12345//使用自定义日志处理器(控制台)ConsoleHandler handler = new ConsoleHandler();handler.setLevel(Level.CONFIG);handler.setFormatter(new XMLFormatter());logger.addHandler(handler); 我们可以直接配置为想要的打印格式，如果这些格式还不能满足你，那么我们也可以自行实现： 1234567891011121314151617181920212223242526272829303132public static void main(String[] args) throws IOException &#123; Logger logger = Logger.getLogger(Main.class.getName()); logger.setUseParentHandlers(false); //为了让颜色变回普通的颜色，通过代码块在初始化时将输出流设定为System.out ConsoleHandler handler = new ConsoleHandler()&#123;&#123; setOutputStream(System.out); &#125;&#125;; //创建匿名内部类实现自定义的格式 handler.setFormatter(new Formatter() &#123; @Override public String format(LogRecord record) &#123; SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;); String time = format.format(new Date(record.getMillis())); //格式化日志时间 String level = record.getLevel().getName(); // 获取日志级别名称 // String level = record.getLevel().getLocalizedName(); // 获取本地化名称（语言跟随系统） String thread = String.format(&quot;%10s&quot;, Thread.currentThread().getName()); //线程名称（做了格式化处理，留出10格空间） long threadID = record.getThreadID(); //线程ID String className = String.format(&quot;%-20s&quot;, record.getSourceClassName()); //发送日志的类名 String msg = record.getMessage(); //日志消息 //\\033[33m作为颜色代码，30~37都有对应的颜色，38是没有颜色，IDEA能显示，但是某些地方可能不支持 return &quot;\\033[38m&quot; + time + &quot; \\033[33m&quot; + level + &quot; \\033[35m&quot; + threadID + &quot;\\033[38m --- [&quot; + thread + &quot;] \\033[36m&quot; + className + &quot;\\033[38m : &quot; + msg + &quot;\\n&quot;; &#125; &#125;); logger.addHandler(handler); logger.info(&quot;我是测试消息1...&quot;); logger.log(Level.INFO, &quot;我是测试消息2...&quot;); logger.log(Level.WARNING, &quot;我是测试消息3...&quot;);&#125; 日志可以设置过滤器，如果我们不希望某些日志信息被输出，我们可以配置过滤规则： 12345678910public static void main(String[] args) throws IOException &#123; Logger logger = Logger.getLogger(Main.class.getName()); //自定义过滤规则 logger.setFilter(record -&gt; !record.getMessage().contains(&quot;普通&quot;)); logger.log(Level.SEVERE, &quot;严重的错误&quot;, new IOException(&quot;我就是错误&quot;)); logger.log(Level.WARNING, &quot;警告的内容&quot;); logger.log(Level.INFO, &quot;普通的信息&quot;);&#125; 实际上，整个日志的输出流程如下： Properties配置文件Properties文件是Java的一种配置文件，我们之前学习了XML，但是我们发现XML配置文件读取实在是太麻烦，那么能否有一种简单一点的配置文件呢？我们可以使用Properties文件： 12name=Testdesc=Description 该文件配置很简单，格式为配置项=配置值，我们可以直接通过Properties类来将其读取为一个类似于Map一样的对象： 12345public static void main(String[] args) throws IOException &#123; Properties properties = new Properties(); properties.load(new FileInputStream(&quot;test.properties&quot;)); System.out.println(properties);&#125; 我们发现，Properties类是继承自Hashtable，而Hashtable是实现的Map接口，也就是说，Properties本质上就是一个Map一样的结构，它会把所有的配置项映射为一个Map，这样我们就可以快速地读取对应配置的值了。 我们也可以将已经存在的Properties对象放入输出流进行保存，我们这里就不保存文件了，而是直接打印到控制台，我们只需要提供输出流即可： 1234567public static void main(String[] args) throws IOException &#123; Properties properties = new Properties(); // properties.setProperty(&quot;test&quot;, &quot;lbwnb&quot;); //和put效果一样 properties.put(&quot;test&quot;, &quot;lbwnb&quot;); properties.store(System.out, &quot;????&quot;); //properties.storeToXML(System.out, &quot;????&quot;); 保存为XML格式&#125; 我们可以通过System.getProperties()获取系统的参数，我们来看看： 123public static void main(String[] args) throws IOException &#123; System.getProperties().store(System.out, &quot;系统信息：&quot;);&#125; 编写日志配置文件我们可以通过进行配置文件来规定日志打印器的一些默认值： 1234# RootLogger 的默认处理器为handlers= java.util.logging.ConsoleHandler# RootLogger 的默认的日志级别.level= CONFIG 我们来尝试使用配置文件来进行配置： 123456789public static void main(String[] args) throws IOException &#123; //获取日志管理器 LogManager manager = LogManager.getLogManager(); //读取我们自己的配置文件 manager.readConfiguration(new FileInputStream(&quot;logging.properties&quot;)); //再获取日志打印器 Logger logger = Logger.getLogger(Main.class.getName()); logger.log(Level.CONFIG, &quot;我是一条日志信息&quot;); //通过自定义配置文件，我们发现默认级别不再是INFO了&#125; 我们也可以去修改ConsoleHandler的默认配置： 123456# 指定默认日志级别java.util.logging.ConsoleHandler.level = ALL# 指定默认日志消息格式java.util.logging.ConsoleHandler.formatter = java.util.logging.SimpleFormatter# 指定默认的字符集java.util.logging.ConsoleHandler.encoding = UTF-8 其实，我们阅读ConsoleHandler的源码就会发现，它就是通过读取配置文件来进行某些参数设置： 123456789101112131415161718192021// Private method to configure a ConsoleHandler from LogManager// properties and/or default values as specified in the class// javadoc.private void configure() &#123; LogManager manager = LogManager.getLogManager(); String cname = getClass().getName(); setLevel(manager.getLevelProperty(cname +&quot;.level&quot;, Level.INFO)); setFilter(manager.getFilterProperty(cname +&quot;.filter&quot;, null)); setFormatter(manager.getFormatterProperty(cname +&quot;.formatter&quot;, new SimpleFormatter())); try &#123; setEncoding(manager.getStringProperty(cname +&quot;.encoding&quot;, null)); &#125; catch (Exception ex) &#123; try &#123; setEncoding(null); &#125; catch (Exception ex2) &#123; // doing a setEncoding with null should always work. // assert false; &#125; &#125;&#125; 使用Lombok快速开启日志我们发现，如果我们现在需要全面使用日志系统，而不是传统的直接打印，那么就需要在每个类都去编写获取Logger的代码，这样显然是很冗余的，能否简化一下这个流程呢？ 前面我们学习了Lombok，我们也体会到Lombok给我们带来的便捷，我们可以通过一个注解快速生成构造方法、Getter和Setter，同样的，Logger也是可以使用Lombok快速生成的。 1234567@Logpublic class Main &#123; public static void main(String[] args) &#123; System.out.println(&quot;自动生成的Logger名称：&quot;+log.getName()); log.info(&quot;我是日志信息&quot;); &#125;&#125; 只需要添加一个@Log注解即可，添加后，我们可以直接使用一个静态变量log，而它就是自动生成的Logger。我们也可以手动指定名称： 1234567@Log(topic = &quot;打工是不可能打工的&quot;)public class Main &#123; public static void main(String[] args) &#123; System.out.println(&quot;自动生成的Logger名称：&quot;+log.getName()); log.info(&quot;我是日志信息&quot;); &#125;&#125; Mybatis日志系统Mybatis也有日志系统，它详细记录了所有的数据库操作等，但是我们在前面的学习中没有开启它，现在我们学习了日志之后，我们就可以尝试开启Mybatis的日志系统，来监控所有的数据库操作，要开启日志系统，我们需要进行配置： 1&lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot; /&gt; logImpl包括很多种配置项，包括 SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING，而默认情况下是未配置，也就是说不打印。我们这里将其设定为STDOUT_LOGGING表示直接使用标准输出将日志信息打印到控制台，我们编写一个测试案例来看看效果： 12345678910111213141516171819202122public class TestMain &#123; private SqlSessionFactory sqlSessionFactory; @Before public void before()&#123; try &#123; sqlSessionFactory = new SqlSessionFactoryBuilder() .build(new FileInputStream(&quot;mybatis-config.xml&quot;)); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; @Test public void test()&#123; try(SqlSession sqlSession = sqlSessionFactory.openSession(true))&#123; TestMapper mapper = sqlSession.getMapper(TestMapper.class); System.out.println(mapper.getStudentBySidAndSex(1, &quot;男&quot;)); System.out.println(mapper.getStudentBySidAndSex(1, &quot;男&quot;)); &#125; &#125;&#125; 我们发现，两次获取学生信息，只有第一次打开了数据库连接，而第二次并没有。 现在我们学习了日志系统，那么我们来尝试使用日志系统输出Mybatis的日志信息： 1&lt;setting name=&quot;logImpl&quot; value=&quot;JDK_LOGGING&quot; /&gt; 将其配置为JDK_LOGGING表示使用JUL进行日志打印，因为Mybatis的日志级别都比较低，因此我们需要设置一下logging.properties默认的日志级别： 123handlers= java.util.logging.ConsoleHandler.level= ALLjava.util.logging.ConsoleHandler.level = ALL 代码编写如下： 12345678910111213141516171819202122232425@Logpublic class TestMain &#123; private SqlSessionFactory sqlSessionFactory; @Before public void before()&#123; try &#123; sqlSessionFactory = new SqlSessionFactoryBuilder() .build(new FileInputStream(&quot;mybatis-config.xml&quot;)); LogManager manager = LogManager.getLogManager(); manager.readConfiguration(new FileInputStream(&quot;logging.properties&quot;)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Test public void test()&#123; try(SqlSession sqlSession = sqlSessionFactory.openSession(true))&#123; TestMapper mapper = sqlSession.getMapper(TestMapper.class); log.info(mapper.getStudentBySidAndSex(1, &quot;男&quot;).toString()); log.info(mapper.getStudentBySidAndSex(1, &quot;男&quot;).toString()); &#125; &#125;&#125; 但是我们发现，这样的日志信息根本没法看，因此我们需要修改一下日志的打印格式，我们自己创建一个格式化类： 12345678public class TestFormatter extends Formatter &#123; @Override public String format(LogRecord record) &#123; SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;); String time = format.format(new Date(record.getMillis())); //格式化日志时间 return time + &quot; : &quot; + record.getMessage() + &quot;\\n&quot;; &#125;&#125; 现在再来修改一下默认的格式化实现： 1234handlers= java.util.logging.ConsoleHandler.level= ALLjava.util.logging.ConsoleHandler.level = ALLjava.util.logging.ConsoleHandler.formatter = com.test.TestFormatter 现在就好看多了，当然，我们还可以继续为Mybatis添加文件日志，这里就不做演示了。 使用Maven管理项目**注意：**开始之前，看看你C盘空间够不够，最好预留2GB空间以上！ **吐槽：**很多电脑预装系统C盘都给得巨少，就算不装软件，一些软件的缓存文件也能给你塞满，建议有时间重装一下系统重新分配一下磁盘空间。 Maven 翻译为”专家”、”内行”，是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。Maven 也可被用于构建和管理各种项目，例如 C#，Ruby，Scala 和其他语言编写的项目。Maven 曾是 Jakarta 项目的子项目，现为由 Apache 软件基金会主持的独立 Apache 项目。 通过Maven，可以帮助我们做： 项目的自动构建，包括代码的编译、测试、打包、安装、部署等操作。 依赖管理，项目使用到哪些依赖，可以快速完成导入。 我们之前并没有讲解如何将我们的项目打包为Jar文件运行，同时，我们导入依赖的时候，每次都要去下载对应的Jar包，这样其实是很麻烦的，并且还有可能一个Jar包依赖于另一个Jar包，就像之前使用JUnit一样，因此我们需要一个更加方便的包管理机制。 Maven也需要安装环境，但是IDEA已经自带了Maven环境，因此我们不需要再去进行额外的环境安装（无IDEA也能使用Maven，但是配置过程很麻烦，并且我们现在使用的都是IDEA的集成开发环境，所以这里就不讲解Maven命令行操作了）我们直接创建一个新的Maven项目即可。 Maven项目结构我们可以来看一下，一个Maven项目和我们普通的项目有什么区别： 那么首先，我们需要了解一下POM文件，它相当于是我们整个Maven项目的配置文件，它也是使用XML编写的： 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;MavenTest&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt;&lt;/project&gt; 我们可以看到，Maven的配置文件是以project为根节点，而modelVersion定义了当前模型的版本，一般是4.0.0，我们不用去修改。 groupId、artifactId、version这三个元素合在一起，用于唯一区别每个项目，别人如果需要将我们编写的代码作为依赖，那么就必须通过这三个元素来定位我们的项目，我们称为一个项目的基本坐标，所有的项目一般都有自己的Maven坐标，因此我们通过Maven导入其他的依赖只需要填写这三个基本元素就可以了，无需再下载Jar文件，而是Maven自动帮助我们下载依赖并导入。 groupId 一般用于指定组名称，命名规则一般和包名一致，比如我们这里使用的是org.example，一个组下面可以有很多个项目。 artifactId 一般用于指定项目在当前组中的唯一名称，也就是说在组中用于区分于其他项目的标记。 version 代表项目版本，随着我们项目的开发和改进，版本号也会不断更新，就像LOL一样，每次赛季更新都会有一个大版本更新，我们的Maven项目也是这样，我们可以手动指定当前项目的版本号，其他人使用我们的项目作为依赖时，也可以根本版本号进行选择（这里的SNAPSHOT代表快照，一般表示这是一个处于开发中的项目，正式发布项目一般只带版本号） properties中一般都是一些变量和选项的配置，我们这里指定了JDK的源代码和编译版本为1.8，无需进行修改。 Maven依赖导入现在我们尝试使用Maven来帮助我们快速导入依赖，我们需要导入之前的JDBC驱动依赖、JUnit依赖、Mybatis依赖、Lombok依赖，那么如何使用Maven来管理依赖呢？ 我们可以创建一个dependencies节点： 123&lt;dependencies&gt; //里面填写的就是所有的依赖&lt;/dependencies&gt; 那么现在就可以向节点中填写依赖了，那么我们如何知道每个依赖的坐标呢？我们可以在：https://mvnrepository.com/ 进行查询（可能打不开，建议用流量，或是直接百度某个项目的Maven依赖），我们直接搜索lombok即可，打开后可以看到已经给我们写出了依赖的坐标： 123456&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.22&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 我们直接将其添加到dependencies节点中即可，现在我们来编写一个测试用例看看依赖导入成功了没有： 123456public class Main &#123; public static void main(String[] args) &#123; Student student = new Student(&quot;小明&quot;, 18); System.out.println(student); &#125;&#125; 123456@Data@AllArgsConstructorpublic class Student &#123; String name; int age;&#125; 项目运行成功，表示成功导入了依赖。那么，Maven是如何进行依赖管理呢，以致于如此便捷的导入依赖，我们来看看Maven项目的依赖管理流程： 通过流程图我们得知，一个项目依赖一般是存储在中央仓库中，也有可能存储在一些其他的远程仓库（私服），几乎所有的依赖都被放到了中央仓库中，因此，Maven可以直接从中央仓库中下载大部分的依赖（Maven第一次导入依赖是需要联网的），远程仓库中下载之后 ，会暂时存储在本地仓库，我们会发现我们本地存在一个.m2文件夹，这就是Maven本地仓库文件夹，默认建立在C盘，如果你C盘空间不足，会出现问题！ 在下次导入依赖时，如果Maven发现本地仓库中就已经存在某个依赖，那么就不会再去远程仓库下载了。 可能在导入依赖时，小小伙伴们会出现卡顿的问题，我们建议配置一下IDEA自带的Maven插件远程仓库地址，我们打开IDEA的安装目录，找到安装根目录/plugins/maven/lib/maven3/conf文件夹，找到settings.xml文件，打开编辑： 找到mirros标签，添加以下内容： 123456&lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;&lt;/mirror&gt; 这样，我们就将默认的远程仓库地址（国外），配置为国内的阿里云仓库地址了（依赖的下载速度就会快起来了） Maven依赖作用域除了三个基本的属性用于定位坐标外，依赖还可以添加以下属性： type：依赖的类型，对于项目坐标定义的packaging。大部分情况下，该元素不必声明，其默认值为jar scope：依赖的范围（作用域，着重讲解） optional：标记依赖是否可选 exclusions：用来排除传递性依赖（一个项目有可能依赖于其他项目，就像我们的项目，如果别人要用我们的项目作为依赖，那么就需要一起下载我们项目的依赖，如Lombok） 我们着重来讲解一下scope属性，它决定了依赖的作用域范围： compile ：为默认的依赖有效范围。如果在定义依赖关系的时候，没有明确指定依赖有效范围的话，则默认采用该依赖有效范围。此种依赖，在编译、运行、测试时均有效。 provided ：在编译、测试时有效，但是在运行时无效，也就是说，项目在运行时，不需要此依赖，比如我们上面的Lombok，我们只需要在编译阶段使用它，编译完成后，实际上已经转换为对应的代码了，因此Lombok不需要在项目运行时也存在。 runtime ：在运行、测试时有效，但是在编译代码时无效。比如我们如果需要自己写一个JDBC实现，那么肯定要用到JDK为我们指定的接口，但是实际上在运行时是不用自带JDK的依赖，因此只保留我们自己写的内容即可。 test ：只在测试时有效，例如：JUnit，我们一般只会在测试阶段使用JUnit，而实际项目运行时，我们就用不到测试了，那么我们来看看，导入JUnit的依赖： 同样的，我们可以在网站上搜索Junit的依赖，我们这里导入最新的JUnit5作为依赖： 123456&lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt; &lt;version&gt;5.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 我们所有的测试用例全部编写到Maven项目给我们划分的test目录下，位于此目录下的内容不会在最后被打包到项目中，只用作开发阶段测试使用： 123456789public class MainTest &#123; @Test public void test()&#123; System.out.println(&quot;测试&quot;); //Assert在JUnit5时名称发生了变化Assertions Assertions.assertArrayEquals(new int[]&#123;1, 2, 3&#125;, new int[]&#123;1, 2&#125;); &#125;&#125; 因此，一般仅用作测试的依赖如JUnit只保留在测试中即可，那么现在我们再来添加JDBC和Mybatis的依赖： 12345678910&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.27&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.7&lt;/version&gt;&lt;/dependency&gt; 我们发现，Maven还给我们提供了一个resource文件夹，我们可以将一些静态资源，比如配置文件，放入到这个文件夹中，项目在打包时会将资源文件夹中文件一起打包的Jar中，比如我们在这里编写一个Mybatis的配置文件： 1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;settings&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;JDK_LOGGING&quot; /&gt; &lt;/settings&gt; &lt;!-- 需要在environments的上方 --&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.test.entity&quot;/&gt; &lt;/typeAliases&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/study&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;test&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper class=&quot;com.test.mapper.TestMapper&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 现在我们创建一下测试用例，顺便带大家了解一下Junit5的一些比较方便的地方： 123456789101112131415161718192021222324public class MainTest &#123; //因为配置文件位于内部，我们需要使用Resources类的getResourceAsStream来获取内部的资源文件 private static SqlSessionFactory factory; //在JUnit5中@Before被废弃，它被细分了： @BeforeAll // 一次性开启所有测试案例只会执行一次 (方法必须是static) // @BeforeEach 一次性开启所有测试案例每个案例开始之前都会执行一次 @SneakyThrows public static void before()&#123; factory = new SqlSessionFactoryBuilder() .build(Resources.getResourceAsStream(&quot;mybatis.xml&quot;)); &#125; @DisplayName(&quot;Mybatis数据库测试&quot;) //自定义测试名称 @RepeatedTest(3) //自动执行多次测试 public void test()&#123; try (SqlSession sqlSession = factory.openSession(true))&#123; TestMapper testMapper = sqlSession.getMapper(TestMapper.class); System.out.println(testMapper.getStudentBySid(1)); &#125; &#125;&#125; 那么就有人提问了，如果我需要的依赖没有上传的远程仓库，而是只有一个Jar怎么办呢？我们可以使用第四种作用域： system：作用域和provided是一样的，但是它不是从远程仓库获取，而是直接导入本地Jar包： 1234567&lt;dependency&gt; &lt;groupId&gt;javax.jntm&lt;/groupId&gt; &lt;artifactId&gt;lbwnb&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;C://学习资料/4K高清无码/test.jar&lt;/systemPath&gt;&lt;/dependency&gt; 比如上面的例子，如果scope为system，那么我们需要添加一个systemPath来指定jar文件的位置，这里就不再演示了。 Maven可选依赖当项目中的某些依赖不希望被使用此项目作为依赖的项目使用时，我们可以给依赖添加optional标签表示此依赖是可选的，默认在导入依赖时，不会导入可选的依赖： 1&lt;optional&gt;true&lt;/optional&gt; 比如Mybatis的POM文件中，就存在大量的可选依赖： 12345678910111213141516171819&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.30&lt;/version&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.30&lt;/version&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; ... 由于Mybatis要支持多种类型的日志，需要用到很多种不同的日志框架，因此需要导入这些依赖来做兼容，但是我们项目中并不一定会使用这些日志框架作为Mybatis的日志打印器，因此这些日志框架仅Mybatis内部做兼容需要导入使用，而我们可以选择不使用这些框架或是选择其中一个即可，也就是说我们导入Mybatis之后想用什么日志框架再自己加就可以了。 Maven排除依赖我们了解了可选依赖，现在我们可以让使用此项目作为依赖的项目默认不使用可选依赖，但是如果存在那种不是可选依赖，但是我们导入此项目有不希望使用此依赖该怎么办呢，这个时候我们就可以通过排除依赖来防止添加不必要的依赖： 123456789101112&lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt; &lt;version&gt;5.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 我们这里演示了排除JUnit的一些依赖，我们可以在外部库中观察排除依赖之后和之前的效果。 Maven继承关系一个Maven项目可以继承自另一个Maven项目，比如多个子项目都需要父项目的依赖，我们就可以使用继承关系来快速配置。 我们右键左侧栏，新建一个模块，来创建一个子项目： 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;MavenTest&lt;/artifactId&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;ChildModel&lt;/artifactId&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt;&lt;/project&gt; 我们可以看到，IDEA默认给我们添加了一个parent节点，表示此Maven项目是父Maven项目的子项目，子项目直接继承父项目的groupId，子项目会直接继承父项目的所有依赖，除非依赖添加了optional标签，我们来编写一个测试用例尝试一下: 12345678import lombok.extern.java.Log;@Logpublic class Main &#123; public static void main(String[] args) &#123; log.info(&quot;我是日志信息&quot;); &#125;&#125; 可以看到，子项目也成功继承了Lombok依赖。 我们还可以让父Maven项目统一管理所有的依赖，包括版本号等，子项目可以选取需要的作为依赖，而版本全由父项目管理，我们可以将dependencies全部放入dependencyManagement节点，这样父项目就完全作为依赖统一管理。 1234567891011121314151617181920212223242526&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.22&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt; &lt;version&gt;5.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.27&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.7&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 我们发现，子项目的依赖失效了，因为现在父项目没有依赖，而是将所有的依赖进行集中管理，子项目需要什么再拿什么即可，同时子项目无需指定版本，所有的版本全部由父项目决定，子项目只需要使用即可： 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 当然，父项目如果还存在dependencies节点的话，里面的内依赖依然是直接继承： 123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt; &lt;version&gt;5.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; ... Maven常用命令我们可以看到在IDEA右上角Maven板块中，每个Maven项目都有一个生命周期，实际上这些是Maven的一些插件，每个插件都有各自的功能，比如： clean命令，执行后会清理整个target文件夹，在之后编写Springboot项目时可以解决一些缓存没更新的问题。 validate命令可以验证项目的可用性。 compile命令可以将项目编译为.class文件。 install命令可以将当前项目安装到本地仓库，以供其他项目导入作为依赖使用 verify命令可以按顺序执行每个默认生命周期阶段（validate，compile，package等） Maven测试项目通过使用test命令，可以一键测试所有位于test目录下的测试案例，请注意有以下要求： 测试类的名称必须是以Test结尾，比如MainTest 测试方法上必须标注@Test注解，实测@RepeatedTest无效 这是由于JUnit5比较新，我们需要重新配置插件升级到高版本，才能完美的兼容Junit5： 12345678910&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;!-- JUnit 5 requires Surefire version 2.22.0 or higher --&gt; &lt;version&gt;2.22.0&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 现在@RepeatedTest、@BeforeAll也能使用了。 Maven打包项目我们的项目在编写完成之后，要么作为Jar依赖，供其他模型使用，要么就作为一个可以执行的程序，在控制台运行，我们只需要直接执行package命令就可以直接对项目的代码进行打包，生成jar文件。 当然，以上方式仅适用于作为Jar依赖的情况，如果我们需要打包一个可执行文件，那么我不仅需要将自己编写的类打包到Jar中，同时还需要将依赖也一并打包到Jar中，因为我们使用了别人为我们通过的框架，自然也需要运行别人的代码，我们需要使用另一个插件来实现一起打包： 123456789101112131415161718192021222324&lt;plugin&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;configuration&gt; &lt;descriptorRefs&gt; &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt; &lt;/descriptorRefs&gt; &lt;archive&gt; &lt;manifest&gt; &lt;addClasspath&gt;true&lt;/addClasspath&gt; &lt;mainClass&gt;com.test.Main&lt;/mainClass&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;make-assembly&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;single&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 在打包之前也会执行一次test命令，来保证项目能够正常运行，当测试出现问题时，打包将无法完成，我们也可以手动跳过，选择执行Maven目标来手动执行Maven命令，输入mvn package -Dmaven.test.skip=true 来以跳过测试的方式进行打包。 最后得到我们的Jar文件，在同级目录下输入java -jar xxxx.jar来运行我们打包好的Jar可执行程序（xxx代表文件名称） deploy命令用于发布项目到本地仓库和远程仓库，一般情况下用不到，这里就不做讲解了。 site命令用于生成当前项目的发布站点，暂时不需要了解。 我们之前还讲解了多模块项目，那么多模块下父项目存在一个packing打包类型标签，所有的父级项目的packing都为pom，packing默认是jar类型，如果不作配置，maven会将该项目打成jar包。作为父级项目，还有一个重要的属性，那就是modules，通过modules标签将项目的所有子项目引用进来，在build父级项目时，会根据子模块的相互依赖关系整理一个build顺序，然后依次build。 实战：基于Mybatis+JUL+Lombok+Maven的图书管理系统（带单元测试）项目需求： 在线录入学生信息和书籍信息 查询书籍信息列表 查询学生信息列表 查询借阅信息列表 完整的日志系统","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"JavaWeb笔记","slug":"Java/JavaWeb笔记","permalink":"http://example.com/categories/Java/JavaWeb%E7%AC%94%E8%AE%B0/"}],"tags":[]}],"categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"JAVASE","slug":"Java/JAVASE","permalink":"http://example.com/categories/Java/JAVASE/"},{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Javascript","slug":"前端/Javascript","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/Javascript/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"},{"name":"C/C++","slug":"C-C","permalink":"http://example.com/categories/C-C/"},{"name":"Node.js","slug":"前端/Node-js","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/Node-js/"},{"name":"CSS","slug":"前端/CSS","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/CSS/"},{"name":"Springboot笔记","slug":"Java/Springboot笔记","permalink":"http://example.com/categories/Java/Springboot%E7%AC%94%E8%AE%B0/"},{"name":"JavaWeb笔记","slug":"Java/JavaWeb笔记","permalink":"http://example.com/categories/Java/JavaWeb%E7%AC%94%E8%AE%B0/"},{"name":"网站收藏","slug":"网站收藏","permalink":"http://example.com/categories/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/"},{"name":"编辑器","slug":"网站收藏/编辑器","permalink":"http://example.com/categories/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/%E7%BC%96%E8%BE%91%E5%99%A8/"},{"name":"前端","slug":"网站收藏/前端","permalink":"http://example.com/categories/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/%E5%89%8D%E7%AB%AF/"},{"name":"镜像站","slug":"网站收藏/镜像站","permalink":"http://example.com/categories/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/%E9%95%9C%E5%83%8F%E7%AB%99/"},{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"搜索与图论","slug":"算法/搜索与图论","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/"},{"name":"Docker","slug":"Docker","permalink":"http://example.com/categories/Docker/"},{"name":"环境配置","slug":"Java/环境配置","permalink":"http://example.com/categories/Java/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"name":"Java-GUi","slug":"Java/Java-GUi","permalink":"http://example.com/categories/Java/Java-GUi/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"},{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"javaweb","slug":"javaweb","permalink":"http://example.com/tags/javaweb/"}]}