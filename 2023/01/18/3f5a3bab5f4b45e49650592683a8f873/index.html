<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>JavaSE笔记（四） | 知识库</title><meta name="author" content="Public"><meta name="copyright" content="Public"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="referrer" content="no-referrer"><meta name="description" content="Java泛型与集合类在前面我们学习了最重要的类和对象，了解了面向对象编程的思想，注意，非常重要，面向对象是必须要深入理解和掌握的内容，不能草草结束。在本章节，我们会继续深入了解，从我们的泛型开始，再到我们的数据结构，最后再开始我们的集合类学习。 走进泛型为了统计学生成绩，要求设计一个Score对象，包括课程名称、课程号、课程成绩，但是成绩分为两种，一种是以优秀、良好、合格 来作为结果，还有一种就是">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaSE笔记（四）">
<meta property="og:url" content="http://example.com/2023/01/18/3f5a3bab5f4b45e49650592683a8f873/index.html">
<meta property="og:site_name" content="知识库">
<meta property="og:description" content="Java泛型与集合类在前面我们学习了最重要的类和对象，了解了面向对象编程的思想，注意，非常重要，面向对象是必须要深入理解和掌握的内容，不能草草结束。在本章节，我们会继续深入了解，从我们的泛型开始，再到我们的数据结构，最后再开始我们的集合类学习。 走进泛型为了统计学生成绩，要求设计一个Score对象，包括课程名称、课程号、课程成绩，但是成绩分为两种，一种是以优秀、良好、合格 来作为结果，还有一种就是">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://meowrain.cn/upload/2022/11/QQ%E5%9B%BE%E7%89%8720221127155827.jpg">
<meta property="article:published_time" content="2023-01-18T02:27:11.000Z">
<meta property="article:modified_time" content="2023-01-29T09:43:52.051Z">
<meta property="article:author" content="Public">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://meowrain.cn/upload/2022/11/QQ%E5%9B%BE%E7%89%8720221127155827.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/01/18/3f5a3bab5f4b45e49650592683a8f873/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JavaSE笔记（四）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-01-29 17:43:52'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><script>if (location.pathname.endsWith('/')) {location += 'index.html';}</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://meowrain.cn/upload/2022/11/QQ%E5%9B%BE%E7%89%8720221127155827.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">118</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">32</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="知识库"><span class="site-name">知识库</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">JavaSE笔记（四）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-18T02:27:11.000Z" title="发表于 2023-01-18 10:27:11">2023-01-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-29T09:43:52.051Z" title="更新于 2023-01-29 17:43:52">2023-01-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/JavaSE-%E7%AC%94%E8%AE%B0%EF%BC%88%E5%90%AB%E6%96%B0%E7%89%B9%E6%80%A7%E4%BB%8B%E7%BB%8D%EF%BC%89/">JavaSE 笔记（含新特性介绍）</a></span></div><div class="meta-secondline"></div></div></div><article class="post-content" id="article-container"><h1 id="Java泛型与集合类"><a href="#Java泛型与集合类" class="headerlink" title="Java泛型与集合类"></a>Java泛型与集合类</h1><p>在前面我们学习了最重要的类和对象，了解了面向对象编程的思想，注意，非常重要，面向对象是必须要深入理解和掌握的内容，不能草草结束。在本章节，我们会继续深入了解，从我们的泛型开始，再到我们的数据结构，最后再开始我们的集合类学习。</p>
<h2 id="走进泛型"><a href="#走进泛型" class="headerlink" title="走进泛型"></a>走进泛型</h2><p>为了统计学生成绩，要求设计一个Score对象，包括课程名称、课程号、课程成绩，但是成绩分为两种，一种是以<code>优秀、良好、合格</code> 来作为结果，还有一种就是 <code>60.0、75.5、92.5</code> 这样的数字分数，那么现在该如何去设计这样的一个Score类呢？现在的问题就是，成绩可能是<code>String</code>类型，也可能是<code>Integer</code>类型，如何才能很好的去存可能出现的两种类型呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Score</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    String id;</span><br><span class="line">    Object score;  <span class="comment">//因为Object是所有类型的父类，因此既可以存放Integer也能存放String</span></span><br><span class="line"></span><br><span class="line">  	<span class="keyword">public</span> <span class="title function_">Score</span><span class="params">(String name, String id, Object score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上的方法虽然很好地解决了多种类型存储问题，但是Object类型在编译阶段并不具有良好的类型判断能力，很容易出现以下的情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Score</span> <span class="variable">score</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Score</span>(<span class="string">&quot;数据结构与算法基础&quot;</span>, <span class="string">&quot;EP074512&quot;</span>, <span class="string">&quot;优秀&quot;</span>);  <span class="comment">//是String类型的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">number</span> <span class="operator">=</span> (Integer) score.score;  <span class="comment">//获取成绩需要进行强制类型转换，虽然并不是一开始的类型，但是编译不会报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行时出现异常！</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Integer</span><br><span class="line">	at com.test.Main.main(Main.java:<span class="number">14</span>)</span><br></pre></td></tr></table></figure>

<p>使用Object类型作为引用，取值只能进行强制类型转换，显然无法在编译期确定类型是否安全，项目中代码量非常之大，进行类型比较又会导致额外的开销和增加代码量，如果不经比较就很容易出现类型转换异常，代码的健壮性有所欠缺！（此方法虽然可行，但并不是最好的方法）</p>
<p>为了解决以上问题，JDK1.5新增了泛型，它能够在编译阶段就检查类型安全，大大提升开发效率。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Score</span>&lt;T&gt; &#123;   <span class="comment">//将Score转变为泛型类&lt;T&gt;</span></span><br><span class="line">    String name;</span><br><span class="line">    String id;</span><br><span class="line">    T score;  <span class="comment">//T为泛型，根据用户提供的类型自动变成对应类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Score</span><span class="params">(String name, String id, T score)</span> &#123;   <span class="comment">//提供的score类型即为T代表的类型</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//直接确定Score的类型是字符串类型的成绩</span></span><br><span class="line">    Score&lt;String&gt; score = <span class="keyword">new</span> <span class="title class_">Score</span>&lt;String&gt;(<span class="string">&quot;数据结构与算法基础&quot;</span>, <span class="string">&quot;EP074512&quot;</span>, <span class="string">&quot;优秀&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> score.score;  <span class="comment">//编译不通过，因为成员变量score类型被定为String！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型将数据类型的确定控制在了编译阶段，在编写代码的时候就能明确泛型的类型！如果类型不符合，将无法通过编译！</p>
<p>泛型本质上也是一个语法糖（并不是JVM所支持的语法，编译后会转成编译器支持的语法，比如之前的foreach就是），在编译后会被擦除，变回上面的Object类型调用，但是类型转换由编译器帮我们完成，而不是我们自己进行转换（安全）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反编译后的代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Score</span> <span class="variable">score</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Score</span>(<span class="string">&quot;数据结构与算法基础&quot;</span>, <span class="string">&quot;EP074512&quot;</span>, <span class="string">&quot;优秀&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">i</span> <span class="operator">=</span> (String)score.score;   <span class="comment">//其实依然会变为强制类型转换，但是这是由编译器帮我们完成的</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>像这样在编译后泛型的内容消失转变为Object的情况称为<code>类型擦除</code>（重要，需要完全理解），所以泛型只是为了方便我们在编译阶段确定类型的一种语法而已，并不是JVM所支持的。</p>
<p>综上，泛型其实就是一种类型参数，用于指定类型。</p>
<h2 id="泛型的使用"><a href="#泛型的使用" class="headerlink" title="泛型的使用"></a>泛型的使用</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>上一节我们已经提到泛型类的定义，实际上就是普通的类多了一个类型参数，也就是在使用时需要指定具体的泛型类型。泛型的名称一般取单个大写字母，比如T代表Type，也就是<code>类型</code>的英文单词首字母，当然也可以添加数字和其他的字符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Score</span>&lt;T&gt; &#123;   <span class="comment">//将Score转变为泛型类&lt;T&gt;</span></span><br><span class="line">    String name;</span><br><span class="line">    String id;</span><br><span class="line">    T score;  <span class="comment">//T为泛型，根据用户提供的类型自动变成对应类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Score</span><span class="params">(String name, String id, T score)</span> &#123;   <span class="comment">//提供的score类型即为T代表的类型</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在一个普通类型中定义泛型，泛型T称为<code>参数化类型</code>，在定义泛型类的引用时，需要明确指出类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Score&lt;String&gt; score = <span class="keyword">new</span> <span class="title class_">Score</span>&lt;String&gt;(<span class="string">&quot;数据结构与算法基础&quot;</span>, <span class="string">&quot;EP074512&quot;</span>, <span class="string">&quot;优秀&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>此时类中的泛型T已经被替换为String了，在我们获取此对象的泛型属性时，编译器会直接告诉我们类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> score.score;   <span class="comment">//编译不通过，因为成员变量score明确为String类型</span></span><br></pre></td></tr></table></figure>

<p>注意，泛型只能用于对象属性，也就是非静态的成员变量才能使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> T score;   <span class="comment">//错误，不能在静态成员上定义</span></span><br></pre></td></tr></table></figure>

<p>由此可见，泛型是只有在创建对象后编译器才能明确泛型类型，而静态类型是类所具有的属性，不足以使得编译器完成类型推断。</p>
<p>泛型无法使用基本类型，如果需要基本类型，只能使用基本类型的包装类进行替换！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Score&lt;<span class="type">double</span>&gt; score = <span class="keyword">new</span> <span class="title class_">Score</span>&lt;<span class="type">double</span>&gt;(<span class="string">&quot;数据结构与算法基础&quot;</span>, <span class="string">&quot;EP074512&quot;</span>, <span class="number">90.5</span>);  <span class="comment">//编译不通过</span></span><br></pre></td></tr></table></figure>

<p>那么为什么泛型无法使用基本类型呢？回想上一节提到的类型擦除，其实就很好理解了。由于JVM没有泛型概念，因此泛型最后还是会被编译器编译为Object，并采用强制类型转换的形式进行类型匹配，而我们的基本数据类型和引用类型之间无法进行类型转换，所以只能使用基本类型的包装类来处理。</p>
<h3 id="类的泛型方法"><a href="#类的泛型方法" class="headerlink" title="类的泛型方法"></a>类的泛型方法</h3><p>泛型方法的使用也很简单，我们只需要把它当做一个未知的类型来使用即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">getScore</span><span class="params">()</span> &#123;    <span class="comment">//若方法的返回值类型为泛型，那么编译器会自动进行推断</span></span><br><span class="line">  <span class="keyword">return</span> score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(T score)</span> &#123;   <span class="comment">//若方法的形式参数为泛型，那么实参只能是定义时的类型</span></span><br><span class="line">  <span class="built_in">this</span>.score = score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Score&lt;String&gt; score = <span class="keyword">new</span> <span class="title class_">Score</span>&lt;String&gt;(<span class="string">&quot;数据结构与算法基础&quot;</span>, <span class="string">&quot;EP074512&quot;</span>, <span class="string">&quot;优秀&quot;</span>);</span><br><span class="line">score.setScore(<span class="number">10</span>);   <span class="comment">//编译不通过，因为只接受String类型</span></span><br></pre></td></tr></table></figure>

<p>同样地，静态方法无法直接使用类定义的泛型（注意是无法直接使用，静态方法可以使用泛型）</p>
<h3 id="自定义泛型方法"><a href="#自定义泛型方法" class="headerlink" title="自定义泛型方法"></a>自定义泛型方法</h3><p>那么如果我想在静态方法中使用泛型呢？首先我们要明确之前为什么无法使用泛型，因为之前我们的泛型定义是在类上的，只有明确具体的类型才能开始使用，也就是创建对象时完成类型确定，但是静态方法不需要依附于对象，那么只能在使用时再来确定了，所以静态方法可以使用泛型，但是需要单独定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(E e)</span>&#123;   <span class="comment">//在方法定义前声明泛型</span></span><br><span class="line">  System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理，成员方法也能自行定义泛型，在实际使用时再进行类型确定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(E e)</span>&#123;</span><br><span class="line">  System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实，无论是泛型类还是泛型方法，再使用时一定要能够进行类型推断，明确类型才行。</p>
<p>注意一定要区分类定义的泛型和方法前定义的泛型！</p>
<h3 id="泛型引用"><a href="#泛型引用" class="headerlink" title="泛型引用"></a>泛型引用</h3><p>可以看到我们在定义一个泛型类的引用时，需要在后面指出此类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Score&lt;Integer&gt; score;  <span class="comment">//声明泛型为Integer类型</span></span><br></pre></td></tr></table></figure>

<p>如果不希望指定类型，或是希望此引用类型可以引用任意泛型的<code>Score</code>类对象，可以使用<code>?</code>通配符，来表示自动匹配任意的可用类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Score&lt;?&gt; score;   <span class="comment">//score可以引用任意的Score类型对象了！</span></span><br></pre></td></tr></table></figure>

<p>那么使用通配符之后，得到的泛型成员变量会是什么类型呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> score.getScore();   <span class="comment">//只能变为Object</span></span><br></pre></td></tr></table></figure>

<p>因为使用了通配符，编译器就无法进行类型推断，所以只能使用原始类型。</p>
<p>在学习了泛型的界限后，我们还会继续了解通配符的使用。</p>
<h3 id="泛型的界限"><a href="#泛型的界限" class="headerlink" title="泛型的界限"></a>泛型的界限</h3><p>现在有一个新的需求，现在没有String类型的成绩了，但是成绩依然可能是整数，也可能是小数，这时我们不希望用户将泛型指定为除数字类型外的其他类型，我们就需要使用到泛型的上界定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Score</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; &#123;   <span class="comment">//设定泛型上界，必须是Number的子类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line">    <span class="keyword">private</span> T score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Score</span><span class="params">(String name, String id, T score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getScore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>extends</code>关键字进行上界限定，只有指定类型或指定类型的子类才能作为类型参数。</p>
<p>同样的，泛型通配符也支持泛型的界限：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Score&lt;? <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; score;  <span class="comment">//限定为匹配Number及其子类的类型</span></span><br></pre></td></tr></table></figure>

<p>同理，既然泛型有上限，那么也有下限：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Score&lt;? <span class="built_in">super</span> Integer&gt; score;   <span class="comment">//限定为匹配Integer及其父类</span></span><br></pre></td></tr></table></figure>

<p>通过<code>super</code>关键字进行下界限定，只有指定类型或指定类型的父类才能作为类型参数。</p>
<p>图解如下：</p>
<p><img src="http://images4.10qianwan.com/10qianwan/20191209/b_0_201912091523263309.png" alt="png"></p>
<p><img src="http://images4.10qianwan.com/10qianwan/20191209/b_0_201912091523264595.jpg" alt="png"></p>
<p>那么限定了上界后，我们再来使用这个对象的泛型成员，会变成什么类型呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Score&lt;? <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; score = <span class="keyword">new</span> <span class="title class_">Score</span>&lt;&gt;(<span class="string">&quot;数据结构与算法基础&quot;</span>, <span class="string">&quot;EP074512&quot;</span>, <span class="number">10</span>);</span><br><span class="line"><span class="type">Number</span> <span class="variable">o</span> <span class="operator">=</span> score.getScore();    <span class="comment">//得到的结果为上界类型</span></span><br></pre></td></tr></table></figure>

<p>也就是说，一旦我们指定了上界后，编译器就将范围从原始类型<code>Object</code>提升到我们指定的上界<code>Number</code>，但是依然无法明确具体类型。思考：那如果定义下限呢？</p>
<p>那么既然我们可以给泛型类限定上界，现在我们来看编译后结果呢：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用javap -l 进行反编译</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">com</span>.test.Score&lt;T <span class="keyword">extends</span> <span class="title class_">java</span>.lang.Number&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> com.test.Score(java.lang.String, java.lang.String, T);</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">8</span>: <span class="number">0</span></span><br><span class="line">      line <span class="number">9</span>: <span class="number">4</span></span><br><span class="line">      line <span class="number">10</span>: <span class="number">9</span></span><br><span class="line">      line <span class="number">11</span>: <span class="number">14</span></span><br><span class="line">      line <span class="number">12</span>: <span class="number">19</span></span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          <span class="number">0</span>      <span class="number">20</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/test/Score;</span><br><span class="line">          <span class="number">0</span>      <span class="number">20</span>     <span class="number">1</span>  name   Ljava/lang/String;</span><br><span class="line">          <span class="number">0</span>      <span class="number">20</span>     <span class="number">2</span>    id   Ljava/lang/String;</span><br><span class="line">          <span class="number">0</span>      <span class="number">20</span>     <span class="number">3</span> score   Ljava/lang/Number;   <span class="comment">//可以看到score的类型直接被编译为Number类</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> T <span class="title function_">getScore</span><span class="params">()</span>;</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">15</span>: <span class="number">0</span></span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/test/Score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因此，一旦确立上限后，编译器会自动将类型提升到上限类型。</p>
<h3 id="钻石运算符"><a href="#钻石运算符" class="headerlink" title="钻石运算符"></a>钻石运算符</h3><p>我们发现，每次创建泛型对象都需要在前后都标明类型，但是实际上后面的类型声明是可以去掉的，因为我们在传入参数时或定义泛型类的引用时，就已经明确了类型，因此JDK1.7提供了钻石运算符来简化代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Score&lt;Integer&gt; score = <span class="keyword">new</span> <span class="title class_">Score</span>&lt;Integer&gt;(<span class="string">&quot;数据结构与算法基础&quot;</span>, <span class="string">&quot;EP074512&quot;</span>, <span class="number">10</span>);  <span class="comment">//1.7之前</span></span><br><span class="line"></span><br><span class="line">Score&lt;Integer&gt; score = <span class="keyword">new</span> <span class="title class_">Score</span>&lt;&gt;(<span class="string">&quot;数据结构与算法基础&quot;</span>, <span class="string">&quot;EP074512&quot;</span>, <span class="number">10</span>);  <span class="comment">//1.7之后</span></span><br></pre></td></tr></table></figure>

<h3 id="泛型与多态"><a href="#泛型与多态" class="headerlink" title="泛型与多态"></a>泛型与多态</h3><p>泛型不仅仅可以可以定义在类上，同时也能定义在接口上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ScoreInterface</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">getScore</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当实现此接口时，我们可以选择在实现类明确泛型类型或是继续使用此泛型，让具体创建的对象来确定类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Score</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">ScoreInterface</span>&lt;T&gt;&#123;   <span class="comment">//将Score转变为泛型类&lt;T&gt;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line">    <span class="keyword">private</span> T score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Score</span><span class="params">(String name, String id, T score)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getScore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(T score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringScore</span> <span class="keyword">implements</span> <span class="title class_">ScoreInterface</span>&lt;String&gt;&#123;   <span class="comment">//在实现时明确类型</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getScore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(String s)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象类同理，这里就不多做演示了。</p>
<h3 id="多态类型擦除"><a href="#多态类型擦除" class="headerlink" title="多态类型擦除"></a>多态类型擦除</h3><p>思考一个问题，既然继承后明确了泛型类型，那么为什么<code>@Override</code>不会出现错误呢，重写的条件是需要和父类的返回值类型、形式参数一致，而泛型默认的原始类型是Object类型，子类明确后变为Number类型，这显然不满足重写的条件，但是为什么依然能编译通过呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.t=t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&lt;Number&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> Number n;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Number <span class="title function_">get</span><span class="params">()</span>&#123;   <span class="comment">//这并不满足重写的要求，因为只能重写父类同样返回值和参数的方法，但是这样却能够通过编译！</span></span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(Number t)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.t=t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过反编译进行观察，实际上是编译器帮助我们生成了两个桥接方法用于支持重写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.get();<span class="comment">//调用返回Number的那个方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(Object t )</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.set((Number)t ); <span class="comment">//调用参数是Number的那个方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="数据结构基础"><a href="#数据结构基础" class="headerlink" title="数据结构基础"></a>数据结构基础</h2><p>警告！本章最难的部分！</p>
<p>学习集合类之前，我们还有最关键的内容需要学习，同第一章一样，自底向上才是最佳的学习方向，比起直接带大家认识集合类，不如先了解一下数据结构，只有了解了数据结构基础，才能更好地学习集合类，同时，数据结构也是你以后深入学习JDK源码的必备条件！（学习不要快餐式！）当然，我们主要是讲解Java，数据结构作为铺垫作用，所以我们只会讲解关键的部分，其他部分可以下去自行了解。</p>
<p>在计算机科学中，数据结构是一种数据组织、管理和存储的格式,它可以帮助我们实现对数据高效的访问和修改。更准确地说,数据结构是数据值的集合，可以体现数据值之间的关系，以及可以对数据进行应用的函数或操作。</p>
<p>通俗地说，我们需要去学习在计算机中如何去更好地管理我们的数据，才能让我们对我们的数据控制更加灵活！</p>
<h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3><p>线性表是最基本的一种数据结构，它是表示一组相同类型数据的有限序列，你可以把它与数组进行参考，但是它并不是数组，线性表是一种表结构，它能够支持数据的插入、删除、更新、查询等，同时数组可以随意存放在数组中任意位置，而线性表只能依次有序排列，不能出现空隙，因此，我们需要进一步的设计。</p>
<h4 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h4><p>将数据依次存储在连续的整块物理空间中，这种存储结构称为<code>顺序存储结构</code>，而以这种方式实现的线性表，我们称为<code>顺序表</code>。</p>
<p>同样的，表中的每一个个体都被称为<code>元素</code>，元素左边的元素（上一个元素），称为<code>前驱</code>，同理，右边的元素（后一个元素）称为<code>后驱</code>。</p>
<p><img src="https://img1.baidu.com/it/u=4003060195,523881164&fm=26&fmt=auto" alt="img"></p>
<p>我们设计线性表的目标就是为了去更好地管理我们的数据，也就是说，我们可以基于数组，来进行封装，实现增删改查！既然要存储一组数据，那么很容易联想到我们之前学过的数组，数组就能够容纳一组同类型的数据。</p>
<p>目标：以数组为底层，编写以下抽象类的具体实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线性表抽象类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;E&gt; 存储的元素(Element)类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractList</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取表的长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 顺序表的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 要添加的位置(索引)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e, <span class="type">int</span> index)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除指定位置的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定位置的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>数据分散的存储在物理空间中，通过一根线保存着它们之间的逻辑关系，这种存储结构称为<code>链式存储结构</code></p>
<p>实际上，就是每一个结点存放一个元素和一个指向下一个结点的引用（C语言里面是指针，Java中就是对象的引用，代表下一个结点对象）</p>
<p><img src="https://img1.baidu.com/it/u=3381038214,3369355034&fm=26&fmt=auto&gp=0.jpg" alt="img"></p>
<p>利用这种思想，我们再来尝试实现上面的抽象类，从实际的代码中感受！</p>
<p>比较：顺序表和链表的优异？</p>
<p>顺序表优缺点：</p>
<ul>
<li>访问速度快，随机访问性能高</li>
<li>插入和删除的效率低下，极端情况下需要变更整个表</li>
<li>不易扩充，需要复制并重新创建数组</li>
</ul>
<p>链表优缺点：</p>
<ul>
<li>插入和删除效率高，只需要改变连接点的指向即可</li>
<li>动态扩充容量，无需担心容量问题</li>
<li>访问元素需要依次寻找，随机访问元素效率低下</li>
</ul>
<p>链表只能指向后面，能不能指向前面呢？双向链表！</p>
<hr>
<p>栈和队列实际上就是对线性表加以约束的一种数据结构，如果前面的线性表的掌握已经ok，那么栈和队列就非常轻松了！</p>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>栈遵循先入后出原则，只能在线性表的一端添加和删除元素。我们可以把栈看做一个杯子，杯子只有一个口进出，最低处的元素只能等到上面的元素离开杯子后，才能离开。</p>
<p><img src="https://img2.baidu.com/it/u=4172728777,3669222584&fm=26&fmt=auto&gp=0.jpg" alt="img"></p>
<p>向栈中插入一个元素时，称为<code>入栈（压栈）</code>，移除栈顶元素称为<code>出栈</code>，我们需要尝试实现以下抽象类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象类型栈，待实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;E&gt; 元素类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStack</span>&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出栈操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 栈顶元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> E <span class="title function_">pop</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入栈操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(E e)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实，我们的JVM在处理方法调用时，也是一个栈操作：</p>
<p><img src="https://img0.baidu.com/it/u=1098322354,1667908648&fm=26&fmt=auto" alt="img"></p>
<p>所以说，如果玩不好递归，就会像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        go();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span>&#123;</span><br><span class="line">        go();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.StackOverflowError</span><br><span class="line">	at com.test.Main.go(Main.java:<span class="number">13</span>)</span><br><span class="line">	at com.test.Main.go(Main.java:<span class="number">13</span>)</span><br><span class="line">	at com.test.Main.go(Main.java:<span class="number">13</span>)</span><br><span class="line">	at com.test.Main.go(Main.java:<span class="number">13</span>)</span><br><span class="line">	at com.test.Main.go(Main.java:<span class="number">13</span>)</span><br><span class="line">	at com.test.Main.go(Main.java:<span class="number">13</span>)</span><br><span class="line">	at com.test.Main.go(Main.java:<span class="number">13</span>)</span><br><span class="line">	at com.test.Main.go(Main.java:<span class="number">13</span>)</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p>栈的深度是有限制的，如果达到限制，将会出现<code>StackOverflowError</code>错误（注意是错误！说明是JVM出现了问题）</p>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>队列同样也是受限制的线性表，不过队列就像我们排队一样，只能从队尾开始排，从队首出。</p>
<p><img src="https://img1.baidu.com/it/u=2682903513,371531599&fm=26&fmt=auto" alt="img"></p>
<p>所以我们要实现以下内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;E&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractQueue</span>&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进队操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">offer</span><span class="params">(E e)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出队操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> E <span class="title function_">poll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>本版块主要学习的是二叉树，树也是一种数据结构，但是它使用起来更加的复杂。</p>
<h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><p>我们前面已经学习过链表了，我们知道链表是单个结点之间相连，也就是一种一对一的关系，而树则是一个结点连接多个结点，也就是一对多的关系。</p>
<p><img src="https://img2.baidu.com/it/u=1603039729,2366298993&fm=26&fmt=auto" alt="img"></p>
<p>一个结点可以有N个子结点，就像上图一样，看起来就像是一棵树。而位于最顶端的结点（没有父结点）我们称为<code>根结点</code>，而结点拥有的子节点数量称为<code>度</code>，每向下一级称为一个<code>层次</code>，树中出现的最大层次称为树的<code>深度(高度)</code>。</p>
<h4 id="二叉树-1"><a href="#二叉树-1" class="headerlink" title="二叉树"></a>二叉树</h4><p>二叉树是一种特殊的树，每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点，位于两边的子结点称为左右子树（注意，左右子树是明确区分的，是左就是左，是右就是右）</p>
<p><img src="https://img1.baidu.com/it/u=4097712510,2021128931&fm=26&fmt=auto&gp=0.jpg" alt="img"></p>
<p>数学性质：</p>
<ul>
<li>在二叉树的第i层上最多有2^(i-1) 个节点。</li>
<li>二叉树中如果深度为k，那么最多有2^k-1个节点。</li>
</ul>
<p>设计一个二叉树结点类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> E e;   <span class="comment">//当前结点数据</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode&lt;E&gt; left;   <span class="comment">//左子树</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode&lt;E&gt; right;   <span class="comment">//右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><p>顺序表的遍历其实就是依次有序去访问表中每一个元素，而像二叉树这样的复杂结构，我们有四种遍历方式，他们是：前序遍历、中序遍历、后序遍历以及层序遍历，本版块我们主要讨论前三种遍历方式：</p>
<ul>
<li><strong>前序遍历</strong>：从二叉树的根结点出发，到达结点时就直接输出结点数据，按照先向左在向右的方向访问。ABCDEF</li>
<li><strong>中序遍历</strong>：从二叉树的根结点出发，优先输出左子树的节点的数据，再输出当前节点本身，最后才是右子树。CBDAEF</li>
<li><strong>后序遍历</strong>：从二叉树的根结点出发，优先遍历其左子树，再遍历右子树，最后在输出当前节点本身。CDBFEA</li>
</ul>
<h4 id="满二叉树和完全二叉树"><a href="#满二叉树和完全二叉树" class="headerlink" title="满二叉树和完全二叉树"></a>满二叉树和完全二叉树</h4><p>满二叉树和完全二叉树其实就是特殊情况下的二叉树，满二叉树左右的所有叶子节点都在同一层，也就是说，完全把每一个层级都给加满了结点。完全二叉树与满二叉树不同的地方在于，它的最下层叶子节点可以不满，但是最下层的叶子节点必须靠左排布。</p>
<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.examw.com%2Fncre%2FFiles%2F2011-6%2F20%2F93236613.gif&refer=http%3A%2F%2Fwww.examw.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1634373420&t=19f3ed8195b15d0b8f49201cc2803759" alt="img"></p>
<p>其实满二叉树和完全二叉树就是有一定规律的二叉树，很容易理解。</p>
<h3 id="快速查找"><a href="#快速查找" class="headerlink" title="快速查找"></a>快速查找</h3><p>我们之前提到的这些数据结构，很好地帮我们管理了数据，但是，如果需要查找某一个元素是否存在于数据结构中，如何才能更加高效的去完成呢？</p>
<h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>通过前面的学习，我们发现，顺序表虽然查询效率高，但是插入删除有严重表更新的问题，而链表虽然弥补了更新问题，但是查询效率实在是太低了，能否有一种折中方案？哈希表！</p>
<p>不知大家在之前的学习中是否发现，我们的Object类中，定义了一个叫做<code>hashcode()</code>的方法？而这个方法呢，就是为了更好地支持哈希表的实现。<code>hashcode()</code>默认得到的是对象的内存地址，也就是说，每个对象的hashCode都不一样。</p>
<p>哈希表，其实本质上就是一个存放链表的数组，那么它是如何去存储数据的呢？我们先来看看长啥样：</p>
<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2020.cnblogs.com%2Fblog%2F2127470%2F202012%2F2127470-20201222194727385-1606433879.jpg&refer=http%3A%2F%2Fimg2020.cnblogs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1634376519&t=8cc6fc7a35e695cc5ba12687974daa54" alt="img"></p>
<p>数组中每一个元素都是一个头结点，用于保存数据，那我们怎么确定数据应该放在哪一个位置呢？通过hash算法，我们能够瞬间得到元素应该放置的位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设hash表长度为16，hash算法为：</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span> hashcode)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> hashcode % <span class="number">16</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设想这样一个问题，如果计算出来的hash值和之前已经存在的元素相同了呢？这种情况我们称为<code>hash碰撞</code>，这也是为什么要将每一个表元素设置为一个链表的头结点的原因，一旦发现重复，我们可以往后继续添加节点。</p>
<p>当然，以上的hash表结构只是一种设计方案，在面对大额数据时，是不够用的，在JDK1.8中，集合类使用的是数组+二叉树的形式解决的（这里的二叉树是经过加强的二叉树，不是前面讲得简单二叉树，我们下一节就会开始讲）</p>
<h4 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h4><p>我们前面学习的二叉树效率是不够的，我们需要的是一种效率更高的二叉树，因此，基于二叉树的改进，提出了二叉查找树，可以看到结构像下面这样：</p>
<p><img src="https://img0.baidu.com/it/u=3674232536,1832030468&fm=26&fmt=auto&gp=0.jpg" alt="img"></p>
<p>不难发现，每个节点的左子树，一定小于当前节点的值，每个节点的右子树，一定大于当前节点的值，这样的二叉树称为<code>二叉排序树</code>。利用二分搜索的思想，我们就可以快速查找某个节点！</p>
<h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>在了解了二叉查找树之后，我们发现，如果根节点为10，现在加入到结点的值从9开始，依次减小到1，那么这个表就会很奇怪，就像下面这样：</p>
<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2F20191127151205330.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNDE5MTA1%2Csize_16%2Ccolor_FFFFFF%2Ct_70&refer=http%3A%2F%2Fimg-blog.csdnimg.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1634378465&t=eb9bf93cfb9191362d1170b93b06d902" alt="img"></p>
<p>显然，当所有的结点都排列到一边，这种情况下，查找效率会直接退化为最原始的二叉树！因此我们需要维持二叉树的平衡，才能维持原有的查找效率。</p>
<p>现在我们对二叉排序树加以约束，要求每个结点的左右两个子树的高度差的绝对值不超过1，这样的二叉树称为<code>平衡二叉树</code>，同时要求每个结点的左右子树都是平衡二叉树，这样，就不会因为一边的疯狂增加导致失衡。我们来看看以下几种情况：</p>
<p><img src="https://pic002.cnblogs.com/images/2012/214741/2012072218213884.png" alt="img"></p>
<p>左左失衡</p>
<p><img src="https://pic002.cnblogs.com/images/2012/214741/2012072218444051.png" alt="img"></p>
<p>右右失衡</p>
<p><img src="https://pic002.cnblogs.com/images/2012/214741/2012072219144367.png" alt="img"></p>
<p>左右失衡</p>
<p><img src="https://pic002.cnblogs.com/images/2012/214741/2012072219540371.png" alt="img"></p>
<p>右左失衡</p>
<p>通过以上四种情况的处理，最终得到维护平衡二叉树的算法。</p>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>红黑树也是二叉排序树的一种改进，同平衡二叉树一样，红黑树也是一种维护平衡的二叉排序树，但是没有平衡二叉树那样严格（平衡二叉树每次插入新结点时，可能会出现大量的旋转，而红黑树保证不超过三次），红黑树降低了对于旋转的要求，因此效率有一定的提升同时实现起来也更加简单。但是红黑树的效率却高于平衡二叉树，红黑树也是JDK1.8中使用的数据结构！</p>
<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2018.cnblogs.com%2Fblog%2F1301290%2F201904%2F1301290-20190418213139526-1239863354.jpg&refer=http%3A%2F%2Fimg2018.cnblogs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1634381313&t=d60b654d81ee3930b8518f194c976409" alt="img"></p>
<p>红黑树的特性:<br>（1）每个节点或者是黑色，或者是红色。<br>（2）根节点是黑色。<br>（3）每个叶子节点的两边也需要表示（虽然没有，但是null也需要表示出来）是黑色。<br>（4）如果一个节点是红色的，则它的子节点必须是黑色的。<br>（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</p>
<p>我们来看看一个节点，是如何插入到红黑树中的：</p>
<p>基本的 插入规则和平衡二叉树一样，但是在插入后：</p>
<ol>
<li>将新插入的节点标记为红色</li>
<li>如果 X 是根结点(root)，则标记为黑色</li>
<li>如果 X 的 parent 不是黑色，同时 X 也不是 root:</li>
</ol>
<ul>
<li><p>3.1 如果 X 的 uncle (叔叔) 是红色</p>
</li>
<li><ul>
<li>3.1.1 将 parent 和 uncle 标记为黑色</li>
<li>3.1.2 将 grand parent (祖父) 标记为红色</li>
<li>3.1.3 让 X 节点的颜色与 X 祖父的颜色相同，然后重复步骤 2、3</li>
</ul>
</li>
<li><p>3.2 如果 X 的 uncle (叔叔) 是黑色，我们要分四种情况处理</p>
</li>
<li><ul>
<li>3.2.1 左左 (P 是 G 的左孩子，并且 X 是 P 的左孩子)</li>
<li>3.2.2 左右 (P 是 G 的左孩子，并且 X 是 P 的右孩子)</li>
<li>3.2.3 右右 (P 是 G 的右孩子，并且 X 是 P 的右孩子)</li>
<li>3.2.4 右左 (P 是 G 的右孩子，并且 X 是 P 的左孩子)</li>
<li>其实这种情况下处理就和我们的平衡二叉树一样了</li>
</ul>
</li>
</ul>
<hr>
<h2 id="认识集合类"><a href="#认识集合类" class="headerlink" title="认识集合类"></a>认识集合类</h2><p>集合表示一组对象，称为其元素。一些集合允许重复的元素，而另一些则不允许。一些集合是有序的，而其他则是无序的。</p>
<p>集合类其实就是为了更好地组织、管理和操作我们的数据而存在的，包括列表、集合、队列、映射等数据结构。从这一块开始，我们会从源码角度给大家讲解（数据结构很重要！），不仅仅是教会大家如何去使用。</p>
<p>集合类最顶层不是抽象类而是接口，因为接口代表的是某个功能，而抽象类是已经快要成形的类型，不同的集合类的底层实现是不相同的，同时一个集合类可能会同时具有两种及以上功能（既能做队列也能做列表），所以采用接口会更加合适，接口只需定义支持的功能即可。</p>
<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.mianfeiwendang.com%2Fpic%2F29a5b61e9e5e19fe10103b4c%2F1-356-jpg_6_0_______-858-0-0-858.jpg&refer=http%3A%2F%2Fwww.mianfeiwendang.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1634434848&t=e696ab71af584ef08a38fc328956586c" alt="img"></p>
<h3 id="数组与集合"><a href="#数组与集合" class="headerlink" title="数组与集合"></a>数组与集合</h3><p>相同之处：</p>
<ol>
<li>它们都是容器，都能够容纳一组元素。</li>
</ol>
<p>不同之处：</p>
<ol>
<li>数组的大小是固定的，集合的大小是可变的。</li>
<li>数组可以存放基本数据类型，但集合只能存放对象。</li>
<li>数组存放的类型只能是一种，但集合可以有不同种类的元素。</li>
</ol>
<h3 id="集合根接口Collection"><a href="#集合根接口Collection" class="headerlink" title="集合根接口Collection"></a>集合根接口Collection</h3><p>本接口中定义了全部的集合基本操作，我们可以在源码中看看。</p>
<p>我们再来看看List和Set以及Queue接口。</p>
<h2 id="集合类的使用"><a href="#集合类的使用" class="headerlink" title="集合类的使用"></a>集合类的使用</h2><h3 id="List列表"><a href="#List列表" class="headerlink" title="List列表"></a>List列表</h3><p>首先介绍ArrayList，它的底层是用数组实现的，内部维护的是一个可改变大小的数组，也就是我们之前所说的线性表！跟我们之前自己写的ArrayList相比，它更加的规范，同时继承自List接口。</p>
<p>先看看ArrayList的源码！</p>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  <span class="comment">//默认长度的列表</span></span><br><span class="line">List&lt;String&gt; listInit = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">100</span>);  <span class="comment">//初始长度为100的列表</span></span><br></pre></td></tr></table></figure>

<p>向列表中添加元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;lbwnb&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;yyds&quot;</span>);</span><br><span class="line">list.contains(<span class="string">&quot;yyds&quot;</span>); <span class="comment">//是否包含某个元素</span></span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>

<p>移除元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;lbwnb&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;yyds&quot;</span>);</span><br><span class="line">    list.remove(<span class="number">0</span>);   <span class="comment">//按下标移除元素</span></span><br><span class="line">    list.remove(<span class="string">&quot;yyds&quot;</span>);    <span class="comment">//移除指定元素</span></span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也支持批量操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.addAll(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());   <span class="comment">//在尾部批量添加元素</span></span><br><span class="line">    list.removeAll(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());   <span class="comment">//批量移除元素（只有给定集合中存在的元素才会被移除）</span></span><br><span class="line">    list.retainAll(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());   <span class="comment">//只保留某些元素</span></span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再来看LinkedList，其实本质就是一个链表！我们来看看源码。</p>
<p>其实与我们之前编写的LinkedList不同之处在于，它内部使用的是一个双向链表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，我们发现它还实现了Queue接口，所以LinkedList也能被当做一个队列或是栈来使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    LinkedList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    list.offer(<span class="string">&quot;A&quot;</span>);   <span class="comment">//入队</span></span><br><span class="line">    System.out.println(list.poll());  <span class="comment">//出队</span></span><br><span class="line">    list.push(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    list.push(<span class="string">&quot;B&quot;</span>);    <span class="comment">//进栈</span></span><br><span class="line">    list.push(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">    System.out.println(list.pop());</span><br><span class="line">    System.out.println(list.pop());    <span class="comment">//出栈</span></span><br><span class="line">    System.out.println(list.pop());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="利用代码块来快速添加内容"><a href="#利用代码块来快速添加内容" class="headerlink" title="利用代码块来快速添加内容"></a>利用代码块来快速添加内容</h4><p>前面我们学习了匿名内部类，我们就可以利用代码块，来快速生成一个自带元素的List</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;()&#123;&#123;    <span class="comment">//初始化时添加</span></span><br><span class="line">  <span class="built_in">this</span>.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">  <span class="built_in">this</span>.add(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">&#125;&#125;;</span><br></pre></td></tr></table></figure>

<p>如果是需要快速生成一个只读的List，后面我们会讲解Arrays工具类。</p>
<h4 id="集合的排序"><a href="#集合的排序" class="headerlink" title="集合的排序"></a>集合的排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;()&#123;   <span class="comment">//Java9才支持匿名内部类使用钻石运算符</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.add(<span class="number">10</span>);</span><br><span class="line">        <span class="built_in">this</span>.add(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">this</span>.add(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">this</span>.add(<span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">list.sort((a, b) -&gt; &#123;    <span class="comment">//排序已经由JDK实现，现在只需要填入自定义规则，完成Comparator接口实现</span></span><br><span class="line">  <span class="keyword">return</span> a - b;    <span class="comment">//返回值小于0，表示a应该在b前面，返回值大于0，表示b应该在a后面，等于0则不进行交换</span></span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>

<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><h4 id="集合的遍历"><a href="#集合的遍历" class="headerlink" title="集合的遍历"></a>集合的遍历</h4><p>所有的集合类，都支持foreach循环！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;()&#123;   <span class="comment">//Java9才支持匿名内部类使用钻石运算符</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">this</span>.add(<span class="number">10</span>);</span><br><span class="line">            <span class="built_in">this</span>.add(<span class="number">2</span>);</span><br><span class="line">            <span class="built_in">this</span>.add(<span class="number">5</span>);</span><br><span class="line">            <span class="built_in">this</span>.add(<span class="number">8</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">        System.out.println(integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，也可以使用JDK1.8新增的forEach方法，它接受一个Consumer接口实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.forEach(i -&gt; &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>从JDK1.8开始，lambda表达式开始逐渐成为主流，我们需要去适应函数式编程的这种语法，包括批量替换，也是用到了函数式接口来完成的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list.replaceAll((i) -&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(i == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">3</span>;   <span class="comment">//将所有的2替换为3</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> i;   <span class="comment">//不是2就不变</span></span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>

<h4 id="Iterable和Iterator接口"><a href="#Iterable和Iterator接口" class="headerlink" title="Iterable和Iterator接口"></a>Iterable和Iterator接口</h4><p>我们之前学习数据结构时，已经得知，不同的线性表实现，在获取元素时的效率也不同，因此我们需要一种更好地方式来统一不同数据结构的遍历。</p>
<p>由于ArrayList对于随机访问的速度更快，而LinkedList对于顺序访问的速度更快，因此在上述的传统for循环遍历操作中，ArrayList的效率更胜一筹，因此我们要使得LinkedList遍历效率提升，就需要采用顺序访问的方式进行遍历，如果没有迭代器帮助我们统一标准，那么我们在应对多种集合类型的时候，就需要对应编写不同的遍历算法，很显然这样会降低我们的开发效率，而迭代器的出现就帮助我们解决了这个问题。</p>
<p>我们先来看看迭代器里面方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个集合类都有自己的迭代器，通过<code>iterator()</code>方法来获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; iterator = list.iterator();   <span class="comment">//生成一个新的迭代器</span></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;    <span class="comment">//判断是否还有下一个元素</span></span><br><span class="line">  <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> iterator.next();     <span class="comment">//获取下一个元素（获取一个少一个）</span></span><br><span class="line">  System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代器生成后，默认指向第一个元素，每次调用<code>next()</code>方法，都会将指针后移，当指针移动到最后一个元素之后，调用<code>hasNext()</code>将会返回<code>false</code>，迭代器是一次性的，用完即止，如果需要再次使用，需要调用<code>iterator()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ListIterator&lt;Integer&gt; iterator = list.listIterator();   <span class="comment">//List还有一个更好地迭代器实现ListIterator</span></span><br></pre></td></tr></table></figure>

<p><code>ListIterator</code>是List中独有的迭代器，在原有迭代器基础上新增了一些额外的操作。</p>
<hr>
<h3 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h3><p>我们之前已经看过<code>Set</code>接口的定义了，我们发现接口中定义的方法都是Collection中直接继承的，因此，Set支持的功能其实也就和Collection中定义的差不多，只不过使用方法上稍有不同。</p>
<p>Set集合特点：</p>
<ul>
<li>不允许出现重复元素</li>
<li>不支持随机访问（不允许通过下标访问）</li>
</ul>
<p>首先认识一下HashSet，它的底层就是采用哈希表实现的（我们在这里先不去探讨实现原理，因为底层实质上维护的是一个HashMap，我们学习了Map之后再来讨论）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    set.add(<span class="number">120</span>);    <span class="comment">//支持插入元素，但是不支持指定位置插入</span></span><br><span class="line">    set.add(<span class="number">13</span>);</span><br><span class="line">    set.add(<span class="number">11</span>);</span><br><span class="line">    <span class="keyword">for</span> (Integer integer : set) &#123;</span><br><span class="line">      System.out.println(integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面代码发现，最后Set集合中存在的元素顺序，并不是我们的插入顺序，这是因为HashSet底层是采用<code>哈希表</code>来实现的，实际的存放顺序是由Hash算法决定的。</p>
<p>那么我们希望数据按照我们插入的顺序进行保存该怎么办呢？我们可以使用LinkedHashSet：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    LinkedHashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();  <span class="comment">//会自动保存我们的插入顺序</span></span><br><span class="line">    set.add(<span class="number">120</span>);</span><br><span class="line">    set.add(<span class="number">13</span>);</span><br><span class="line">    set.add(<span class="number">11</span>);</span><br><span class="line">    <span class="keyword">for</span> (Integer integer : set) &#123;</span><br><span class="line">        System.out.println(integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LinkedHashSet底层维护的不再是一个HashMap，而是LinkedHashMap，它能够在插入数据时利用链表自动维护顺序，因此这样就能够保证我们插入顺序和最后的迭代顺序一致了。</p>
<p>还有一种Set叫做TreeSet，它会在元素插入时进行排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">    set.add(<span class="number">1</span>);</span><br><span class="line">    set.add(<span class="number">3</span>);</span><br><span class="line">    set.add(<span class="number">2</span>);</span><br><span class="line">    System.out.println(set);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到最后得到的结果并不是我们插入顺序，而是按照数字的大小进行排列。当然，我们也可以自定义排序规则：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;((a, b) -&gt; b - a);   <span class="comment">//在创建对象时指定规则即可</span></span><br><span class="line">    set.add(<span class="number">1</span>);</span><br><span class="line">    set.add(<span class="number">3</span>);</span><br><span class="line">    set.add(<span class="number">2</span>);</span><br><span class="line">    System.out.println(set);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在的结果就是我们自定义的排序规则了。</p>
<p>虽然Set集合只是粗略的进行了讲解，但是学习Map之后，我们还会回来看我们Set的底层实现，所以说最重要的还是Map。本节只需要记住Set的性质、使用即可。</p>
<hr>
<h3 id="Map映射"><a href="#Map映射" class="headerlink" title="Map映射"></a>Map映射</h3><h4 id="什么是映射"><a href="#什么是映射" class="headerlink" title="什么是映射"></a>什么是映射</h4><p>我们在高中阶段其实已经学习过映射了，映射指两个元素的之间相互“对应”的关系，也就是说，我们的元素之间是两两对应的，是以键值对的形式存在。</p>
<p><img src="https://bkimg.cdn.bcebos.com/pic/7aec54e736d12f2e89cbcbb64dc2d5628435681d?x-bce-process=image/resize,m_lfit,w_268,limit_1/format,f_jpg" alt="映射"></p>
<h4 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h4><p>Map就是为了实现这种数据结构而存在的，我们通过保存键值对的形式来存储映射关系。</p>
<p>我们先来看看Map接口中定义了哪些操作。</p>
<h4 id="HashMap和LinkedHashMap"><a href="#HashMap和LinkedHashMap" class="headerlink" title="HashMap和LinkedHashMap"></a>HashMap和LinkedHashMap</h4><p>HashMap的实现过程，相比List，就非常地复杂了，它并不是简简单单的表结构，而是利用哈希表存放映射关系，我们来看看HashMap是如何实现的，首先回顾我们之前学习的哈希表，它长这样：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/16566539-672ab962ae6dc500.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/508/format/webp" alt="img"></p>
<p>哈希表的本质其实就是一个用于存放后续节点的头结点的数组，数组里面的每一个元素都是一个头结点（也可以说就是一个链表），当要新插入一个数据时，会先计算该数据的哈希值，找到数组下标，然后创建一个新的节点，添加到对应的链表后面。</p>
<p>而HashMap就是采用的这种方式，我们可以看到源码中同样定义了这样的一个结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment"> * necessary. When allocated, length is always a power of two.</span></span><br><span class="line"><span class="comment"> * (We also tolerate length zero in some operations to allow</span></span><br><span class="line"><span class="comment"> * bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>

<p>这个表会在第一次使用时初始化，同时在必要时进行扩容，并且它的大小永远是2的倍数！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br></pre></td></tr></table></figure>

<p>我们可以看到默认的大小为2的4次方，每次都需要是2的倍数，也就是说，下一次增长之后，大小会变成2的5次方。</p>
<p>我们现在需要思考一个问题，当我们表中的数据不断增加之后，链表会变得越来越长，这样会严重导致查询速度变慢，首先想到办法就是，我们可以对数组的长度进行扩容，来存放更多的链表，那么什么情况下会进行扩容呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor for the hash table.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br></pre></td></tr></table></figure>

<p>我们还发现HashMap源码中有这样一个变量，也就是<code>负载因子</code>，那么它是干嘛的呢？</p>
<p>负载因子其实就是用来衡量当前情况是否需要进行扩容的标准。我们可以看到默认的负载因子是<code>0.75</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure>

<p>那么负载因子是怎么控制扩容的呢？<code>0.75</code>的意思是，在插入新的结点后，如果当前数组的占用率达到75%则进行扩容。在扩容时，会将所有的数据，重新计算哈希值，得到一个新的下标，组成新的哈希表。</p>
<p>但是这样依然有一个问题，链表过长的情况还是有可能发生，所以，为了从根源上解决这个问题，在JDK1.8时，引入了红黑树这个数据结构。</p>
<p><img src="https://i0.hdslb.com/bfs/album/5884577601a5ab1aabe10ee95696557b8d3b5338.jpg"></p>
<p>当链表的长度达到8时，会自动将链表转换为红黑树，这样能使得原有的查询效率大幅度降低！当使用红黑树之后，我们就可以利用二分搜索的思想，快速地去寻找我们想要的结果，而不是像链表一样挨个去看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn</span></span><br><span class="line"><span class="comment"> * extends Node) so can be used as extension of either regular or</span></span><br><span class="line"><span class="comment"> * linked node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt; &#123;</span><br></pre></td></tr></table></figure>

<p>除了Node以外，HashMap还有TreeNode，很明显这就是为了实现红黑树而设计的内部类。不过我们发现，TreeNode并不是直接继承Node，而是使用了LinkedHashMap中的Entry实现，它保存了前后节点的顺序（也就是我们的插入顺序）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashMap.Node subclass for normal LinkedHashMap entries.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Node&lt;K,V&gt; &#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LinkedHashMap是直接继承自HashMap，具有HashMap的全部性质，同时得益于每一个节点都是一个双向链表，保存了插入顺序，这样我们在遍历LinkedHashMap时，顺序就同我们的插入顺序一致。当然，也可以使用访问顺序，也就是说对于刚访问过的元素，会被排到最后一位。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    LinkedHashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(<span class="number">16</span>, <span class="number">0.75f</span>, <span class="literal">true</span>);  <span class="comment">//以访问顺序</span></span><br><span class="line">    map.put(<span class="number">1</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">    map.put(<span class="number">2</span>, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">    map.put(<span class="number">3</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">    map.get(<span class="number">2</span>);</span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察结果，我们发现，刚访问的结果被排到了最后一位。</p>
<h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><p>TreeMap其实就是自动维护顺序的一种Map，就和我们前面提到的TreeSet一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The comparator used to maintain order in this tree map, or</span></span><br><span class="line"><span class="comment"> * null if it uses the natural ordering of its keys.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="built_in">super</span> K&gt; comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Node in the Tree.  Doubles as a means to pass key-value pairs back to</span></span><br><span class="line"><span class="comment">* user (see Map.Entry).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br></pre></td></tr></table></figure>

<p>我们发现它的内部直接维护了一个红黑树，就像它的名字一样，就是一个Tree，因为它默认就是有序的，所以说直接采用红黑树会更好。我们在创建时，直接给予一个比较规则即可。</p>
<h4 id="Map的使用"><a href="#Map的使用" class="headerlink" title="Map的使用"></a>Map的使用</h4><p>我们首先来看看Map的一些基本操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="number">1</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">    map.put(<span class="number">2</span>, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">    map.put(<span class="number">3</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">    System.out.println(map.get(<span class="number">1</span>));    <span class="comment">//获取Key为1的值</span></span><br><span class="line">    System.out.println(map.getOrDefault(<span class="number">0</span>, <span class="string">&quot;K&quot;</span>));  <span class="comment">//不存在就返回K</span></span><br><span class="line">   	map.remove(<span class="number">1</span>);   <span class="comment">//移除这个Key的键值对</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于Map并未实现迭代器接口，因此不支持foreach，但是JDK1.8为我们提供了forEach方法使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="number">1</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">    map.put(<span class="number">2</span>, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">    map.put(<span class="number">3</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">    map.forEach((k, v) -&gt; System.out.println(k+<span class="string">&quot;-&gt;&quot;</span>+v));</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;   <span class="comment">//也可以获取所有的Entry来foreach</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">      <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">      System.out.println(key+<span class="string">&quot; -&gt; &quot;</span>+value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以单独获取所有的值或者是键：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="number">1</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">    map.put(<span class="number">2</span>, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">    map.put(<span class="number">3</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">    System.out.println(map.keySet());   <span class="comment">//直接获取所有的key</span></span><br><span class="line">    System.out.println(map.values());   <span class="comment">//直接获取所有的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="再谈Set原理"><a href="#再谈Set原理" class="headerlink" title="再谈Set原理"></a>再谈Set原理</h4><p>通过观察HashSet的源码发现，HashSet几乎都在操作内部维护的一个HashMap，也就是说，HashSet只是一个表壳，而内部维护的HashMap才是灵魂！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>

<p>我们发现，在添加元素时，其实添加的是一个键为我们插入的元素，而值就是<code>PRESENT</code>常量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds the specified element to this set if it is not already present.</span></span><br><span class="line"><span class="comment"> * More formally, adds the specified element &lt;tt&gt;e&lt;/tt&gt; to this set if</span></span><br><span class="line"><span class="comment"> * this set contains no element &lt;tt&gt;e2&lt;/tt&gt; such that</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;(e==null&amp;nbsp;?&amp;nbsp;e2==null&amp;nbsp;:&amp;nbsp;e.equals(e2))&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> * If this set already contains the element, the call leaves the set</span></span><br><span class="line"><span class="comment"> * unchanged and returns &lt;tt&gt;false&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be added to this set</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this set did not already contain the specified</span></span><br><span class="line"><span class="comment"> * element</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察其他的方法，也几乎都是在用HashMap做事，所以说，HashSet利用了HashMap内部的数据结构，轻松地就实现了Set定义的全部功能！</p>
<p>再来看TreeSet，实际上用的就是我们的TreeMap：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The backing map.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br></pre></td></tr></table></figure>

<p>同理，这里就不多做阐述了。</p>
<h4 id="JDK1-8新增方法使用"><a href="#JDK1-8新增方法使用" class="headerlink" title="JDK1.8新增方法使用"></a>JDK1.8新增方法使用</h4><p>最后，我们再来看看JDK1.8中集合类新增的一些操作（之前没有提及的）首先来看看<code>compute</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="number">1</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">    map.put(<span class="number">2</span>, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">    map.compute(<span class="number">1</span>, (k, v) -&gt; &#123;   <span class="comment">//compute会将指定Key的值进行重新计算，若Key不存在，v会返回null</span></span><br><span class="line">        <span class="keyword">return</span> v+<span class="string">&quot;M&quot;</span>;     <span class="comment">//这里返回原来的value+M</span></span><br><span class="line">    &#125;);</span><br><span class="line">  	map.computeIfPresent(<span class="number">1</span>, (k, v) -&gt; &#123;   <span class="comment">//当Key存在时存在则计算并赋予新的值</span></span><br><span class="line">      <span class="keyword">return</span> v+<span class="string">&quot;M&quot;</span>;     <span class="comment">//这里返回原来的value+M</span></span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以使用<code>computeIfAbsent</code>，当不存在Key时，计算并将键值对放入Map</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="number">1</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">    map.put(<span class="number">2</span>, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">    map.computeIfAbsent(<span class="number">0</span>, (k) -&gt; &#123;   <span class="comment">//若不存在则计算并插入新的值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;M&quot;</span>;     <span class="comment">//这里返回M</span></span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>merge方法用于处理数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Student&gt; students = Arrays.asList(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;yoni&quot;</span>, <span class="string">&quot;English&quot;</span>, <span class="number">80</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;yoni&quot;</span>, <span class="string">&quot;Chiness&quot;</span>, <span class="number">98</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;yoni&quot;</span>, <span class="string">&quot;Math&quot;</span>, <span class="number">95</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;taohai.wang&quot;</span>, <span class="string">&quot;English&quot;</span>, <span class="number">50</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;taohai.wang&quot;</span>, <span class="string">&quot;Chiness&quot;</span>, <span class="number">72</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;taohai.wang&quot;</span>, <span class="string">&quot;Math&quot;</span>, <span class="number">41</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Seely&quot;</span>, <span class="string">&quot;English&quot;</span>, <span class="number">88</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Seely&quot;</span>, <span class="string">&quot;Chiness&quot;</span>, <span class="number">89</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Seely&quot;</span>, <span class="string">&quot;Math&quot;</span>, <span class="number">92</span>)</span><br><span class="line">    );</span><br><span class="line">    Map&lt;String, Integer&gt; scoreMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    students.forEach(student -&gt; scoreMap.merge(student.getName(), student.getScore(), Integer::sum));</span><br><span class="line">    scoreMap.forEach((k, v) -&gt; System.out.println(<span class="string">&quot;key:&quot;</span> + k + <span class="string">&quot;总分&quot;</span> + <span class="string">&quot;value:&quot;</span> + v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String type;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, String type, <span class="type">int</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="集合的嵌套"><a href="#集合的嵌套" class="headerlink" title="集合的嵌套"></a>集合的嵌套</h3><p>既然集合类型中的元素类型是泛型，那么能否嵌套存储呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Map&lt;String, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();   <span class="comment">//每一个映射都是 字符串&lt;-&gt;列表</span></span><br><span class="line">    map.put(<span class="string">&quot;卡布奇诺今犹在&quot;</span>, <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;());</span><br><span class="line">    map.put(<span class="string">&quot;不见当年倒茶人&quot;</span>, <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;());</span><br><span class="line">    System.out.println(map.keySet());</span><br><span class="line">    System.out.println(map.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过Key获取到对应的值后，就是一个列表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map.get(<span class="string">&quot;卡布奇诺今犹在&quot;</span>).add(<span class="number">10</span>);</span><br><span class="line">System.out.println(map.get(<span class="string">&quot;卡布奇诺今犹在&quot;</span>).get(<span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p>让套娃继续下去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Map&lt;Integer, Map&lt;Integer, Map&lt;Integer, String&gt;&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你也可以使用List来套娃别的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Map&lt;String, Set&lt;String&gt;&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="流Stream和Optional的使用"><a href="#流Stream和Optional的使用" class="headerlink" title="流Stream和Optional的使用"></a>流Stream和Optional的使用</h3><p>Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。</p>
<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fseo-1255598498.file.myqcloud.com%2Ffull%2F723b4e9e03e9f1cbd9078f60b265e3ddc8a582aa.jpg&refer=http%3A%2F%2Fseo-1255598498.file.myqcloud.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1634782830&t=8d9a60d60087bec5ce0d09b763eb3805" alt="img"></p>
<p>它看起来就像一个工厂的流水线一样！我们就可以把一个Stream当做流水线处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">//移除为B的元素</span></span><br><span class="line">  	Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            <span class="keyword">if</span>(iterator.next().equals(<span class="string">&quot;B&quot;</span>)) iterator.remove();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">//Stream操作</span></span><br><span class="line">    list = list     <span class="comment">//链式调用</span></span><br><span class="line">            .stream()    <span class="comment">//获取流</span></span><br><span class="line">            .filter(e -&gt; !e.equals(<span class="string">&quot;B&quot;</span>))   <span class="comment">//只允许所有不是B的元素通过流水线</span></span><br><span class="line">            .collect(Collectors.toList());   <span class="comment">//将流水线中的元素重新收集起来，变回List</span></span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能从上述例子中还不能感受到流处理带来的便捷，我们通过下面这个例子来感受一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="number">1</span>);</span><br><span class="line">    list.add(<span class="number">2</span>);</span><br><span class="line">    list.add(<span class="number">3</span>);</span><br><span class="line">  	list.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    list = list</span><br><span class="line">            .stream()</span><br><span class="line">      			.distinct()   <span class="comment">//去重（使用equals判断）</span></span><br><span class="line">            .sorted((a, b) -&gt; b - a)    <span class="comment">//进行倒序排列</span></span><br><span class="line">            .map(e -&gt; e+<span class="number">1</span>)    <span class="comment">//每个元素都要执行+1操作</span></span><br><span class="line">            .limit(<span class="number">2</span>)    <span class="comment">//只放行前两个元素</span></span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当遇到大量的复杂操作时，我们就可以使用Stream来快速编写代码，这样不仅代码量大幅度减少，而且逻辑也更加清晰明了（如果你学习过SQL的话，你会发现它更像一个Sql语句）</p>
<p><strong>注意</strong>：不能认为每一步是直接依次执行的！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">list = list</span><br><span class="line">        .stream()</span><br><span class="line">        .distinct()   <span class="comment">//断点</span></span><br><span class="line">        .sorted((a, b) -&gt; b - a)</span><br><span class="line">        .map(e -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;&gt;&gt;&gt; &quot;</span>+e);   <span class="comment">//断点</span></span><br><span class="line">            <span class="keyword">return</span> e+<span class="number">1</span>;</span><br><span class="line">        &#125;)</span><br><span class="line">        .limit(<span class="number">2</span>)   <span class="comment">//断点</span></span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line"><span class="comment">//实际上，stream会先记录每一步操作，而不是直接开始执行内容，当整个链式调用完成后，才会依次进行！</span></span><br></pre></td></tr></table></figure>

<p>接下来，我们用一堆随机数来进行更多流操作的演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();  <span class="comment">//Random是一个随机数工具类</span></span><br><span class="line">    random</span><br><span class="line">            .ints(-<span class="number">100</span>, <span class="number">100</span>)   <span class="comment">//生成-100~100之间的，随机int型数字（本质上是一个IntStream）</span></span><br><span class="line">            .limit(<span class="number">10</span>)   <span class="comment">//只获取前10个数字（这是一个无限制的流，如果不加以限制，将会无限进行下去！）</span></span><br><span class="line">            .filter(i -&gt; i &lt; <span class="number">0</span>)   <span class="comment">//只保留小于0的数字</span></span><br><span class="line">            .sorted()    <span class="comment">//默认从小到大排序</span></span><br><span class="line">            .forEach(System.out::println);   <span class="comment">//依次打印</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以生成一个统计实例来帮助我们快速进行统计：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();  <span class="comment">//Random是一个随机数工具类</span></span><br><span class="line">    <span class="type">IntSummaryStatistics</span> <span class="variable">statistics</span> <span class="operator">=</span> random</span><br><span class="line">            .ints(<span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">            .limit(<span class="number">100</span>)</span><br><span class="line">            .summaryStatistics();    <span class="comment">//获取语法统计实例</span></span><br><span class="line">    System.out.println(statistics.getMax());  <span class="comment">//快速获取最大值</span></span><br><span class="line">    System.out.println(statistics.getCount());  <span class="comment">//获取数量</span></span><br><span class="line">    System.out.println(statistics.getAverage());   <span class="comment">//获取平均值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>普通的List只需要一个方法就可以直接转换到方便好用的IntStream了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="number">1</span>);</span><br><span class="line">    list.add(<span class="number">1</span>);</span><br><span class="line">    list.add(<span class="number">2</span>);</span><br><span class="line">    list.add(<span class="number">3</span>);</span><br><span class="line">    list.add(<span class="number">4</span>);</span><br><span class="line">    list.stream()</span><br><span class="line">            .mapToInt(i -&gt; i)    <span class="comment">//将每一个元素映射为Integer类型（这里因为本来就是Integer）</span></span><br><span class="line">            .summaryStatistics();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还可以通过<code>flat</code>来对整个流进行进一步细分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;A,B&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;C,D&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;E,F&quot;</span>);   <span class="comment">//我们想让每一个元素通过,进行分割，变成独立的6个元素</span></span><br><span class="line">    list = list</span><br><span class="line">            .stream()    <span class="comment">//生成流</span></span><br><span class="line">            .flatMap(e -&gt; Arrays.stream(e.split(<span class="string">&quot;,&quot;</span>)))    <span class="comment">//分割字符串并生成新的流</span></span><br><span class="line">            .collect(Collectors.toList());   <span class="comment">//汇成新的List</span></span><br><span class="line">    System.out.println(list);   <span class="comment">//得到结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以只通过Stream来完成所有数字的和，使用<code>reduce</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="number">1</span>);</span><br><span class="line">    list.add(<span class="number">2</span>);</span><br><span class="line">    list.add(<span class="number">3</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> list</span><br><span class="line">            .stream()</span><br><span class="line">            .reduce((a, b) -&gt; a + b)   <span class="comment">//计算规则为：a是上一次计算的值，b是当前要计算的参数，这里是求和</span></span><br><span class="line">            .get();    <span class="comment">//我们发现得到的是一个Optional类实例，不是我们返回的类型，通过get方法返回得到的值</span></span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的例子，我们发现，Stream不喜欢直接给我们返回一个结果，而是通过Optinal的方式，那么什么是Optional呢？</p>
<p>Optional类是Java8为了解决null值判断问题，使用Optional类可以避免显式的null值判断（null的防御性检查），避免null导致的NPE（NullPointerException）。总而言之，就是对控制的一个判断，为了避免空指针异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(str != <span class="literal">null</span>)&#123;   <span class="comment">//当str不为空时添加元素到List中</span></span><br><span class="line">        list.add(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了Optional之后，我们就可以这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    Optional&lt;String&gt; optional = Optional.ofNullable(str);   <span class="comment">//转换为Optional</span></span><br><span class="line">    optional.ifPresent(System.out::println);  <span class="comment">//当存在时再执行方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就类似于Kotlin中的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str : <span class="title class_">String</span>? = <span class="literal">null</span></span><br><span class="line">str?.<span class="title function_">upperCase</span>()</span><br></pre></td></tr></table></figure>

<p>我们可以选择直接get或是当值为null时，获取备选值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Optional</span> <span class="variable">optional</span> <span class="operator">=</span> Optional.ofNullable(str);   <span class="comment">//转换为Optional（可空）</span></span><br><span class="line">    System.out.println(optional.orElse(<span class="string">&quot;lbwnb&quot;</span>));</span><br><span class="line"> 		<span class="comment">// System.out.println(optional.get());   这样会直接报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，Optional也支持过滤操作和映射操作，不过是对于单对象而言：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;A&quot;</span>;</span><br><span class="line">    <span class="type">Optional</span> <span class="variable">optional</span> <span class="operator">=</span> Optional.ofNullable(str);   <span class="comment">//转换为Optional（可空）</span></span><br><span class="line">    System.out.println(optional.filter(s -&gt; s.equals(<span class="string">&quot;B&quot;</span>)).get());   <span class="comment">//被过滤了，此时元素为null，获取时报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;A&quot;</span>;</span><br><span class="line">    <span class="type">Optional</span> <span class="variable">optional</span> <span class="operator">=</span> Optional.ofNullable(str);   <span class="comment">//转换为Optional（可空）</span></span><br><span class="line">    System.out.println(optional.map(s -&gt; s + <span class="string">&quot;A&quot;</span>).get());   <span class="comment">//在尾部追加一个A</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他操作自学了解。</p>
<h3 id="Arrays和Collections的使用"><a href="#Arrays和Collections的使用" class="headerlink" title="Arrays和Collections的使用"></a>Arrays和Collections的使用</h3><p>Arrays是一个用于操作数组的工具类，它给我们提供了大量的工具方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This class contains various methods for manipulating arrays (such as</span></span><br><span class="line"><span class="comment"> * sorting and searching). This class also contains a static factory</span></span><br><span class="line"><span class="comment"> * that allows arrays to be viewed as lists. &lt;- 注意，这句话很关键</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Josh Bloch</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Neal Gafter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> John Rose</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>  1.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Arrays</span> &#123;</span><br></pre></td></tr></table></figure>

<p>由于操作数组并不像集合那样方便，因此JDK提供了Arrays类来增强对数组操作，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    Arrays.sort(array);   <span class="comment">//直接进行排序（底层原理：进行判断，元素少使用插入排序，大量元素使用双轴快速/归并排序）</span></span><br><span class="line">    System.out.println(array);  <span class="comment">//由于int[]是一个对象类型，而数组默认是没有重写toString()方法，因此无法打印到想要的结果</span></span><br><span class="line">    System.out.println(Arrays.toString(array));  <span class="comment">//我们可以使用Arrays.toString()来像集合一样直接打印每一个元素出来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    Arrays.sort(array);</span><br><span class="line">    System.out.println(<span class="string">&quot;排序后的结果：&quot;</span>+Arrays.toString(array));</span><br><span class="line">    System.out.println(<span class="string">&quot;目标元素3位置为：&quot;</span>+Arrays.binarySearch(array, <span class="number">3</span>));  <span class="comment">//二分搜素，必须是已经排序好的数组！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    Arrays</span><br><span class="line">            .stream(array)    <span class="comment">//将数组转换为流进行操作</span></span><br><span class="line">            .sorted()</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="type">int</span>[] array2 = Arrays.copyOf(array, array.length);  <span class="comment">//复制一个一模一样的数组</span></span><br><span class="line">    System.out.println(Arrays.toString(array2));</span><br><span class="line"></span><br><span class="line">    System.out.println(Arrays.equals(array, array2));  <span class="comment">//比较两个数组是否值相同</span></span><br><span class="line"></span><br><span class="line">    Arrays.fill(array, <span class="number">0</span>);   <span class="comment">//将数组的所有值全部填充为指定值</span></span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">    Arrays.setAll(array2, i -&gt; array2[i] + <span class="number">2</span>);  <span class="comment">//依次计算每一个元素（注意i是下标位置）</span></span><br><span class="line">    System.out.println(Arrays.toString(array2));   <span class="comment">//这里计算让每个元素值+2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思考：当二维数组使用<code>Arrays.equals()</code>进行比较以及<code>Arrays.toString()</code>进行打印时，还会得到我们想要的结果吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Integer[][] array = &#123;&#123;<span class="number">1</span>, <span class="number">5</span>&#125;, &#123;<span class="number">2</span>, <span class="number">4</span>&#125;, &#123;<span class="number">7</span>, <span class="number">3</span>&#125;, &#123;<span class="number">6</span>&#125;&#125;;</span><br><span class="line">    Integer[][] array2 = &#123;&#123;<span class="number">1</span>, <span class="number">5</span>&#125;, &#123;<span class="number">2</span>, <span class="number">4</span>&#125;, &#123;<span class="number">7</span>, <span class="number">3</span>&#125;, &#123;<span class="number">6</span>&#125;&#125;;</span><br><span class="line">    System.out.println(Arrays.toString(array));    <span class="comment">//这样还会得到我们想要的结果吗？</span></span><br><span class="line">    System.out.println(Arrays.equals(array2, array));    <span class="comment">//这样还会得到true吗？</span></span><br><span class="line"></span><br><span class="line">    System.out.println(Arrays.deepToString(array));   <span class="comment">//使用deepToString就能到打印多维数组</span></span><br><span class="line">    System.out.println(Arrays.deepEquals(array2, array));   <span class="comment">//使用deepEquals就能比较多维数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，一开始提到的当做List进行操作呢？我们可以使用<code>Arrays.asList()</code>来将数组转换为一个 <strong>固定长度的List</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Integer[] array = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(array);   <span class="comment">//不支持基本类型数组，必须是对象类型数组</span></span><br><span class="line">    Arrays.asList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);  <span class="comment">//也可以逐个添加，因为是可变参数</span></span><br><span class="line"></span><br><span class="line">    list.add(<span class="number">1</span>);    <span class="comment">//此List实现是长度固定的，是Arrays内部单独实现的一个类型，因此不支持添加操作</span></span><br><span class="line">    list.remove(<span class="number">0</span>);   <span class="comment">//同理，也不支持移除</span></span><br><span class="line"></span><br><span class="line">    list.set(<span class="number">0</span>, <span class="number">8</span>);   <span class="comment">//直接设置指定下标的值就可以</span></span><br><span class="line">    list.sort(Comparator.reverseOrder());   <span class="comment">//也可以执行排序操作</span></span><br><span class="line">    System.out.println(list);   <span class="comment">//也可以像List那样直接打印</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文字游戏：<code>allows arrays to be viewed as lists</code>，实际上只是当做List使用，本质还是数组，因此数组的属性依然存在！因此如果要将数组快速转换为实际的List，可以像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Integer[] array = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(array));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过自行创建一个真正的ArrayList并在构造时将Arrays的List值传递。</p>
<p>既然数组操作都这么方便了，集合操作能不能也安排点高级的玩法呢？那必须的，JDK为我们准备的Collocations类就是专用于集合的工具类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Collections.max(list);</span><br><span class="line">    Collections.min(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，Collections提供的内容相比Arrays会更多，希望大家下去自行了解，这里就不多做介绍了。</p>
<hr>
<h2 id="集合类编程实战"><a href="#集合类编程实战" class="headerlink" title="集合类编程实战"></a>集合类编程实战</h2><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><p>1 &lt;- 3 &lt;- 5 &lt;- 7 &lt;- 9  转换为 1 &lt;- 3 &lt;- 5 &lt;- 7 &lt;- 9</p>
<p>现在有一个单链表，尝试将其所有节点倒序排列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">1</span>);</span><br><span class="line">        head.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">3</span>);</span><br><span class="line">        head.next.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">5</span>);</span><br><span class="line">        head.next.next.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">7</span>);</span><br><span class="line">        head.next.next.next.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">        head = reverse(head);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(head.value+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">reverse</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="comment">//在这里实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h3><p>现在知道二叉树的前序: GDAFEMHZ，以及中序: ADEFGHMZ，请根据已知信息还原这颗二叉树。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMTEwMTExNTE3NDcx?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<h3 id="实现计算器"><a href="#实现计算器" class="headerlink" title="实现计算器"></a>实现计算器</h3><p>实现一个计算器，要求输入一个计算公式（含加减乘除运算符，没有负数但是有小数），得到结果，比如输入：1+4*3&#x2F;1.321，得到结果为：2.2</p>
<h3 id="字符串匹配（KMP算法）"><a href="#字符串匹配（KMP算法）" class="headerlink" title="字符串匹配（KMP算法）"></a>字符串匹配（KMP算法）</h3><p>现在给定一个主字符串和一个子字符串，请判断主字符串是否包含子字符串，例如主字符串：ABCABCDHI，子字符串：ABCD，因此主字符串包含此子字符串；主字符串：ABCABCUISA，子字符串：ABCD，则不包含。</p>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/01/18/3cef651e6ab44cf49a9b3618d2d7f3e1/" title="Java关键字总结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java关键字总结</div></div></a></div><div class="next-post pull-right"><a href="/2023/01/18/7392825e88864ee1bdfc6c4922736eb6/" title="JavaSE笔记（一）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JavaSE笔记（一）</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">Java泛型与集合类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%B0%E8%BF%9B%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">走进泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.2.</span> <span class="toc-text">泛型的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-number">1.2.1.</span> <span class="toc-text">泛型类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.2.</span> <span class="toc-text">类的泛型方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.3.</span> <span class="toc-text">自定义泛型方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E5%BC%95%E7%94%A8"><span class="toc-number">1.2.4.</span> <span class="toc-text">泛型引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%95%8C%E9%99%90"><span class="toc-number">1.2.5.</span> <span class="toc-text">泛型的界限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%92%BB%E7%9F%B3%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.2.6.</span> <span class="toc-text">钻石运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E4%B8%8E%E5%A4%9A%E6%80%81"><span class="toc-number">1.2.7.</span> <span class="toc-text">泛型与多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="toc-number">1.2.8.</span> <span class="toc-text">多态类型擦除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80"><span class="toc-number">1.3.</span> <span class="toc-text">数据结构基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text">线性表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">顺序表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.3.2.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91-1"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">二叉树的遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">满二叉树和完全二叉树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%9F%A5%E6%89%BE"><span class="toc-number">1.3.3.</span> <span class="toc-text">快速查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">哈希表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">二叉排序树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">平衡二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">1.3.3.4.</span> <span class="toc-text">红黑树</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86%E9%9B%86%E5%90%88%E7%B1%BB"><span class="toc-number">1.4.</span> <span class="toc-text">认识集合类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%8E%E9%9B%86%E5%90%88"><span class="toc-number">1.4.1.</span> <span class="toc-text">数组与集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E6%A0%B9%E6%8E%A5%E5%8F%A3Collection"><span class="toc-number">1.4.2.</span> <span class="toc-text">集合根接口Collection</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.5.</span> <span class="toc-text">集合类的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E5%88%97%E8%A1%A8"><span class="toc-number">1.5.1.</span> <span class="toc-text">List列表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">基本操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E4%BB%A3%E7%A0%81%E5%9D%97%E6%9D%A5%E5%BF%AB%E9%80%9F%E6%B7%BB%E5%8A%A0%E5%86%85%E5%AE%B9"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">利用代码块来快速添加内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%9A%84%E6%8E%92%E5%BA%8F"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">集合的排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.5.2.</span> <span class="toc-text">迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">集合的遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Iterable%E5%92%8CIterator%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">Iterable和Iterator接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set%E9%9B%86%E5%90%88"><span class="toc-number">1.5.3.</span> <span class="toc-text">Set集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map%E6%98%A0%E5%B0%84"><span class="toc-number">1.5.4.</span> <span class="toc-text">Map映射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%98%A0%E5%B0%84"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">什么是映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Map%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">Map接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap%E5%92%8CLinkedHashMap"><span class="toc-number">1.5.4.3.</span> <span class="toc-text">HashMap和LinkedHashMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TreeMap"><span class="toc-number">1.5.4.4.</span> <span class="toc-text">TreeMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Map%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.5.4.5.</span> <span class="toc-text">Map的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%8D%E8%B0%88Set%E5%8E%9F%E7%90%86"><span class="toc-number">1.5.4.6.</span> <span class="toc-text">再谈Set原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK1-8%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8"><span class="toc-number">1.5.4.7.</span> <span class="toc-text">JDK1.8新增方法使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%9A%84%E5%B5%8C%E5%A5%97"><span class="toc-number">1.5.5.</span> <span class="toc-text">集合的嵌套</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81Stream%E5%92%8COptional%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.5.6.</span> <span class="toc-text">流Stream和Optional的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Arrays%E5%92%8CCollections%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.5.7.</span> <span class="toc-text">Arrays和Collections的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%B1%BB%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98"><span class="toc-number">1.6.</span> <span class="toc-text">集合类编程实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">1.6.1.</span> <span class="toc-text">反转链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.6.2.</span> <span class="toc-text">重建二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E5%99%A8"><span class="toc-number">1.6.3.</span> <span class="toc-text">实现计算器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%EF%BC%88KMP%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-number">1.6.4.</span> <span class="toc-text">字符串匹配（KMP算法）</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://meowrain.cn">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div></div></body></html>