<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>struct | 知识库</title><meta name="author" content="Public"><meta name="copyright" content="Public"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="referrer" content="no-referrer"><meta name="description" content="struct 结构简介C 语言内置的数据类型，除了最基本的几种原始类型，只有数组属于复合类型，可以同时包含多个值，但是只能包含相同类型的数据，实际使用中并不够用。 实际使用中，主要有下面两种情况，需要更灵活强大的复合类型。  复杂的物体需要使用多个变量描述，这些变量都是相关的，最好有某种机制将它们联系起来。 某些函数需要传入多个参数，如果一个个按照顺序传入，非常麻烦，最好能组合成一个复合结构传入。">
<meta property="og:type" content="article">
<meta property="og:title" content="struct">
<meta property="og:url" content="http://example.com/2023/02/02/a86312379ebb44c39fbda22a6eecf977/index.html">
<meta property="og:site_name" content="知识库">
<meta property="og:description" content="struct 结构简介C 语言内置的数据类型，除了最基本的几种原始类型，只有数组属于复合类型，可以同时包含多个值，但是只能包含相同类型的数据，实际使用中并不够用。 实际使用中，主要有下面两种情况，需要更灵活强大的复合类型。  复杂的物体需要使用多个变量描述，这些变量都是相关的，最好有某种机制将它们联系起来。 某些函数需要传入多个参数，如果一个个按照顺序传入，非常麻烦，最好能组合成一个复合结构传入。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://meowrain.cn/upload/2022/11/QQ%E5%9B%BE%E7%89%8720221127155827.jpg">
<meta property="article:published_time" content="2023-02-02T03:09:53.207Z">
<meta property="article:modified_time" content="2023-02-02T03:10:33.218Z">
<meta property="article:author" content="Public">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://meowrain.cn/upload/2022/11/QQ%E5%9B%BE%E7%89%8720221127155827.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/02/02/a86312379ebb44c39fbda22a6eecf977/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'struct',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-02 11:10:33'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><script>if (location.pathname.endsWith('/')) {location += 'index.html';}</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://meowrain.cn/upload/2022/11/QQ%E5%9B%BE%E7%89%8720221127155827.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">274</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">41</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="知识库"><span class="site-name">知识库</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">struct</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-02T03:09:53.207Z" title="发表于 2023-02-02 11:09:53">2023-02-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-02T03:10:33.218Z" title="更新于 2023-02-02 11:10:33">2023-02-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C-C/">C/C++</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C-C/wangdoc-c/">wangdoc-c</a></span></div><div class="meta-secondline"></div></div></div><article class="post-content" id="article-container"><h1 id="struct-结构"><a href="#struct-结构" class="headerlink" title="struct 结构"></a>struct 结构</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>C 语言内置的数据类型，除了最基本的几种原始类型，只有数组属于复合类型，可以同时包含多个值，但是只能包含相同类型的数据，实际使用中并不够用。</p>
<p>实际使用中，主要有下面两种情况，需要更灵活强大的复合类型。</p>
<ul>
<li>复杂的物体需要使用多个变量描述，这些变量都是相关的，最好有某种机制将它们联系起来。</li>
<li>某些函数需要传入多个参数，如果一个个按照顺序传入，非常麻烦，最好能组合成一个复合结构传入。</li>
</ul>
<p>为了解决这些问题，C 语言提供了<code>struct</code>关键字，允许自定义复合数据类型，将不同类型的值组合在一起。这样不仅为编程提供方便，也有利于增强代码的可读性。C 语言没有其他语言的对象（object）和类（class）的概念，struct 结构很大程度上提供了对象和类的功能。</p>
<p>下面是<code>struct</code>自定义数据类型的一个例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fraction</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> numerator;</span><br><span class="line">  <span class="type">int</span> denominator;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例定义了一个分数的数据类型<code>struct fraction</code>，包含两个属性<code>numerator</code>和<code>denominator</code>。</p>
<p>注意，作为一个自定义的数据类型，它的类型名要包括<code>struct</code>关键字，比如上例是<code>struct fraction</code>，单独的<code>fraction</code>没有任何意义，甚至脚本还可以另外定义名为<code>fraction</code>的变量，虽然这样很容易造成混淆。另外，<code>struct</code>语句结尾的分号不能省略，否则很容易产生错误。</p>
<p>定义了新的数据类型以后，就可以声明该类型的变量，这与声明其他类型变量的写法是一样的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fraction</span> <span class="title">f1</span>;</span></span><br><span class="line"></span><br><span class="line">f1.numerator = <span class="number">22</span>;</span><br><span class="line">f1.denominator = <span class="number">7</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，先声明了一个<code>struct fraction</code>类型的变量<code>f1</code>，这时编译器就会为<code>f1</code>分配内存，接着就可以为<code>f1</code>的不同属性赋值。可以看到，struct 结构的属性通过点（<code>.</code>）来表示，比如<code>numerator</code>属性要写成<code>f1.numerator</code>。</p>
<p>再提醒一下，声明自定义类型的变量时，类型名前面，不要忘记加上<code>struct</code>关键字。也就是说，必须使用<code>struct fraction f1</code>声明变量，不能写成<code>fraction f1</code>。</p>
<p>除了逐一对属性赋值，也可以使用大括号，一次性对 struct 结构的所有属性赋值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">car</span> &#123;</span></span><br><span class="line">  <span class="type">char</span>* name;</span><br><span class="line">  <span class="type">float</span> price;</span><br><span class="line">  <span class="type">int</span> speed;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">car</span> <span class="title">saturn</span> =</span> &#123;<span class="string">&quot;Saturn SL/2&quot;</span>, <span class="number">16000.99</span>, <span class="number">175</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>saturn</code>是<code>struct car</code>类型，大括号里面同时对它的三个属性赋值。如果大括号里面的值的数量，少于属性的数量，那么缺失的属性自动初始化为<code>0</code>。</p>
<p>注意，大括号里面的值的顺序，必须与 struct 类型声明时属性的顺序一致。否则，必须为每个值指定属性名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">car</span> <span class="title">saturn</span> =</span> &#123;.speed=<span class="number">172</span>, .name=<span class="string">&quot;Saturn SL/2&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，初始化的属性少于声明时的属性，这时剩下的那些属性都会初始化为<code>0</code>。</p>
<p>声明变量以后，可以修改某个属性的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">car</span> <span class="title">saturn</span> =</span> &#123;.speed=<span class="number">172</span>, .name=<span class="string">&quot;Saturn SL/2&quot;</span>&#125;;</span><br><span class="line">saturn.speed = <span class="number">168</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例将<code>speed</code>属性的值改成<code>168</code>。</p>
<p>struct 的数据类型声明语句与变量的声明语句，可以合并为一个语句。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> title[<span class="number">500</span>];</span><br><span class="line">  <span class="type">char</span> author[<span class="number">100</span>];</span><br><span class="line">  <span class="type">float</span> value;</span><br><span class="line">&#125; b1;</span><br></pre></td></tr></table></figure>

<p>上面的语句同时声明了数据类型<code>book</code>和该类型的变量<code>b1</code>。如果类型标识符<code>book</code>只用在这一个地方，后面不再用到，这里可以将类型名省略。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> title[<span class="number">500</span>];</span><br><span class="line">  <span class="type">char</span> author[<span class="number">100</span>];</span><br><span class="line">  <span class="type">float</span> value;</span><br><span class="line">&#125; b1;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>struct</code>声明了一个匿名数据类型，然后又声明了这个类型的变量<code>b1</code>。</p>
<p>与其他变量声明语句一样，可以在声明变量的同时，对变量赋值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> title[<span class="number">500</span>];</span><br><span class="line">  <span class="type">char</span> author[<span class="number">100</span>];</span><br><span class="line">  <span class="type">float</span> value;</span><br><span class="line">&#125; b1 = &#123;<span class="string">&quot;Harry Potter&quot;</span>, <span class="string">&quot;J. K. Rowling&quot;</span>, <span class="number">10.0</span>&#125;,</span><br><span class="line">  b2 = &#123;<span class="string">&quot;Cancer Ward&quot;</span>, <span class="string">&quot;Aleksandr Solzhenitsyn&quot;</span>, <span class="number">7.85</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，在声明变量<code>b1</code>和<code>b2</code>的同时，为它们赋值。</p>
<p>下一章介绍的<code>typedef</code>命令可以为 struct 结构指定一个别名，这样使用起来更简洁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cell_phone</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> cell_no;</span><br><span class="line">  <span class="type">float</span> minutes_of_charge;</span><br><span class="line">&#125; phone;</span><br><span class="line"></span><br><span class="line">phone p = &#123;<span class="number">5551234</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>phone</code>就是<code>struct cell_phone</code>的别名。</p>
<p>指针变量也可以指向<code>struct</code>结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> title[<span class="number">500</span>];</span><br><span class="line">  <span class="type">char</span> author[<span class="number">100</span>];</span><br><span class="line">  <span class="type">float</span> value;</span><br><span class="line">&#125;* b1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者写成两个语句</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> title[<span class="number">500</span>];</span><br><span class="line">  <span class="type">char</span> author[<span class="number">100</span>];</span><br><span class="line">  <span class="type">float</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span>* <span class="title">b1</span>;</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>b1</code>是一个指针，指向的数据是<code>struct book</code>类型的实例。</p>
<p>struct 结构也可以作为数组成员。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fraction</span> <span class="title">numbers</span>[1000];</span></span><br><span class="line"></span><br><span class="line">numbers[<span class="number">0</span>].numerator = <span class="number">22</span>;</span><br><span class="line">numbers[<span class="number">0</span>].denominator = <span class="number">7</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例声明了一个有1000个成员的数组<code>numbers</code>，每个成员都是自定义类型<code>fraction</code>的实例。</p>
<p>struct 结构占用的存储空间，不是各个属性存储空间的总和，而是最大内存占用属性的存储空间的倍数，其他属性会添加空位与之对齐。这样可以提高读写效率。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  <span class="type">char</span>* b;</span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> foo)); <span class="comment">// 24</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>struct foo</code>有三个属性，在64位计算机上占用的存储空间分别是：<code>int a</code>占4个字节，指针<code>char* b</code>占8个字节，<code>char c</code>占1个字节。它们加起来，一共是13个字节（4 + 8 + 1）。但是实际上，<code>struct foo</code>会占用24个字节，原因是它最大的内存占用属性是<code>char* b</code>的8个字节，导致其他属性的存储空间也是8个字节，这样才可以对齐，导致整个<code>struct foo</code>就是24个字节（8 * 3）。</p>
<p>多出来的存储空间，都采用空位填充，所以上面的<code>struct foo</code>真实的结构其实是下面这样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> a;        <span class="comment">// 4</span></span><br><span class="line">  <span class="type">char</span> pad1[<span class="number">4</span>]; <span class="comment">// 填充4字节</span></span><br><span class="line">  <span class="type">char</span> *b;      <span class="comment">// 8</span></span><br><span class="line">  <span class="type">char</span> c;       <span class="comment">// 1</span></span><br><span class="line">  <span class="type">char</span> pad2[<span class="number">7</span>]; <span class="comment">// 填充7字节</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> foo)); <span class="comment">// 24</span></span><br></pre></td></tr></table></figure>

<p>为什么浪费这么多空间进行内存对齐呢？这是为了加快读写速度，把内存占用划分成等长的区块，就可以快速在 Struct 结构体中定位到每个属性的起始地址。</p>
<p>由于这个特性，在有必要的情况下，定义 Struct 结构体时，可以采用存储空间递增的顺序，定义每个属性，这样就能节省一些空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  <span class="type">char</span>* b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> foo)); <span class="comment">// 16</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，占用空间最小的<code>char c</code>排在第一位，其次是<code>int a</code>，占用空间最大的<code>char* b</code>排在最后。整个<code>strct foo</code>的内存占用就从24字节下降到16字节。</p>
<h2 id="struct-的复制"><a href="#struct-的复制" class="headerlink" title="struct 的复制"></a>struct 的复制</h2><p>struct 变量可以使用赋值运算符（<code>=</code>），复制给另一个变量，这时会生成一个全新的副本。系统会分配一块新的内存空间，大小与原来的变量相同，把每个属性都复制过去，即原样生成了一份数据。这一点跟数组的复制不一样，务必小心。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cat</span> &#123;</span> <span class="type">char</span> name[<span class="number">30</span>]; <span class="type">short</span> age; &#125; a, b;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(a.name, <span class="string">&quot;Hula&quot;</span>);</span><br><span class="line">a.age = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">b = a;</span><br><span class="line">b.name[<span class="number">0</span>] = <span class="string">&#x27;M&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, a.name); <span class="comment">// Hula</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, b.name); <span class="comment">// Mula</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，变量<code>b</code>是变量<code>a</code>的副本，两个变量的值是各自独立的，修改掉<code>b.name</code>不影响<code>a.name</code>。</p>
<p>上面这个示例是有前提的，就是 struct 结构的属性必须定义成字符数组，才能复制数据。如果稍作修改，属性定义成字符指针，结果就不一样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cat</span> &#123;</span> <span class="type">char</span>* name; <span class="type">short</span> age; &#125; a, b;</span><br><span class="line"></span><br><span class="line">a.name = <span class="string">&quot;Hula&quot;</span>;</span><br><span class="line">a.age = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">b = a;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>name</code>属性变成了一个字符指针，这时<code>a</code>赋值给<code>b</code>，导致<code>b.name</code>也是同样的字符指针，指向同一个地址，也就是说两个属性共享同一个地址。因为这时，struct 结构内部保存的是一个指针，而不是上一个例子的数组，这时复制的就不是字符串本身，而是它的指针。并且，这个时候也没法修改字符串，因为字符指针指向的字符串是不能修改的。</p>
<p>总结一下，赋值运算符（<code>=</code>）可以将 struct 结构每个属性的值，一模一样复制一份，拷贝给另一个 struct 变量。这一点跟数组完全不同，使用赋值运算符复制数组，不会复制数据，只会共享地址。</p>
<p>注意，这种赋值要求两个变量是同一个类型，不同类型的 struct 变量无法互相赋值。</p>
<p>另外，C 语言没有提供比较两个自定义数据结构是否相等的方法，无法用比较运算符（比如<code>==</code>和<code>!=</code>）比较两个数据结构是否相等或不等。</p>
<h2 id="struct-指针"><a href="#struct-指针" class="headerlink" title="struct 指针"></a>struct 指针</h2><p>如果将 struct 变量传入函数，函数内部得到的是一个原始值的副本。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">turtle</span> &#123;</span></span><br><span class="line">  <span class="type">char</span>* name;</span><br><span class="line">  <span class="type">char</span>* species;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">happy</span><span class="params">(<span class="keyword">struct</span> turtle t)</span> &#123;</span><br><span class="line">  t.age = t.age + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">turtle</span> <span class="title">myTurtle</span> =</span> &#123;<span class="string">&quot;MyTurtle&quot;</span>, <span class="string">&quot;sea turtle&quot;</span>, <span class="number">99</span>&#125;;</span><br><span class="line">  happy(myTurtle);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Age is %i\n&quot;</span>, myTurtle.age); <span class="comment">// 输出 99</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>happy()</code>传入的是一个 struct 变量<code>myTurtle</code>，函数内部有一个自增操作。但是，执行完<code>happy()</code>以后，函数外部的<code>age</code>属性值根本没变。原因就是函数内部得到的是 struct 变量的副本，改变副本影响不到函数外部的原始数据。</p>
<p>通常情况下，开发者希望传入函数的是同一份数据，函数内部修改数据以后，会反映在函数外部。而且，传入的是同一份数据，也有利于提高程序性能。这时就需要将 struct 变量的指针传入函数，通过指针来修改 struct 属性，就可以影响到函数外部。</p>
<p>struct 指针传入函数的写法如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">happy</span><span class="params">(<span class="keyword">struct</span> turtle* t)</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">happy(&amp;myTurtle);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>t</code>是 struct 结构的指针，调用函数时传入的是指针。struct 类型跟数组不一样，类型标识符本身并不是指针，所以传入时，指针必须写成<code>&amp;myTurtle</code>。</p>
<p>函数内部也必须使用<code>(*t).age</code>的写法，从指针拿到 struct 结构本身。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">happy</span><span class="params">(<span class="keyword">struct</span> turtle* t)</span> &#123;</span><br><span class="line">  (*t).age = (*t).age + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>(*t).age</code>不能写成<code>*t.age</code>，因为点运算符<code>.</code>的优先级高于<code>*</code>。<code>*t.age</code>这种写法会将<code>t.age</code>看成一个指针，然后取它对应的值，会出现无法预料的结果。</p>
<p>现在，重新编译执行上面的整个示例，<code>happy()</code>内部对 struct 结构的操作，就会反映到函数外部。</p>
<p><code>(*t).age</code>这样的写法很麻烦。C 语言就引入了一个新的箭头运算符（<code>-&gt;</code>），可以从 struct 指针上直接获取属性，大大增强了代码的可读性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">happy</span><span class="params">(<span class="keyword">struct</span> turtle* t)</span> &#123;</span><br><span class="line">  t-&gt;age = t-&gt;age + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下，对于 struct 变量名，使用点运算符（<code>.</code>）获取属性；对于 struct 变量指针，使用箭头运算符（<code>-&gt;</code>）获取属性。以变量<code>myStruct</code>为例，假设<code>ptr</code>是它的指针，那么下面三种写法是同一回事。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ptr == &amp;myStruct</span></span><br><span class="line">myStruct.prop == (*ptr).prop == ptr-&gt;prop</span><br></pre></td></tr></table></figure>

<h2 id="struct-的嵌套"><a href="#struct-的嵌套" class="headerlink" title="struct 的嵌套"></a>struct 的嵌套</h2><p>struct 结构的成员可以是另一个 struct 结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">species</span> &#123;</span></span><br><span class="line">  <span class="type">char</span>* name;</span><br><span class="line">  <span class="type">int</span> kinds;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fish</span> &#123;</span></span><br><span class="line">  <span class="type">char</span>* name;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">species</span> <span class="title">breed</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>fish</code>的属性<code>breed</code>是另一个 struct 结构<code>species</code>。</p>
<p>赋值的时候有多种写法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fish</span> <span class="title">shark</span> =</span> &#123;<span class="string">&quot;shark&quot;</span>, <span class="number">9</span>, &#123;<span class="string">&quot;Selachimorpha&quot;</span>, <span class="number">500</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">species</span> <span class="title">myBreed</span> =</span> &#123;<span class="string">&quot;Selachimorpha&quot;</span>, <span class="number">500</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fish</span> <span class="title">shark</span> =</span> &#123;<span class="string">&quot;shark&quot;</span>, <span class="number">9</span>, myBreed&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法三</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fish</span> <span class="title">shark</span> =</span> &#123;</span><br><span class="line">  .name=<span class="string">&quot;shark&quot;</span>,</span><br><span class="line">  .age=<span class="number">9</span>,</span><br><span class="line">  .breed=&#123;<span class="string">&quot;Selachimorpha&quot;</span>, <span class="number">500</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法四</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fish</span> <span class="title">shark</span> =</span> &#123;</span><br><span class="line">  .name=<span class="string">&quot;shark&quot;</span>,</span><br><span class="line">  .age=<span class="number">9</span>,</span><br><span class="line">  .breed.name=<span class="string">&quot;Selachimorpha&quot;</span>,</span><br><span class="line">  .breed.kinds=<span class="number">500</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Shark&#x27;s species is %s&quot;</span>, shark.breed.name);</span><br></pre></td></tr></table></figure>

<p>上面示例展示了嵌套 Struct 结构的四种赋值写法。另外，引用<code>breed</code>属性的内部属性，要使用两次点运算符（<code>shark.breed.name</code>）。</p>
<p>下面是另一个嵌套 struct 的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">name</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> first[<span class="number">50</span>];</span><br><span class="line">  <span class="type">char</span> last[<span class="number">50</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">name</span> <span class="title">name</span>;</span></span><br><span class="line">  <span class="type">short</span> age;</span><br><span class="line">  <span class="type">char</span> sex;</span><br><span class="line">&#125; student1;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(student1.name.first, <span class="string">&quot;Harry&quot;</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(student1.name.last, <span class="string">&quot;Potter&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">name</span> <span class="title">myname</span> =</span> &#123;<span class="string">&quot;Harry&quot;</span>, <span class="string">&quot;Potter&quot;</span>&#125;;</span><br><span class="line">student1.name = myname;</span><br></pre></td></tr></table></figure>

<p>上面示例中，自定义类型<code>student</code>的<code>name</code>属性是另一个自定义类型，如果要引用后者的属性，就必须使用两个<code>.</code>运算符，比如<code>student1.name.first</code>。另外，对字符数组属性赋值，要使用<code>strcpy()</code>函数，不能直接赋值，因为直接改掉字符数组名的地址会报错。</p>
<p>struct 结构内部不仅可以引用其他结构，还可以自我引用，即结构内部引用当前结构。比如，链表结构的节点就可以写成下面这样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>node</code>结构的<code>next</code>属性，就是指向另一个<code>node</code>实例的指针。下面，使用这个结构自定义一个数据链表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">head</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成一个三个节点的列表 (11)-&gt;(22)-&gt;(33)</span></span><br><span class="line">head = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> node));</span><br><span class="line"></span><br><span class="line">head-&gt;data = <span class="number">11</span>;</span><br><span class="line">head-&gt;next = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> node));</span><br><span class="line"></span><br><span class="line">head-&gt;next-&gt;data = <span class="number">22</span>;</span><br><span class="line">head-&gt;next-&gt;next = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> node));</span><br><span class="line"></span><br><span class="line">head-&gt;next-&gt;next-&gt;data = <span class="number">33</span>;</span><br><span class="line">head-&gt;next-&gt;next-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历这个列表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">struct</span> node *cur = head; cur != <span class="literal">NULL</span>; cur = cur-&gt;next) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cur-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例是链表结构的最简单实现，通过<code>for</code>循环可以对其进行遍历。</p>
<h2 id="位字段"><a href="#位字段" class="headerlink" title="位字段"></a>位字段</h2><p>struct 还可以用来定义二进制位组成的数据结构，称为“位字段”（bit field），这对于操作底层的二进制数据非常有用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> ab:<span class="number">1</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> cd:<span class="number">1</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> ef:<span class="number">1</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> gh:<span class="number">1</span>;</span><br><span class="line">&#125; synth;</span><br><span class="line"></span><br><span class="line">synth.ab = <span class="number">0</span>;</span><br><span class="line">synth.cd = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例中，每个属性后面的<code>:1</code>，表示指定这些属性只占用一个二进制位，所以这个数据结构一共是4个二进制位。</p>
<p>注意，定义二进制位时，结构内部的各个属性只能是整数类型。</p>
<p>实际存储的时候，C 语言会按照<code>int</code>类型占用的字节数，存储一个位字段结构。如果有剩余的二进制位，可以使用未命名属性，填满那些位。也可以使用宽度为0的属性，表示占满当前字节剩余的二进制位，迫使下一个属性存储在下一个字节。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> field1 : <span class="number">1</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span>        : <span class="number">2</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> field2 : <span class="number">1</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span>        : <span class="number">0</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> field3 : <span class="number">1</span>;</span><br><span class="line">&#125; stuff;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>stuff.field1</code>与<code>stuff.field2</code>之间，有一个宽度为两个二进制位的未命名属性。<code>stuff.field3</code>将存储在下一个字节。</p>
<h2 id="弹性数组成员"><a href="#弹性数组成员" class="headerlink" title="弹性数组成员"></a>弹性数组成员</h2><p>很多时候，不能事先确定数组到底有多少个成员。如果声明数组的时候，事先给出一个很大的成员数，就会很浪费空间。C 语言提供了一个解决方法，叫做弹性数组成员（flexible array member）。</p>
<p>如果不能事先确定数组成员的数量时，可以定义一个 struct 结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vstring</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> len;</span><br><span class="line">  <span class="type">char</span> chars[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>struct vstring</code>结构有两个属性。<code>len</code>属性用来记录数组<code>chars</code>的长度，<code>chars</code>属性是一个数组，但是没有给出成员数量。</p>
<p><code>chars</code>数组到底有多少个成员，可以在为<code>vstring</code>分配内存时确定。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vstring</span>* <span class="title">str</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> vstring) + n * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">str-&gt;len = n;</span><br></pre></td></tr></table></figure>

<p>上面示例中，假定<code>chars</code>数组的成员数量是<code>n</code>，只有在运行时才能知道<code>n</code>到底是多少。然后，就为<code>struct vstring</code>分配它需要的内存：它本身占用的内存长度，再加上<code>n</code>个数组成员占用的内存长度。最后，<code>len</code>属性记录一下<code>n</code>是多少。</p>
<p>这样就可以让数组<code>chars</code>有<code>n</code>个成员，不用事先确定，可以跟运行时的需要保持一致。</p>
<p>弹性数组成员有一些专门的规则。首先，弹性成员的数组，必须是 struct 结构的最后一个属性。另外，除了弹性数组成员，struct 结构必须至少还有一个其他属性。</p>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/02/02/5f8eaecb5f1f414d9106a33847f193a9/" title="variable"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">variable</div></div></a></div><div class="next-post pull-right"><a href="/2023/02/02/bf7f6d8e12f54a7c8802abcbdc18e689/" title="union"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">union</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#struct-%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">struct 结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#struct-%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="toc-number">1.2.</span> <span class="toc-text">struct 的复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#struct-%E6%8C%87%E9%92%88"><span class="toc-number">1.3.</span> <span class="toc-text">struct 指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#struct-%E7%9A%84%E5%B5%8C%E5%A5%97"><span class="toc-number">1.4.</span> <span class="toc-text">struct 的嵌套</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E5%AD%97%E6%AE%B5"><span class="toc-number">1.5.</span> <span class="toc-text">位字段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%B9%E6%80%A7%E6%95%B0%E7%BB%84%E6%88%90%E5%91%98"><span class="toc-number">1.6.</span> <span class="toc-text">弹性数组成员</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://meowrain.cn">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div></div></body></html>