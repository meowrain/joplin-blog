<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>file | 知识库</title><meta name="author" content="Public"><meta name="copyright" content="Public"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="referrer" content="no-referrer"><meta name="description" content="文件操作本章介绍 C 语言如何操作文件。 文件指针C 语言提供了一个 FILE 数据结构，记录了操作一个文件所需要的信息。该结构定义在头文件stdio.h，所有文件操作函数都要通过这个数据结构，获取文件信息。 开始操作一个文件之前，就要定义一个指向该文件的 FILE 指针，相当于获取一块内存区域，用来保存文件信息。 1FILE* fp;  上面示例定义了一个 FILE 指针fp。 下面是一个读取文">
<meta property="og:type" content="article">
<meta property="og:title" content="file">
<meta property="og:url" content="http://example.com/2023/02/02/a57d1c9278214ad49c0c94d45a92af2b/index.html">
<meta property="og:site_name" content="知识库">
<meta property="og:description" content="文件操作本章介绍 C 语言如何操作文件。 文件指针C 语言提供了一个 FILE 数据结构，记录了操作一个文件所需要的信息。该结构定义在头文件stdio.h，所有文件操作函数都要通过这个数据结构，获取文件信息。 开始操作一个文件之前，就要定义一个指向该文件的 FILE 指针，相当于获取一块内存区域，用来保存文件信息。 1FILE* fp;  上面示例定义了一个 FILE 指针fp。 下面是一个读取文">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://meowrain.cn/upload/2022/11/QQ%E5%9B%BE%E7%89%8720221127155827.jpg">
<meta property="article:published_time" content="2023-02-02T03:09:53.202Z">
<meta property="article:modified_time" content="2023-02-02T03:10:32.453Z">
<meta property="article:author" content="Public">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://meowrain.cn/upload/2022/11/QQ%E5%9B%BE%E7%89%8720221127155827.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/02/02/a57d1c9278214ad49c0c94d45a92af2b/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'file',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-02 11:10:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><script>if (location.pathname.endsWith('/')) {location += 'index.html';}</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://meowrain.cn/upload/2022/11/QQ%E5%9B%BE%E7%89%8720221127155827.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">495</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">47</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="知识库"><span class="site-name">知识库</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">file</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-02T03:09:53.202Z" title="发表于 2023-02-02 11:09:53">2023-02-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-02T03:10:32.453Z" title="更新于 2023-02-02 11:10:32">2023-02-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C-C/">C/C++</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C-C/wangdoc-c/">wangdoc-c</a></span></div><div class="meta-secondline"></div></div></div><article class="post-content" id="article-container"><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><p>本章介绍 C 语言如何操作文件。</p>
<h2 id="文件指针"><a href="#文件指针" class="headerlink" title="文件指针"></a>文件指针</h2><p>C 语言提供了一个 FILE 数据结构，记录了操作一个文件所需要的信息。该结构定义在头文件<code>stdio.h</code>，所有文件操作函数都要通过这个数据结构，获取文件信息。</p>
<p>开始操作一个文件之前，就要定义一个指向该文件的 FILE 指针，相当于获取一块内存区域，用来保存文件信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE* fp;</span><br></pre></td></tr></table></figure>

<p>上面示例定义了一个 FILE 指针<code>fp</code>。</p>
<p>下面是一个读取文件的完整示例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  FILE* fp;</span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">  fp = fopen(<span class="string">&quot;hello.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  c = fgetc(fp);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">  fclose(fp);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，新建文件指针<code>fp</code>以后，依次使用了下面三个文件操作函数，分成三个步骤。其他的文件操作，大致上也是这样的步骤。</p>
<p>第一步，使用<code>fopen()</code>打开指定文件，返回一个 File 指针。如果出错，返回 NULL。</p>
<p>它相当于将指定文件的信息与新建的文件指针<code>fp</code>相关联，在 FILE 结构内部记录了这样一些信息：文件内部的当前读写位置、读写报错的记录、文件结尾指示器、缓冲区开始位置的指针、文件标识符、一个计数器（统计拷贝进缓冲区的字节数）等等。后继的操作就可以使用这个指针（而不是文件名）来处理指定文件。</p>
<p>同时，它还为文件建立一个缓存区。由于存在缓存区，也可以说<code>fopen()</code>函数“打开一个了流”，后继的读写文件都是流模式。</p>
<p>第二步，使用读写函数，从文件读取数据，或者向文件写入数据。上例使用了<code>fgetc()</code>函数，从已经打开的文件里面，读取一个字符。</p>
<p><code>fgetc()</code>一调用，文件的数据块先拷贝到缓冲区。不同的计算机有不同的缓冲区大小，一般是512字节或是它的倍数，如4096或16384。随着计算机硬盘容量越来越大，缓冲区也越来越大。</p>
<p><code>fgetc()</code>从缓冲区读取数据，同时将文件指针内部的读写位置指示器，指向所读取字符的下一个字符。所有的文件读取函数都使用相同的缓冲区，后面再调用任何一个读取函数，都将从指示器指向的位置，即上一次读取函数停止的位置开始读取。</p>
<p>当读取函数发现已读完缓冲区里面的所有字符时，会请求把下一个缓冲区大小的数据块，从文件拷贝到缓冲区中。读取函数就以这种方式，读完文件的所有内容，直到文件结尾。不过，上例是只从缓存区读取一个字符。当函数在缓冲区里面，读完文件的最后一个字符时，就把 FILE 结构里面的文件结尾指示器设置为真。于是，下一次再调用读取函数时，会返回常量 EOF。EOF 是一个整数值，代表文件结尾，一般是<code>-1</code>。</p>
<p>第三步，<code>fclose()</code>关闭文件，同时清空缓存区。</p>
<p>上面是文件读取的过程，文件写入也是类似的方式，先把数据写入缓冲区，当缓冲区填满后，缓存区的数据将被转移到文件中。</p>
<h2 id="fopen"><a href="#fopen" class="headerlink" title="fopen()"></a>fopen()</h2><p><code>fopen()</code>函数用来打开文件。所有文件操作的第一步，都是使用<code>fopen()</code>打开指定文件。这个函数的原型定义在头文件<code>stdio.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE* <span class="title function_">fopen</span><span class="params">(<span class="type">char</span>* filename, <span class="type">char</span>* mode)</span>;</span><br></pre></td></tr></table></figure>

<p>它接受两个参数。第一个参数是文件名(可以包含路径)，第二个参数是模式字符串，指定对文件执行的操作，比如下面的例子中，<code>r</code>表示以读取模式打开文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fp = fopen(<span class="string">&quot;in.dat&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>成功打开文件以后，<code>fopen()</code>返回一个 FILE 指针，其他函数可以用这个指针操作文件。如果无法打开文件（比如文件不存在或没有权限），会返回空指针 NULL。所以，执行<code>fopen()</code>以后，最好判断一下，有没有打开成功。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fp = fopen(<span class="string">&quot;hello.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Can&#x27;t open file!\n&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，如果<code>fopen()</code>返回一个空指针，程序就会报错。</p>
<p><code>fopen()</code>的模式字符串有以下几种。</p>
<ul>
<li><code>r</code>：读模式，只用来读取数据。如果文件不存在，返回 NULL 指针。</li>
<li><code>w</code>：写模式，只用来写入数据。如果文件存在，文件长度会被截为0，然后再写入；如果文件不存在，则创建该文件。</li>
<li><code>a</code>：写模式，只用来在文件尾部追加数据。如果文件不存在，则创建该文件。</li>
<li><code>r+</code>：读写模式。如果文件存在，指针指向文件开始处，可以在文件头部添加数据。如果文件不存在，返回 NULL 指针。</li>
<li><code>w+</code>：读写模式。如果文件存在，文件长度会被截为0，然后再写入数据。这种模式实际上读不到数据，反而会擦掉数据。如果文件不存在，则创建该文件。</li>
<li><code>a+</code>：读写模式。如果文件存在，指针指向文件结尾，可以在现有文件末尾添加内容。如果文件不存在，则创建该文件。</li>
</ul>
<p>上一小节说过，<code>fopen()</code>函数会为打开的文件创建一个缓冲区。读模式下，创建的是读缓存区；写模式下，创建的是写缓存区；读写模式下，会同时创建两个缓冲区。C 语言通过缓存区，以流的形式，向文件读写数据。</p>
<p>数据在文件里面，都是以二进制形式存储。但是，读取的时候，有不同的解读方法：以原本的二进制形式解读，叫做“二进制流”；将二进制数据转成文本，以文本形式解读，叫做“文本流”。写入操作也是如此，分成以二进制写入和以文本写入，后者会多一个文本转二进制的步骤。</p>
<p><code>fopen()</code>的模式字符串，默认是以文本流读写。如果添加<code>b</code>后缀（表示 binary），就会以“二进制流”进行读写。比如，<code>rb</code>是读取二进制数据模式，<code>wb</code>是写入二进制数据模式。</p>
<p>模式字符串还有一个<code>x</code>后缀，表示独占模式（exclusive）。如果文件已经存在，则打开文件失败；如果文件不存在，则新建文件，打开后不再允许其他程序或线程访问当前文件。比如，<code>wx</code>表示以独占模式写入文件，如果文件已经存在，就会打开失败。</p>
<h2 id="标准流"><a href="#标准流" class="headerlink" title="标准流"></a>标准流</h2><p>Linux 系统默认提供三个已经打开的文件，它们的文件指针如下。</p>
<ul>
<li><code>stdin</code>（标准输入）：默认来源为键盘，文件指针编号为<code>0</code>。</li>
<li><code>stdout</code>（标准输出）：默认目的地为显示器，文件指针编号为<code>1</code>。</li>
<li><code>stderr</code>（标准错误）：默认目的地为显示器，文件指针编号为<code>2</code>。</li>
</ul>
<p>Linux 系统的文件，不一定是数据文件，也可以是设备文件，即文件代表一个可以读或写的设备。文件指针<code>stdin</code>默认是把键盘看作一个文件，读取这个文件，就能获取用户的键盘输入。同理，<code>stdout</code>和<code>stderr</code>默认是把显示器看作一个文件，将程序的运行结果写入这个文件，用户就能看到运行结果了。它们的区别是，<code>stdout</code>写入的是程序的正常运行结果，<code>stderr</code>写入的是程序的报错信息。</p>
<p>这三个输入和输出渠道，是 Linux 默认提供的，所以分别称为标准输入（stdin）、标准输出（stdout）和标准错误（stderr）。因为它们的实现是一样的，都是文件流，所以合称为“标准流”。</p>
<p>Linux 允许改变这三个文件指针（文件流）指向的文件，这称为重定向（redirection）。</p>
<p>如果标准输入不绑定键盘，而是绑定其他文件，可以在文件名前面加上小于号<code>&lt;</code>，跟在程序名后面。这叫做“输入重定向”（input redirection）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ demo &lt; in.dat</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>demo</code>程序代码里面的<code>stdin</code>，将指向文件<code>in.dat</code>，即从<code>in.dat</code>获取数据。</p>
<p>如果标准输出绑定其他文件，而不是显示器，可以在文件名前加上大于号<code>&gt;</code>，跟在程序名后面。这叫做“输出重定向”（output redirection）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ demo &gt; out.dat</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>demo</code>程序代码里面的<code>stdout</code>，将指向文件<code>out.dat</code>，即向<code>out.dat</code>写入数据。</p>
<p>输出重定向<code>&gt;</code>会先擦去<code>out.dat</code>的所有原有的内容，然后再写入。如果希望写入的信息追加在<code>out.dat</code>的结尾，可以使用<code>&gt;&gt;</code>符号。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ demo &gt;&gt; out.dat</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>demo</code>程序代码里面的<code>stdout</code>，将向文件<code>out.dat</code>写入数据。与<code>&gt;</code>不同的是，写入的开始位置是<code>out.dat</code>的文件结尾。</p>
<p>标准错误的重定向符号是<code>2&gt;</code>。其中的<code>2</code>代表文件指针的编号，即<code>2&gt;</code>表示将2号文件指针的写入，重定向到<code>err.txt</code>。2号文件指针就是标准错误<code>stderr</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ demo &gt; out.dat 2&gt; err.txt</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>demo</code>程序代码里面的<code>stderr</code>，会向文件<code>err.txt</code>写入报错信息。而<code>stdout</code>向文件<code>out.dat</code>写入。</p>
<p>输入重定向和输出重定向，也可以结合在一条命令里面。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ demo &lt; in.dat &gt; out.dat</span><br><span class="line"></span><br><span class="line">// or</span><br><span class="line">$ demo &gt; out.dat &lt; in.dat</span><br></pre></td></tr></table></figure>

<p>重定向还有另一种情况，就是将一个程序的标准输出<code>stdout</code>，指向另一个程序的标准输入<code>stdin</code>，这时要使用<code>|</code>符号。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ random | <span class="built_in">sum</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>random</code>程序代码里面的<code>stdout</code>的写入，会从<code>sum</code>程序代码里面的<code>stdin</code>被读取。</p>
<h2 id="fclose"><a href="#fclose" class="headerlink" title="fclose()"></a>fclose()</h2><p><code>fclose()</code>用来关闭已经使用<code>fopen()</code>打开的文件。它的原型定义在<code>stdin.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">(FILE* stream)</span>;</span><br></pre></td></tr></table></figure>

<p>它接受一个文件指针<code>fp</code>作为参数。如果成功关闭文件，<code>fclose()</code>函数返回整数<code>0</code>；如果操作失败（比如磁盘已满，或者出现 I&#x2F;O 错误），则返回一个特殊值 EOF（详见下一小节）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fclose(fp) != <span class="number">0</span>)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Something wrong.&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>不再使用的文件，都应该使用<code>fclose()</code>关闭，否则无法释放资源。一般来说，系统对同时打开的文件数量有限制，及时关闭文件可以避免超过这个限制。</p>
<h2 id="EOF"><a href="#EOF" class="headerlink" title="EOF"></a>EOF</h2><p>C 语言的文件操作函数的设计是，如果遇到文件结尾，就返回一个特殊值。程序接收到这个特殊值，就知道已经到达文件结尾了。</p>
<p>头文件<code>stdio.h</code>为这个特殊值定义了一个宏<code>EOF</code>（end of file 的缩写），它的值一般是<code>-1</code>。这是因为从文件读取的二进制值，不管作为无符号数字解释，还是作为 ASCII 码解释，都不可能是负值，所以可以很安全地返回<code>-1</code>，不会跟文件本身的数据相冲突。</p>
<p>需要注意的是，不像字符串结尾真的存储了<code>\0</code>这个值，<code>EOF</code>并不存储在文件结尾，文件中并不存在这个值，完全是文件操作函数发现到达了文件结尾，而返回这个值。</p>
<h2 id="freopen"><a href="#freopen" class="headerlink" title="freopen()"></a>freopen()</h2><p><code>freopen()</code>用于新打开一个文件，直接关联到某个已经打开的文件指针。这样可以复用文件指针。它的原型定义在头文件<code>stdio.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE* <span class="title function_">freopen</span><span class="params">(<span class="type">char</span>* filename, <span class="type">char</span>* mode, FILE stream)</span>;</span><br></pre></td></tr></table></figure>

<p>它跟<code>fopen()</code>相比，就是多出了第三个参数，表示要复用的文件指针。其他两个参数都一样，分别是文件名和打开模式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">freopen(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例将文件<code>output.txt</code>关联到<code>stdout</code>，此后向<code>stdout</code>写入的内容，都会写入<code>output.txt</code>。由于<code>printf()</code>默认就是输出到<code>stdout</code>，所以运行上面的代码以后，文件<code>output.txt</code>会被写入<code>hello</code>。</p>
<p><code>freopen()</code>的返回值是它的第三个参数（文件指针）。如果打开失败（比如文件不存在），会返回空指针 NULL。</p>
<p><code>freopen()</code>会自动关闭原先已经打开的文件，如果文件指针并没有指向已经打开的文件，则<code>freopen()</code>等同于<code>fopen()</code>。</p>
<p>下面是<code>freopen()</code>关联<code>scanf()</code>的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, i2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;i); </span><br><span class="line"></span><br><span class="line">freopen(<span class="string">&quot;someints.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;i2);</span><br></pre></td></tr></table></figure>

<p>上面例子中，一共调用了两次<code>scanf()</code>，第一次调用是从键盘读取，然后使用<code>freopen()</code>将<code>stdin</code>指针关联到某个文件，第二次调用就会从该文件读取。</p>
<p>某些系统允许使用<code>freopen()</code>，改变文件的打开模式。这时，<code>freopen()</code>的第一个参数应该是 NULL。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">freopen(<span class="literal">NULL</span>, <span class="string">&quot;wb&quot;</span>, <span class="built_in">stdout</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例将<code>stdout</code>的打开模式从<code>w</code>改成了<code>wb</code>。</p>
<h2 id="fgetc-，getc"><a href="#fgetc-，getc" class="headerlink" title="fgetc()，getc()"></a>fgetc()，getc()</h2><p><code>fgetc()</code>和<code>getc()</code>用于从文件读取一个字符。它们的用法跟<code>getchar()</code>类似，区别是<code>getchar()</code>只用来从<code>stdin</code>读取，而这两个函数是从任意指定的文件读取。它们的原型定义在头文件<code>stdio.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE *stream)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getc</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p><code>fgetc()</code>与<code>getc()</code>的用法是一样的，都只有文件指针一个参数。两者的区别是，<code>getc()</code>一般用宏来实现，而<code>fgetc()</code>是函数实现，所以前者的性能可能更好一些。注意，虽然这两个函数返回的是一个字符，但是它们的返回值类型却不是<code>char</code>，而是<code>int</code>，这是因为读取失败的情况下，它们会返回 EOF，这个值一般是<code>-1</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  FILE *fp;</span><br><span class="line">  fp = fopen(<span class="string">&quot;hello.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line">  <span class="keyword">while</span> ((c = getc(fp)) != EOF)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">  fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>getc()</code>依次读取文件的每个字符，将其放入变量<code>c</code>，直到读到文件结尾，返回 EOF，循环终止。变量<code>c</code>的类型是<code>int</code>，而不是<code>char</code>，因为有可能等于负值，所以设为<code>int</code>更好一些。</p>
<h2 id="fputc-，putc"><a href="#fputc-，putc" class="headerlink" title="fputc()，putc()"></a>fputc()，putc()</h2><p><code>fputc()</code>和<code>putc()</code>用于向文件写入一个字符。它们的用法跟<code>putchar()</code>类似，区别是<code>putchar()</code>是向<code>stdout</code>写入，而这两个函数是向文件写入。它们的原型定义在头文件<code>stdio.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> <span class="type">char</span>, FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">putc</span><span class="params">(<span class="type">int</span> <span class="type">char</span>, FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p><code>fputc()</code>与<code>putc()</code>的用法是一样，都接受两个参数，第一个参数是待写入的字符，第二个参数是文件指针。它们的区别是，<code>putc()</code>通常是使用宏来实现，而<code>fputc()</code>只作为函数来实现，所以理论上，<code>putc()</code>的性能会好一点。</p>
<p>写入成功时，它们返回写入的字符；写入失败时，返回 EOF。</p>
<h2 id="fprintf"><a href="#fprintf" class="headerlink" title="fprintf()"></a>fprintf()</h2><p><code>fprintf()</code>用于向文件写入格式化字符串，用法与<code>printf()</code>类似。区别是<code>printf()</code>总是写入<code>stdout</code>，而<code>fprintf()</code>则是写入指定的文件，它的第一个参数必须是一个文件指针。它的原型定义在头文件<code>stdio.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE* stream, <span class="type">const</span> <span class="type">char</span>* format, ...)</span></span><br></pre></td></tr></table></figure>

<p><code>fprintf()</code>可以替代<code>printf()</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;Hello, world!\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面例子中，指定<code>fprintf()</code>写入<code>stdout</code>，结果就等同于调用<code>printf()</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(fp, <span class="string">&quot;Sum: %d\n&quot;</span>, sum);</span><br></pre></td></tr></table></figure>

<p>上面示例是向文件指针<code>fp</code>写入指定格式的字符串。</p>
<p>下面是向<code>stderr</code>输出错误信息的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Something number.\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="fscanf"><a href="#fscanf" class="headerlink" title="fscanf()"></a>fscanf()</h2><p><code>fscanf()</code>用于按照给定的模式，从文件中读取内容，用法跟<code>scanf()</code>类似。区别是<code>scanf()</code>总是从<code>stdin</code>读取数据，而<code>fscanf()</code>是从文件读入数据，它的原型定义在头文件<code>stdio.h</code>，第一个参数必须是文件指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fscanf</span><span class="params">(FILE* stream, <span class="type">const</span> <span class="type">char</span>* format, ...)</span>;</span><br></pre></td></tr></table></figure>

<p>下面是一个例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fscanf</span>(fp, <span class="string">&quot;%d%d&quot;</span>, &amp;i, &amp;j);</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>fscanf()</code>从文件<code>fp</code>里面，读取两个整数，放入变量<code>i</code>和<code>j</code>。</p>
<p>使用<code>fscanf()</code>的前提是知道文件的结构，它的占位符解析规则与<code>scanf()</code>完全一致。由于<code>fscanf()</code>可以连续读取，直到读到文件尾，或者发生错误（读取失败、匹配失败），才会停止读取，所以<code>fscanf()</code>通常放在循环里面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">fscanf</span>(fp, <span class="string">&quot;%s&quot;</span>, words) == <span class="number">1</span>)</span><br><span class="line">  <span class="built_in">puts</span>(words);</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>fscanf()</code>依次读取文件的每个词，将它们一行打印一个，直到文件结束。</p>
<p><code>fscanf()</code>的返回值是赋值成功的变量数量，如果赋值失败会返回 EOF。</p>
<h2 id="fgets"><a href="#fgets" class="headerlink" title="fgets()"></a>fgets()</h2><p><code>fgets()</code>用于从文件读取指定长度的字符串，它名字的第一个字符是<code>f</code>，就代表<code>file</code>。它的原型定义在头文件<code>stdio.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">fgets</span><span class="params">(<span class="type">char</span>* str, <span class="type">int</span> STRLEN, File* fp)</span>;</span><br></pre></td></tr></table></figure>

<p>它的第一个参数<code>str</code>是一个字符串指针，用于存放读取的内容。第二个参数<code>STRLEN</code>指定读取的长度，第三个参数是一个 FILE 指针，指向要读取的文件。</p>
<p><code>fgets()</code>读取 STRLEN - 1 个字符之后，或者遇到换行符与文件结尾，就会停止读取，然后在已经读取的内容末尾添加一个空字符<code>\0</code>，使之成为一个字符串。注意，<code>fgets()</code>会将换行符（<code>\n</code>）存储进字符串。</p>
<p>如果<code>fgets</code>的第三个参数是<code>stdin</code>，就可以读取标准输入，等同于<code>scanf()</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fgets(str, <span class="keyword">sizeof</span>(str), <span class="built_in">stdin</span>);</span><br></pre></td></tr></table></figure>

<p>读取成功时，<code>fgets()</code>的返回值是它的第一个参数，即指向字符串的指针，否则返回空指针 NULL。</p>
<p><code>fgets()</code>可以用来读取文件的每一行，下面是读取文件所有行的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  FILE* fp;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">1024</span>];  <span class="comment">// 数组必须足够大，足以放下一行</span></span><br><span class="line">  <span class="type">int</span> linecount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  fp = fopen(<span class="string">&quot;hello.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (fgets(s, <span class="keyword">sizeof</span> s, fp) != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d: %s&quot;</span>, ++linecount, s);</span><br><span class="line"></span><br><span class="line">  fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，每读取一行，都会输出行号和该行的内容。</p>
<p>下面的例子是循环读取用户的输入。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> words[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Enter strings (q to quit):&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (fgets(words, <span class="number">10</span>, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (words[<span class="number">0</span>] == <span class="string">&#x27;q&#x27;</span> &amp;&amp; words[<span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(words);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Done.&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面的示例中，如果用户输入的字符串大于9个字符，<code>fgets()</code>会多次读取。直到遇到<code>q</code> + 回车键，才会退出循环。</p>
<h2 id="fputs"><a href="#fputs" class="headerlink" title="fputs()"></a>fputs()</h2><p><code>fputs()</code>函数用于向文件写入字符串，和<code>puts()</code>函数只有一点不同，那就是它不会在字符串末尾添加换行符。这是因为<code>fgets()</code>保留了换行符，所以<code>fputs()</code>就不添加了。<code>fputs()</code>函数通常与<code>fgets()</code>配对使用。</p>
<p>它的原型定义在<code>stdio.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, FILE* stream)</span>;</span><br></pre></td></tr></table></figure>

<p>它接受两个参数，第一个参数是字符串指针，第二个参数是要写入的文件指针。如果第二个参数为<code>stdout</code>（标准输出），就是将内容输出到计算机屏幕，等同于<code>printf()</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> words[<span class="number">14</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Enter a string, please.&quot;</span>);</span><br><span class="line">fgets(words, <span class="number">14</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;This is your string:&quot;</span>);</span><br><span class="line"><span class="built_in">fputs</span>(words, <span class="built_in">stdout</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，先用<code>fgets()</code>从<code>stdin</code>读取用户输入，然后用<code>fputs()</code>输出到<code>stdout</code>。</p>
<p>写入成功时，<code>fputs()</code>返回一个非负整数，否则返回 EOF。</p>
<h2 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite()"></a>fwrite()</h2><p><code>fwrite()</code>用来一次性写入较大的数据块，主要用途是将数组数据一次性写入文件，适合写入二进制数据。它的原型定义在<code>stdio.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="type">void</span>* ptr,</span></span><br><span class="line"><span class="params">  <span class="type">size_t</span> size,</span></span><br><span class="line"><span class="params">  <span class="type">size_t</span> nmemb,</span></span><br><span class="line"><span class="params">  FILE* fp</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>它接受四个参数。</p>
<ul>
<li><code>ptr</code>：数组指针。</li>
<li><code>size</code>：每个数组成员的大小，单位字节。</li>
<li><code>nmemb</code>：数组成员的数量。</li>
<li><code>fp</code>：要写入的文件指针。</li>
</ul>
<p>注意，<code>fwrite()</code>原型的第一个参数类型是<code>void*</code>，这是一个无类型指针，编译器会自动将参数指针转成<code>void*</code>类型。正是由于<code>fwrite()</code>不知道数组成员的类型，所以才需要知道每个成员的大小（第二个参数）和成员数量（第三个参数）。</p>
<p><code>fwrite()</code>函数的返回值是成功写入的数组成员的数量（注意不是字节数）。正常情况下，该返回值就是第三个参数<code>nmemb</code>，但如果出现写入错误，只写入了一部分成员，返回值会比<code>nmemb</code>小。</p>
<p>要将整个数组<code>arr</code>写入文件，可以采用下面的写法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fwrite(</span><br><span class="line">  arr,</span><br><span class="line">  <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]),</span><br><span class="line">  <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]),</span><br><span class="line">  fp</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>sizeof(a[0])</code>是每个数组成员占用的字节，<code>sizeof(a) / sizeof(a[0])</code>是整个数组的成员数量。</p>
<p>下面的例子是将一个大小为256字节的字符串写入文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buffer[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">fwrite(buffer, <span class="number">1</span>, <span class="number">256</span>, fp);</span><br></pre></td></tr></table></figure>

<p>上面示例中，数组<code>buffer</code>每个成员是1个字节，一共有256个成员。由于<code>fwrite()</code>是连续内存复制，所以写成<code>fwrite(buffer, 256, 1, fp)</code>也能达到目的。</p>
<p><code>fwrite()</code>没有规定一定要写入整个数组，只写入数组的一部分也是可以的。</p>
<p>任何类型的数据都可以看成是1字节数据组成的数组，或者是一个成员的数组，所以<code>fwrite()</code>实际上可以写入任何类型的数据，而不仅仅是数组。比如，<code>fwrite()</code>可以将一个 Struct 结构写入文件保存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fwrite(&amp;s, <span class="keyword">sizeof</span>(s), <span class="number">1</span>, fp);</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>s</code>是一个 Struct 结构指针，可以看成是一个成员的数组。注意，如果<code>s</code>的属性包含指针，存储时需要小心，因为保存指针可能没意义，还原出来的时候，并不能保证指针指向的数据还存在。</p>
<p><code>fwrite()</code>以及后面要介绍的<code>fread()</code>，比较适合读写二进制数据，因为它们不会对写入的数据进行解读。二进制数据可能包含空字符<code>\0</code>，这是 C 语言的字符串结尾标记，所以读写二进制文件，不适合使用文本读写函数（比如<code>fprintf()</code>等）。</p>
<p>下面是一个写入二进制文件的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  FILE* fp;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> bytes[] = &#123;<span class="number">5</span>, <span class="number">37</span>, <span class="number">0</span>, <span class="number">88</span>, <span class="number">255</span>, <span class="number">12</span>&#125;;</span><br><span class="line"></span><br><span class="line">  fp = fopen(<span class="string">&quot;output.bin&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">  fwrite(bytes, <span class="keyword">sizeof</span>(<span class="type">char</span>), <span class="keyword">sizeof</span>(bytes), fp);</span><br><span class="line">  fclose(fp);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，写入二进制文件时，<code>fopen()</code>要使用<code>wb</code>模式打开，表示二进制写入。<code>fwrite()</code>可以把数据解释成单字节数组，因此它的第二个参数是<code>sizeof(char)</code>，第三个参数是数组的总字节数<code>sizeof(bytes)</code>。</p>
<p>上面例子写入的文件<code>output.bin</code>，使用十六进制编辑器打开，会是下面的内容。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">05</span> <span class="number">25</span> <span class="number">00</span> <span class="number">58</span> ff <span class="number">0</span>c</span><br></pre></td></tr></table></figure>

<p><code>fwrite()</code>还可以连续向一个文件写入数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clientData</span> <span class="title">myClient</span> =</span> &#123;<span class="number">1</span>, <span class="string">&#x27;foo bar&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">  fwrite(&amp;myClient, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> clientData), <span class="number">1</span>, cfPtr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>fwrite()</code>连续将100条数据写入文件。</p>
<h2 id="fread"><a href="#fread" class="headerlink" title="fread()"></a>fread()</h2><p><code>fread()</code>函数用于一次性从文件读取较大的数据块，主要用途是将文件内容读入一个数组，适合读取二进制数据。它的原型定义在头文件<code>stdio.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">void</span>* ptr,</span></span><br><span class="line"><span class="params">  <span class="type">size_t</span> size,</span></span><br><span class="line"><span class="params">  <span class="type">size_t</span> nmemb,</span></span><br><span class="line"><span class="params">  FILE* fp</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>它接受四个参数，与<code>fwrite()</code>完全相同。</p>
<ul>
<li><code>ptr</code>：数组地址。</li>
<li><code>size</code>：每个数组成员的大小，单位为字节。</li>
<li><code>nmemb</code>：数组的成员数量。</li>
<li><code>fp</code>：文件指针。</li>
</ul>
<p>要将文件内容读入数组<code>arr</code>，可以采用下面的写法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fread(</span><br><span class="line">  arr,</span><br><span class="line">  <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]),</span><br><span class="line">  <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]),</span><br><span class="line">  fp</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面示例中，数组长度（第二个参数）和每个成员的大小（第三个参数）的乘积，就是数组占用的内存空间的大小。<code>fread()</code>会从文件（第四个参数）里面读取相同大小的内容，然后将<code>ptr</code>（第一个参数）指向这些内容的内存地址。</p>
<p>下面的例子是将文件内容读入一个10个成员的双精度浮点数数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> earnings[<span class="number">10</span>];</span><br><span class="line">fread(earnings, <span class="keyword">sizeof</span>(<span class="type">double</span>), <span class="number">10</span>, fp);</span><br></pre></td></tr></table></figure>

<p>上面示例中，每个数组成员的大小是<code>sizeof(double)</code>，一个有10个成员，就会从文件<code>fp</code>读取<code>sizeof(double) * 10</code>大小的内容。</p>
<p><code>fread()</code>函数的返回值是成功读取的数组成员的数量。正常情况下，该返回值就是第三个参数<code>nmemb</code>，但如果出现读取错误或读到文件结尾，该返回值就会比<code>nmemb</code>小。所以，检查<code>fread()</code>的返回值是非常重要的。</p>
<p><code>fread()</code>和<code>fwrite()</code>可以配合使用。在程序终止之前，使用<code>fwrite()</code>将数据保存进文件，下次运行时再用<code>fread()</code>将数据还原进入内存。</p>
<p>下面是读取上一节生成的二进制文件<code>output.bin</code>的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  FILE* fp;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">  fp = fopen(<span class="string">&quot;output.bin&quot;</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> (fread(&amp;c, <span class="keyword">sizeof</span>(<span class="type">char</span>), <span class="number">1</span>, fp) &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, c);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后，得到如下结果。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">37</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">88</span></span><br><span class="line"><span class="number">255</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<h2 id="feof"><a href="#feof" class="headerlink" title="feof()"></a>feof()</h2><p><code>feof()</code>函数判断文件的内部指针是否指向文件结尾。它的原型定义在头文件<code>stdio.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">feof</span><span class="params">(FILE *fp)</span>;</span><br></pre></td></tr></table></figure>

<p><code>feof()</code>接受一个文件指针作为参数。如果已经到达文件结尾，会返回一个非零值（表示 true），否则返回<code>0</code>（表示 false）。</p>
<p>诸如<code>fgetc()</code>这样的文件读取函数，如果返回 EOF，有两种可能，一种可能是已读取到文件结尾，另一种可能是出现读取错误。<code>feof()</code>可以用来判断到底是那一种情况。</p>
<p>下面是通过<code>feof()</code>判断是否到达文件结尾，从而循环读取整个文件的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">FILE* cfPtr = fopen(<span class="string">&quot;clients.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!feof(cfPtr)) &#123;</span><br><span class="line">  <span class="built_in">fscanf</span>(cfPtr, <span class="string">&quot;%d%s\n&quot;</span>, &amp;num, name);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d %s\n&quot;</span>, num, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fclose(cfPtr);</span><br></pre></td></tr></table></figure>

<p>上面示例通过循环判断<code>feof()</code>是否读到文件结尾，从而实现读出整个文件内容。</p>
<p><code>feof()</code>为真时，可以通过<code>fseek()</code>、<code>rewind()</code>、<code>fsetpos()</code>函数改变文件内部读写位置的指示器，从而清除这个函数的状态。</p>
<h2 id="fseek"><a href="#fseek" class="headerlink" title="fseek()"></a>fseek()</h2><p>每个文件指针都有一个内部指示器（内部指针），记录当前打开的文件的读写位置（file position），即下一次读写从哪里开始。文件操作函数（比如<code>getc()</code>、<code>fgets()</code>、<code>fscanf()</code>和<code>fread()</code>等）都从这个指示器指定的位置开始按顺序读写文件。</p>
<p>如果希望改变这个指示器，将它移到文件的指定位置，可以使用<code>fseek()</code>函数。它的原型定义在头文件<code>stdio.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE* stream, <span class="type">long</span> <span class="type">int</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure>

<p><code>fseek()</code>接受3个参数。</p>
<ul>
<li><code>stream</code>：文件指针。</li>
<li><code>offset</code>：距离基准（第三个参数）的字节数。类型为 long int，可以为正值（向文件末尾移动）、负值（向文件开始处移动）或 0（保持不动）。</li>
<li><code>whence</code>：位置基准，用来确定计算起点。它的值是以下三个宏（定义在<code>stdio.h</code>）：<code>SEEK_SET</code>（文件开始处）、<code>SEEK_CUR </code>（内部指针的当前位置）、<code>SEEK_END</code>（文件末尾）</li>
</ul>
<p>请看下面的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定位到文件开始处</span></span><br><span class="line">fseek(fp, <span class="number">0L</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定位到文件末尾</span></span><br><span class="line">fseek(fp, <span class="number">0L</span>, SEEK_END);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从当前位置后移2个字节</span></span><br><span class="line">fseek(fp, <span class="number">2L</span>, SEEK_CUR);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定位到文件第10个字节</span></span><br><span class="line">fseek(fp, <span class="number">10L</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定位到文件倒数第10个字节</span></span><br><span class="line">fseek(fp, <span class="number">-10L</span>, SEEK_END);</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>fseek()</code>的第二个参数为 long 类型，所以移动距离必须加上后缀<code>L</code>，将其转为 long 类型。</p>
<p>下面的示例逆向输出文件的所有字节。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (count = <span class="number">1L</span>; count &lt;= size; count++) &#123;</span><br><span class="line">  fseek(fp, -count, SEEK_END);</span><br><span class="line">  ch = getc(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，<code>fseek()</code>最好只用来操作二进制文件，不要用来读取文本文件。因为文本文件的字符有不同的编码，某个位置的准确字节位置不容易确定。</p>
<p>正常情况下，<code>fseek()</code>的返回值为0。如果发生错误（如移动的距离超出文件的范围），返回值为非零值（比如<code>-1</code>)。</p>
<h2 id="ftell"><a href="#ftell" class="headerlink" title="ftell()"></a>ftell()</h2><p><code>ftell()</code>函数返回文件内部指示器的当前位置。它的原型定义在头文件<code>stdio.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">int</span> <span class="title function_">ftell</span><span class="params">(FILE* stream)</span>;</span><br></pre></td></tr></table></figure>

<p>它接受一个文件指针作为参数。返回值是一个 long 类型的整数，表示内部指示器的当前位置，即文件开始处到当前位置的字节数，<code>0</code>表示文件开始处。如果发生错误，<code>ftell()</code>返回<code>-1L</code>。</p>
<p><code>ftell()</code>可以跟<code>fseek()</code>配合使用，先记录内部指针的位置，一系列操作过后，再用<code>fseek()</code>返回原来的位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> file_pos = ftell(fp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一系列文件操作之后</span></span><br><span class="line">fseek(fp, file_pos, SEEK_SET);</span><br></pre></td></tr></table></figure>

<p>下面的例子先将指示器定位到文件结尾，然后得到文件开始处到结尾的字节数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fseek(fp, <span class="number">0L</span>, SEEK_END);</span><br><span class="line">size = ftell(fp);</span><br></pre></td></tr></table></figure>

<h2 id="rewind"><a href="#rewind" class="headerlink" title="rewind()"></a>rewind()</h2><p><code>rewind()</code>函数可以让文件的内部指示器回到文件开始处。它的原型定义在<code>stdio.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rewind</span><span class="params">(file* stream)</span>;</span><br></pre></td></tr></table></figure>

<p>它接受一个文件指针作为参数。</p>
<p><code>rewind(fp)</code>基本等价于<code>fseek(fp, 0l, seek_set)</code>，唯一的区别是<code>rewind()</code>没有返回值，而且会清除当前文件的错误指示器。</p>
<h2 id="fgetpos-，fsetpos"><a href="#fgetpos-，fsetpos" class="headerlink" title="fgetpos()，fsetpos()"></a>fgetpos()，fsetpos()</h2><p><code>fseek()</code>和<code>ftell()</code>有一个潜在的问题，那就是它们都把文件大小限制在 long int 类型能表示的范围内。这看起来相当大，但是在32位计算机上，long int 的长度为4个字节，能够表示的范围最大为 4GB。随着存储设备的容量迅猛增长，文件也越来越大，往往会超出这个范围。鉴于此，C 语言新增了两个处理大文件的新定位函数：<code>fgetpos()</code>和<code>fsetpos()</code>。</p>
<p>它们的原型都定义在头文件<code>stdio.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fgetpos</span><span class="params">(FILE* stream, <span class="type">fpos_t</span>* pos)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fsetpos</span><span class="params">(FILE* stream, <span class="type">const</span> <span class="type">fpos_t</span>* pos)</span>;</span><br></pre></td></tr></table></figure>

<p><code>fgetpos()</code>函数会将文件内部指示器的当前位置，存储在指针变量<code>pos</code>。该函数接受两个参数，第一个是文件指针，第二个存储指示器位置的变量。</p>
<p><code>fsetpos()</code>函数会将文件内部指示器的位置，移动到指针变量<code>pos</code>指定的地址。注意，变量<code>pos</code>必须是通过调用<code>fgetpos()</code>方法获得的。<code>fsetpos()</code>的两个参数与<code>fgetpos()</code>必须是一样的。</p>
<p>记录文件内部指示器位置的指针变量<code>pos</code>，类型为<code>fpos_t*</code>（file position type 的缩写，意为文件定位类型）。它不一定是整数，也可能是一个 Struct 结构。</p>
<p>下面是用法示例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">fpos_t</span> file_pos;</span><br><span class="line">fgetpos(fp, &amp;file_pos);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一系列文件操作之后</span></span><br><span class="line">fsetpos(fp, &amp;file_pos);</span><br></pre></td></tr></table></figure>

<p>上面示例中，先用<code>fgetpos()</code>获取内部指针的位置，后面再用<code>fsetpos()</code>恢复指针的位置。</p>
<p>执行成功时，<code>fgetpos()</code>和<code>fsetpos()</code>都会返回<code>0</code>，否则返回非零值。</p>
<h2 id="ferror-，clearerr"><a href="#ferror-，clearerr" class="headerlink" title="ferror()，clearerr()"></a>ferror()，clearerr()</h2><p>所有的文件操作函数如果执行失败，都会在文件指针里面记录错误状态。后面的操作只要读取错误指示器，就知道前面的操作出错了。</p>
<p><code>ferror()</code>函数用来返回错误指示器的状态。可以通过这个函数，判断前面的文件操作是否成功。它的原型定义在头文件<code>stdio.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ferror</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p>它接受一个文件指针作为参数。如果前面的操作出现错误，<code>ferror()</code>就会返回一个非零整数（表示 true），否则返回<code>0</code>。</p>
<p><code>clearerr()</code>函数用来重置出错指示器。它的原型定义在头文件<code>stdio.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">clearerr</span><span class="params">(FILE* fp)</span>;</span><br></pre></td></tr></table></figure>

<p>它接受一个文件指针作为参数，没有返回值。</p>
<p>下面是一个例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FILE* fp = fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="type">char</span> c = fgetc(fp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ferror(fp)) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;读取文件：file.txt 时发生错误\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">clearerr(fp);</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>fgetc()</code>尝试读取一个以”写模式“打开的文件，读取失败就会返回 EOF。这时调用<code>ferror()</code>就可以知道上一步操作出错了。处理完以后，再用<code>clearerr()</code>清除出错状态。</p>
<p>文件操作函数如果正常执行，<code>ferror()</code>和<code>feof()</code>都会返回零。如果执行不正常，就要判断到底是哪里出了问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">fscanf</span>(fp, <span class="string">&quot;%d&quot;</span>, &amp;n) != <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ferror(fp)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;io error\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (feof(fp)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;end of file\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  clearerr(fp);</span><br><span class="line"></span><br><span class="line">  fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，当<code>fscanf()</code>函数报错时，通过检查<code>ferror()</code>和<code>feof()</code>，确定到底发生什么问题。这两个指示器改变状态后，会保持不变，所以要用<code>clearerr()</code>清除它们，<code>clearerr()</code>可以同时清除两个指示器。</p>
<h2 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h2><p><code>remove()</code>函数用于删除指定文件。它的原型定义在头文件<code>stdio.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">remove</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename)</span>;</span><br></pre></td></tr></table></figure>

<p>它接受文件名作为参数。如果删除成功，<code>remove()</code>返回<code>0</code>，否则返回非零值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remove(<span class="string">&quot;foo.txt&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例删除了<code>foo.txt</code>文件。</p>
<p>注意，删除文件必须是在文件关闭的状态下。如果是用<code>fopen()</code>打开的文件，必须先用<code>fclose()</code>关闭后再删除。</p>
<h2 id="rename"><a href="#rename" class="headerlink" title="rename()"></a>rename()</h2><p><code>rename()</code>函数用于文件改名，也用于移动文件。它的原型定义在头文件<code>stdio.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rename</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* old_filename, <span class="type">const</span> <span class="type">char</span>* new_filename)</span>;</span><br></pre></td></tr></table></figure>

<p>它接受两个参数，第一个参数是现在的文件名，第二个参数是新的文件名。如果改名成功，<code>rename()</code>返回<code>0</code>，否则返回非零值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename(<span class="string">&quot;foo.txt&quot;</span>, <span class="string">&quot;bar.txt&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例将<code>foo.txt</code>改名为<code>bar.txt</code>。</p>
<p>注意，改名后的文件不能与现有文件同名。另外，如果要改名的文件已经打开了，必须先关闭，然后再改名，对打开的文件进行改名会失败。</p>
<p>下面是移动文件的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename(<span class="string">&quot;/tmp/evidence.txt&quot;</span>, <span class="string">&quot;/home/beej/nothing.txt&quot;</span>);</span><br></pre></td></tr></table></figure>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/02/02/9e03d1990b4c477c8e5ecd52164183d1/" title="flow-control"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">flow-control</div></div></a></div><div class="next-post pull-right"><a href="/2023/02/01/044b8ce85ead497299e994db3a444991/" title="transparent"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">transparent</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">1.</span> <span class="toc-text">文件操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88"><span class="toc-number">1.1.</span> <span class="toc-text">文件指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fopen"><span class="toc-number">1.2.</span> <span class="toc-text">fopen()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E6%B5%81"><span class="toc-number">1.3.</span> <span class="toc-text">标准流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fclose"><span class="toc-number">1.4.</span> <span class="toc-text">fclose()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EOF"><span class="toc-number">1.5.</span> <span class="toc-text">EOF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#freopen"><span class="toc-number">1.6.</span> <span class="toc-text">freopen()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fgetc-%EF%BC%8Cgetc"><span class="toc-number">1.7.</span> <span class="toc-text">fgetc()，getc()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fputc-%EF%BC%8Cputc"><span class="toc-number">1.8.</span> <span class="toc-text">fputc()，putc()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fprintf"><span class="toc-number">1.9.</span> <span class="toc-text">fprintf()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fscanf"><span class="toc-number">1.10.</span> <span class="toc-text">fscanf()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fgets"><span class="toc-number">1.11.</span> <span class="toc-text">fgets()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fputs"><span class="toc-number">1.12.</span> <span class="toc-text">fputs()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fwrite"><span class="toc-number">1.13.</span> <span class="toc-text">fwrite()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fread"><span class="toc-number">1.14.</span> <span class="toc-text">fread()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#feof"><span class="toc-number">1.15.</span> <span class="toc-text">feof()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fseek"><span class="toc-number">1.16.</span> <span class="toc-text">fseek()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ftell"><span class="toc-number">1.17.</span> <span class="toc-text">ftell()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rewind"><span class="toc-number">1.18.</span> <span class="toc-text">rewind()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fgetpos-%EF%BC%8Cfsetpos"><span class="toc-number">1.19.</span> <span class="toc-text">fgetpos()，fsetpos()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ferror-%EF%BC%8Cclearerr"><span class="toc-number">1.20.</span> <span class="toc-text">ferror()，clearerr()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#remove"><span class="toc-number">1.21.</span> <span class="toc-text">remove()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rename"><span class="toc-number">1.22.</span> <span class="toc-text">rename()</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://meowrain.cn">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div></div></body></html>